<!DOCTYPE html>
<html lang="cn">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    <link rel="shortcut icon" type='image/x-icon' href="/blogs/favicon.svg">


    <!-- meta -->


<title>计算机图形学 | AlertNote</title>


    <meta name="keywords" content="算法">




    <!-- OpenGraph -->
 
    <meta name="description" content="概述部分帧缓冲器、分辨率与颜色种类之间的关系 单色图，每个像素1Bit 16色，每个像素4Bit（$2^4&#x3D;16$） 256色，每个像素1个字节（$2^8&#x3D;256$） 65,536(64K)色，每个像素2个字节（$2^{16}&#x3D;65536$） 16,777,216(16.7M)色，每个像素3个字节（$2^{24}&#x3D;16.7M$）（24位真彩色）  举例2M显存，在$1024*768$分辨率下数值为">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学">
<meta property="og:url" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/index.html">
<meta property="og:site_name" content="AlertNote">
<meta property="og:description" content="概述部分帧缓冲器、分辨率与颜色种类之间的关系 单色图，每个像素1Bit 16色，每个像素4Bit（$2^4&#x3D;16$） 256色，每个像素1个字节（$2^8&#x3D;256$） 65,536(64K)色，每个像素2个字节（$2^{16}&#x3D;65536$） 16,777,216(16.7M)色，每个像素3个字节（$2^{24}&#x3D;16.7M$）（24位真彩色）  举例2M显存，在$1024*768$分辨率下数值为">
<meta property="og:locale">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/img/graphics/3.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.3.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.4.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/4.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.3.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.4.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.5.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.6.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.7.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.8.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.9.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.10.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.11.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.12.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.13.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.3.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.4.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.5.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.4.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.1.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.3.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.6.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.7.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.1.1.jpg">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.1.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.2.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.3.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.4.png">
<meta property="og:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.5.png">
<meta property="article:published_time" content="2020-07-27T16:00:00.000Z">
<meta property="article:modified_time" content="2020-10-12T09:11:30.588Z">
<meta property="article:author" content="Alert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://msyqgzt.gitee.io/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.1.png">


    
<link rel="stylesheet" href="/blogs/css/style/main.css">
 


    
<link rel="stylesheet" href="/blogs/css/darkmode.css">

    
<script src="/blogs/js/darkmode.js"></script>



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/blogs/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
            <link rel="stylesheet" id="hl-dark-theme" href="/blogs/css/highlight/dark.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
        
    

    
    

     
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

    <!-- custom head -->

<meta name="generator" content="Hexo 5.2.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/blogs/" class="button">
            <span class="logo__text">
                AlertNote
            </span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/blogs/" class="navbar-menu button">
                        首页
                    </a>
                
                    <a href="/blogs/categories/" class="navbar-menu button">
                        分类
                    </a>
                
                    <a href="/blogs/tags/" class="navbar-menu button">
                        标签
                    </a>
                
                    <a href="/blogs/archives/" class="navbar-menu button">
                        归档
                    </a>
                
                    <a href="/blogs/friends/" class="navbar-menu button">
                        友链
                    </a>
                
                    <a href="/blogs/about/" class="navbar-menu button">
                        关于我
                    </a>
                
            </div>
        
        
        
    <a href="/blogs/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


         
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path>
                </svg>
            </a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/blogs/" class="dropdown-menu button">
                        首页
                    </a>
                
                    <a href="/blogs/categories/" class="dropdown-menu button">
                        分类
                    </a>
                
                    <a href="/blogs/tags/" class="dropdown-menu button">
                        标签
                    </a>
                
                    <a href="/blogs/archives/" class="dropdown-menu button">
                        归档
                    </a>
                
                    <a href="/blogs/friends/" class="dropdown-menu button">
                        友链
                    </a>
                
                    <a href="/blogs/about/" class="dropdown-menu button">
                        关于我
                    </a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        计算机图形学
    </h1>
    <div class="post-title__meta">
        <a href="/blogs/archives/2020/07/" class="post-meta__date button">
    2020-07-28
</a>
        
    <span class="separate-dot"></span><a href="/blogs/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="button">图形学</a>

 
        
    
     
    <span id="busuanzi_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span></span>
        <span id="busuanzi_value_page_pv"></span>
        <span>次访问</span>
    </span>



 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">概述部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2%E5%99%A8%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8E%E9%A2%9C%E8%89%B2%E7%A7%8D%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">帧缓冲器、分辨率与颜色种类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">直线扫描转换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86%E6%B3%95%EF%BC%88DDA%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">数值微分法（DDA）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%82%B9%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">中点画线算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">算法优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bresenham%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">Bresenham算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">算法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%AD%A5%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">分步改进思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">最终算法思路</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85"><span class="toc-number">3.</span> <span class="toc-text">多边形的扫描转换与区域填充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">多边形的扫描转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#X-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">X-扫描线算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">算法改进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">边缘填充算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">栅栏填充算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%A0%87%E5%BF%97%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">边界标志算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85"><span class="toc-number">3.2.</span> <span class="toc-text">区域填充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%9B%E8%BF%9E%E9%80%9A%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%EF%BC%88%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">简单四连通种子填充算法（区域填充递归算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">使用栈结构来实现简单的种子填充算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%B5%B0%E6%A0%B7"><span class="toc-number">4.</span> <span class="toc-text">反走样</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8A%A0%E6%9D%83%E5%8C%BA%E5%9F%9F%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">非加权区域采样方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%8C%BA%E5%9F%9F%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">加权区域采样方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E7%A6%BB%E6%95%A3%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">采用离散计算方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">裁剪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E8%A3%81%E5%89%AA"><span class="toc-number">5.1.</span> <span class="toc-text">直线裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%BC%94%E5%8F%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">算法演变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cohen-Sutherland%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">Cohen-Sutherland算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%82%B9%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">中点分割算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Liang-Barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">Liang-Barsky裁剪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">计算过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.4.3.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.1.4.4.</span> <span class="toc-text">算法举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA"><span class="toc-number">5.2.</span> <span class="toc-text">多边形裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sutherland-Hodgeman%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA"><span class="toc-number">5.2.1.</span> <span class="toc-text">Sutherland-Hodgeman多边形裁剪</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E8%A3%81%E5%89%AA"><span class="toc-number">5.3.</span> <span class="toc-text">文字裁剪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">消隐算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E9%9A%90"><span class="toc-number">6.1.</span> <span class="toc-text">什么是消隐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%9A%90%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">消隐的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%B6%88%E9%9A%90%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">按消隐对象分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%B6%88%E9%9A%90%E7%A9%BA%E9%97%B4%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.2.</span> <span class="toc-text">按消隐空间分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">物体空间的消隐算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Roberts%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Roberts算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">光线投射</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">图像空间的消隐算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Z%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Z-Buffer%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">Z缓冲区（Z-Buffer）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.3.1.1.</span> <span class="toc-text">算法原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B-1"><span class="toc-number">6.2.3.1.2.</span> <span class="toc-text">算法改进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%82%B9%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%8C%85%E5%90%AB%E6%80%A7%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.1.3.</span> <span class="toc-text">点与多边形的包含性检测方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">区间扫描线算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%AD%90%E5%88%86%E5%89%B2-Warnock-%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">区域子分割(Warnock)消隐算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">二维图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">7.1.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.</span> <span class="toc-text">向量的线性组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%B0%84%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">仿射组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%B8%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">凸组合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%BA%A6%E9%87%8F%E5%92%8C%E5%8D%95%E4%BD%8D%E5%90%91%E9%87%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">向量的度量和单位向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">7.1.3.</span> <span class="toc-text">向量运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E7%A7%AF"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">向量的点积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E7%A7%AF"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">向量的叉积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">图形坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.1.</span> <span class="toc-text">坐标系的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">坐标系的分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">计算机图形学中坐标系的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">7.3.1.</span> <span class="toc-text">图形变换的用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.</span> <span class="toc-text">图形变换的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-number">7.3.3.</span> <span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.</span> <span class="toc-text">基本几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">平移变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">比例变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">对称变换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">7.3.4.3.1.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.4.</span> <span class="toc-text">旋转变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.5.</span> <span class="toc-text">错切变换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.5.</span> <span class="toc-text">复合变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.6.</span> <span class="toc-text">坐标系之间的变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E4%BB%BB%E6%84%8F%E5%8F%82%E8%80%83%E7%82%B9%E7%9A%84%E4%BA%8C%E7%BB%B4%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.7.</span> <span class="toc-text">相对任意参考点的二维几何变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E3%80%81%E8%A7%86%E5%8C%BA%E5%8F%8A%E5%8F%98%E6%8D%A2"><span class="toc-number">7.4.</span> <span class="toc-text">窗口、视区及变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E5%8F%98%E6%8D%A2"><span class="toc-number">7.4.1.</span> <span class="toc-text">观察变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%B0%E8%A7%86%E5%8C%BA%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">7.4.2.</span> <span class="toc-text">窗口到视区的映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">三维图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E7%89%A9%E4%BD%93%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">三维物体基本几何变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.2.</span> <span class="toc-text">平移变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.3.</span> <span class="toc-text">比例变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">8.3.1.</span> <span class="toc-text">局部比例变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">8.3.2.</span> <span class="toc-text">整体比例变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.3.3.</span> <span class="toc-text">旋转变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95z%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">绕z轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95x%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">绕x轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95y%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">绕y轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.4.</span> <span class="toc-text">绕任意轴旋转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.4.</span> <span class="toc-text">对称变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9D%90%E6%A0%87%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">关于坐标平面的对称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9D%90%E6%A0%87%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.4.2.</span> <span class="toc-text">关于坐标轴对称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="toc-number">8.5.</span> <span class="toc-text">投影变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86-%E4%B8%AD%E5%BF%83-%E6%8A%95%E5%BD%B1%E6%B3%95"><span class="toc-number">8.5.1.</span> <span class="toc-text">透视(中心)投影法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E6%8A%95%E5%BD%B1"><span class="toc-number">8.5.2.</span> <span class="toc-text">平行投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E6%8A%95%E5%BD%B1-%E4%B8%89%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.</span> <span class="toc-text">正投影-三视图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.1.</span> <span class="toc-text">主视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AF%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.2.</span> <span class="toc-text">俯视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.3.</span> <span class="toc-text">侧视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.5.2.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E6%8A%95%E5%BD%B1-%E6%AD%A3%E8%BD%B4%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.</span> <span class="toc-text">正投影-正轴测图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E7%AD%89%E8%BD%B4%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.1.</span> <span class="toc-text">正等轴测图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E4%BA%8C%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.2.</span> <span class="toc-text">正二测图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-number">8.5.3.</span> <span class="toc-text">透视投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%82%B9%E9%80%8F%E8%A7%86"><span class="toc-number">8.5.3.1.</span> <span class="toc-text">一点透视</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E9%80%8F%E8%A7%86"><span class="toc-number">8.5.3.2.</span> <span class="toc-text">多点透视</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.5.3.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.</span> <span class="toc-text">曲线曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E5%9F%BA%E7%A1%80"><span class="toc-number">9.1.</span> <span class="toc-text">曲线曲面基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E3%80%81%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">显示、隐式和参数表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B"><span class="toc-number">9.1.2.</span> <span class="toc-text">参数方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.3.</span> <span class="toc-text">位置矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.4.</span> <span class="toc-text">切矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%8E%87"><span class="toc-number">9.1.5.</span> <span class="toc-text">曲率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.6.</span> <span class="toc-text">法矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%A0%E7%8E%87"><span class="toc-number">9.1.7.</span> <span class="toc-text">挠率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">9.1.8.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9F%E5%90%88"><span class="toc-number">9.1.9.</span> <span class="toc-text">拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E9%A1%BA"><span class="toc-number">9.1.10.</span> <span class="toc-text">光顺</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">曲线连续性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.1.</span> <span class="toc-text">参数连续性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.2.</span> <span class="toc-text">几何连续性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">参数化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BB%A3%E6%95%B0%E5%92%8C%E5%87%A0%E4%BD%95%E5%BD%A2%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">参数曲线的代数和几何形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.5.</span> <span class="toc-text">Bezier曲线与曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">9.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.2.</span> <span class="toc-text">一次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.3.</span> <span class="toc-text">二次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.4.</span> <span class="toc-text">三次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bernstein%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.5.</span> <span class="toc-text">Bernstein基函数的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.6.</span> <span class="toc-text">Bezier曲线的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">9.5.7.</span> <span class="toc-text">Bezier曲线的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">9.5.8.</span> <span class="toc-text">Bezier曲线的拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%8D%87%E9%98%B6%E4%B8%8E%E9%99%8D%E9%98%B6"><span class="toc-number">9.5.9.</span> <span class="toc-text">Bezier曲线的升阶与降阶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E5%8D%87%E9%99%8D%E9%98%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">9.5.9.1.</span> <span class="toc-text">Bezier曲线曲面升降阶的重要性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.5.10.</span> <span class="toc-text">Bezier曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.5.10.1.</span> <span class="toc-text">Bezier曲面的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.10.2.</span> <span class="toc-text">Bezier曲面的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%89%87%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">9.5.10.3.</span> <span class="toc-text">Bezier曲面片的拼接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E6%8E%A8-de-Castel-jau-%E7%AE%97%E6%B3%95%EF%BC%88%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%B1%82%E5%80%BC%EF%BC%89"><span class="toc-number">9.5.11.</span> <span class="toc-text">递推(de Castel jau)算法（曲面的求值）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1"><span class="toc-number">9.6.</span> <span class="toc-text">B样条</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E7%9A%84%E9%80%92%E6%8E%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.</span> <span class="toc-text">B样条的递推定义和性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#de-boor-Cox%E9%80%92%E6%8E%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">9.6.1.1.</span> <span class="toc-text">de boor-Cox递推定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#K%E9%98%B6B%E6%A0%B7%E6%9D%A1%E5%AF%B9%E5%BA%94%E8%8A%82%E7%82%B9%E5%90%91%E9%87%8F%E6%95%B0"><span class="toc-number">9.6.1.2.</span> <span class="toc-text">K阶B样条对应节点向量数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8C%BA%E9%97%B4"><span class="toc-number">9.6.1.3.</span> <span class="toc-text">B样条函数定义区间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.4.</span> <span class="toc-text">B样条基函数的主要性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.5.</span> <span class="toc-text">B样条函数的主要性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">9.6.1.6.</span> <span class="toc-text">B样条曲线类型的划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF-Quasi-uniform-B-spline-curve"><span class="toc-number">9.6.1.7.</span> <span class="toc-text">准均匀B样条曲线(Quasi-uniform B-spline curve)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5Bezier%E6%9B%B2%E7%BA%BF%EF%BC%88Piecewise-Bezier-Curve%EF%BC%89"><span class="toc-number">9.6.2.</span> <span class="toc-text">分段Bezier曲线（Piecewise Bezier Curve）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%EF%BC%88non-uniform-B-spline-curve%EF%BC%89"><span class="toc-number">9.6.3.</span> <span class="toc-text">非均匀B样条曲线（non- uniform B- spline curve）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.6.4.</span> <span class="toc-text">B样条曲面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%EF%BC%88%E9%9D%A2%EF%BC%89"><span class="toc-number">9.7.</span> <span class="toc-text">NURBS曲线（面）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.7.1.</span> <span class="toc-text">NURBS曲线的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.7.2.</span> <span class="toc-text">NURBS曲线的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.7.3.</span> <span class="toc-text">NURBS曲面的定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E5%AD%A6"><span class="toc-number">10.</span> <span class="toc-text">真实感图形学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">颜色模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">常用颜色模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">简单光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%89%A9%E7%90%86%E7%9F%A5%E8%AF%86"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">背景物理知识</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%8E%AF%E5%A2%83%E5%85%89-%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%EF%BC%89"><span class="toc-number">10.2.1.</span> <span class="toc-text">Phong光照模型（环境光+漫反射光+镜面反射光）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.3.</span> <span class="toc-text">增量式光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gouraud%E6%98%8E%E6%9A%97%E5%A4%84%E7%90%86"><span class="toc-number">10.3.1.</span> <span class="toc-text">Gouraud明暗处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E6%98%8E%E6%9A%97%E5%A4%84%E7%90%86"><span class="toc-number">10.3.2.</span> <span class="toc-text">Phong明暗处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">10.3.3.</span> <span class="toc-text">两种增量式光照模型比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">局部光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E5%85%89%E5%8F%8D%E5%B0%84"><span class="toc-number">10.4.1.</span> <span class="toc-text">自然光反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E5%8F%8D%E5%B0%84%E7%8E%87"><span class="toc-number">10.4.2.</span> <span class="toc-text">光反射率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E8%A1%B0%E5%87%8F"><span class="toc-number">10.4.3.</span> <span class="toc-text">光的衰减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC"><span class="toc-number">10.4.4.</span> <span class="toc-text">推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">10.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E9%80%8F%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.5.</span> <span class="toc-text">光透射模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Whitted%E5%85%89%E9%80%8F%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.5.1.</span> <span class="toc-text">Whitted光透射模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.6.</span> <span class="toc-text">整体光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA%EF%BC%88Ray-tracing%EF%BC%89"><span class="toc-number">10.6.1.</span> <span class="toc-text">光线跟踪（Ray tracing）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="toc-number">10.7.</span> <span class="toc-text">纹理映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E5%A4%84%E7%90%86"><span class="toc-number">10.8.</span> <span class="toc-text">阴影处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E7%AE%97%E6%B3%95"><span class="toc-number">10.8.1.</span> <span class="toc-text">阴影算法</span></a></li></ol></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">概述部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2%E5%99%A8%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8E%E9%A2%9C%E8%89%B2%E7%A7%8D%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">帧缓冲器、分辨率与颜色种类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">直线扫描转换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86%E6%B3%95%EF%BC%88DDA%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">数值微分法（DDA）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%82%B9%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">中点画线算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">算法优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bresenham%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">Bresenham算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">算法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%AD%A5%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">分步改进思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">最终算法思路</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85"><span class="toc-number">3.</span> <span class="toc-text">多边形的扫描转换与区域填充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">多边形的扫描转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#X-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">X-扫描线算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">算法改进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">边缘填充算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">栅栏填充算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%A0%87%E5%BF%97%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">边界标志算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85"><span class="toc-number">3.2.</span> <span class="toc-text">区域填充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%9B%E8%BF%9E%E9%80%9A%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%EF%BC%88%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">简单四连通种子填充算法（区域填充递归算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">使用栈结构来实现简单的种子填充算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%B5%B0%E6%A0%B7"><span class="toc-number">4.</span> <span class="toc-text">反走样</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8A%A0%E6%9D%83%E5%8C%BA%E5%9F%9F%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">非加权区域采样方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%8C%BA%E5%9F%9F%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">加权区域采样方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E7%A6%BB%E6%95%A3%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">采用离散计算方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">裁剪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E8%A3%81%E5%89%AA"><span class="toc-number">5.1.</span> <span class="toc-text">直线裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%BC%94%E5%8F%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">算法演变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cohen-Sutherland%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">Cohen-Sutherland算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%82%B9%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">中点分割算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Liang-Barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">Liang-Barsky裁剪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">计算过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.4.3.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.1.4.4.</span> <span class="toc-text">算法举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA"><span class="toc-number">5.2.</span> <span class="toc-text">多边形裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sutherland-Hodgeman%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA"><span class="toc-number">5.2.1.</span> <span class="toc-text">Sutherland-Hodgeman多边形裁剪</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E8%A3%81%E5%89%AA"><span class="toc-number">5.3.</span> <span class="toc-text">文字裁剪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">消隐算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E9%9A%90"><span class="toc-number">6.1.</span> <span class="toc-text">什么是消隐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%9A%90%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">消隐的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%B6%88%E9%9A%90%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">按消隐对象分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%B6%88%E9%9A%90%E7%A9%BA%E9%97%B4%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.2.</span> <span class="toc-text">按消隐空间分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">物体空间的消隐算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Roberts%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Roberts算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">光线投射</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">图像空间的消隐算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Z%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Z-Buffer%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">Z缓冲区（Z-Buffer）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.3.1.1.</span> <span class="toc-text">算法原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B-1"><span class="toc-number">6.2.3.1.2.</span> <span class="toc-text">算法改进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%82%B9%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%8C%85%E5%90%AB%E6%80%A7%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.1.3.</span> <span class="toc-text">点与多边形的包含性检测方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">区间扫描线算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%AD%90%E5%88%86%E5%89%B2-Warnock-%E6%B6%88%E9%9A%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">区域子分割(Warnock)消隐算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">二维图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">7.1.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.</span> <span class="toc-text">向量的线性组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%B0%84%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">仿射组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%B8%E7%BB%84%E5%90%88"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">凸组合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%BA%A6%E9%87%8F%E5%92%8C%E5%8D%95%E4%BD%8D%E5%90%91%E9%87%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">向量的度量和单位向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">7.1.3.</span> <span class="toc-text">向量运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E7%A7%AF"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">向量的点积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E7%A7%AF"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">向量的叉积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">图形坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.1.</span> <span class="toc-text">坐标系的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">坐标系的分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">计算机图形学中坐标系的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">7.3.1.</span> <span class="toc-text">图形变换的用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.2.</span> <span class="toc-text">图形变换的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-number">7.3.3.</span> <span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.</span> <span class="toc-text">基本几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">平移变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">比例变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">对称变换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">7.3.4.3.1.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.4.</span> <span class="toc-text">旋转变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.4.5.</span> <span class="toc-text">错切变换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.5.</span> <span class="toc-text">复合变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.6.</span> <span class="toc-text">坐标系之间的变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E4%BB%BB%E6%84%8F%E5%8F%82%E8%80%83%E7%82%B9%E7%9A%84%E4%BA%8C%E7%BB%B4%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">7.3.7.</span> <span class="toc-text">相对任意参考点的二维几何变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E3%80%81%E8%A7%86%E5%8C%BA%E5%8F%8A%E5%8F%98%E6%8D%A2"><span class="toc-number">7.4.</span> <span class="toc-text">窗口、视区及变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E5%8F%98%E6%8D%A2"><span class="toc-number">7.4.1.</span> <span class="toc-text">观察变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%B0%E8%A7%86%E5%8C%BA%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">7.4.2.</span> <span class="toc-text">窗口到视区的映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">三维图形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E7%89%A9%E4%BD%93%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">三维物体基本几何变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.2.</span> <span class="toc-text">平移变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.3.</span> <span class="toc-text">比例变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">8.3.1.</span> <span class="toc-text">局部比例变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%AF%94%E4%BE%8B%E5%8F%98%E6%8D%A2"><span class="toc-number">8.3.2.</span> <span class="toc-text">整体比例变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.3.3.</span> <span class="toc-text">旋转变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95z%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">绕z轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95x%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">绕x轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95y%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">绕y轴旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-number">8.3.3.4.</span> <span class="toc-text">绕任意轴旋转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2-1"><span class="toc-number">8.4.</span> <span class="toc-text">对称变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9D%90%E6%A0%87%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">关于坐标平面的对称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9D%90%E6%A0%87%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.4.2.</span> <span class="toc-text">关于坐标轴对称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="toc-number">8.5.</span> <span class="toc-text">投影变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86-%E4%B8%AD%E5%BF%83-%E6%8A%95%E5%BD%B1%E6%B3%95"><span class="toc-number">8.5.1.</span> <span class="toc-text">透视(中心)投影法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E6%8A%95%E5%BD%B1"><span class="toc-number">8.5.2.</span> <span class="toc-text">平行投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E6%8A%95%E5%BD%B1-%E4%B8%89%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.</span> <span class="toc-text">正投影-三视图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.1.</span> <span class="toc-text">主视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AF%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.2.</span> <span class="toc-text">俯视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">8.5.2.1.3.</span> <span class="toc-text">侧视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.5.2.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E6%8A%95%E5%BD%B1-%E6%AD%A3%E8%BD%B4%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.</span> <span class="toc-text">正投影-正轴测图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E7%AD%89%E8%BD%B4%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.1.</span> <span class="toc-text">正等轴测图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E4%BA%8C%E6%B5%8B%E5%9B%BE"><span class="toc-number">8.5.2.2.2.</span> <span class="toc-text">正二测图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-number">8.5.3.</span> <span class="toc-text">透视投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%82%B9%E9%80%8F%E8%A7%86"><span class="toc-number">8.5.3.1.</span> <span class="toc-text">一点透视</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E9%80%8F%E8%A7%86"><span class="toc-number">8.5.3.2.</span> <span class="toc-text">多点透视</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.5.3.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.</span> <span class="toc-text">曲线曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E5%9F%BA%E7%A1%80"><span class="toc-number">9.1.</span> <span class="toc-text">曲线曲面基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E3%80%81%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">9.1.1.</span> <span class="toc-text">显示、隐式和参数表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B"><span class="toc-number">9.1.2.</span> <span class="toc-text">参数方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.3.</span> <span class="toc-text">位置矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.4.</span> <span class="toc-text">切矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%8E%87"><span class="toc-number">9.1.5.</span> <span class="toc-text">曲率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E7%9F%A2%E9%87%8F"><span class="toc-number">9.1.6.</span> <span class="toc-text">法矢量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%A0%E7%8E%87"><span class="toc-number">9.1.7.</span> <span class="toc-text">挠率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">9.1.8.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9F%E5%90%88"><span class="toc-number">9.1.9.</span> <span class="toc-text">拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E9%A1%BA"><span class="toc-number">9.1.10.</span> <span class="toc-text">光顺</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">曲线连续性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.1.</span> <span class="toc-text">参数连续性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">9.2.2.</span> <span class="toc-text">几何连续性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">参数化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9B%B2%E7%BA%BF%E7%9A%84%E4%BB%A3%E6%95%B0%E5%92%8C%E5%87%A0%E4%BD%95%E5%BD%A2%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">参数曲线的代数和几何形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.5.</span> <span class="toc-text">Bezier曲线与曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">9.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.2.</span> <span class="toc-text">一次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.3.</span> <span class="toc-text">二次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1Bezier%E6%9B%B2%E7%BA%BF"><span class="toc-number">9.5.4.</span> <span class="toc-text">三次Bezier曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bernstein%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.5.</span> <span class="toc-text">Bernstein基函数的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.6.</span> <span class="toc-text">Bezier曲线的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">9.5.7.</span> <span class="toc-text">Bezier曲线的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">9.5.8.</span> <span class="toc-text">Bezier曲线的拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%8D%87%E9%98%B6%E4%B8%8E%E9%99%8D%E9%98%B6"><span class="toc-number">9.5.9.</span> <span class="toc-text">Bezier曲线的升阶与降阶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E5%8D%87%E9%99%8D%E9%98%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">9.5.9.1.</span> <span class="toc-text">Bezier曲线曲面升降阶的重要性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.5.10.</span> <span class="toc-text">Bezier曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.5.10.1.</span> <span class="toc-text">Bezier曲面的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.5.10.2.</span> <span class="toc-text">Bezier曲面的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bezier%E6%9B%B2%E9%9D%A2%E7%89%87%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">9.5.10.3.</span> <span class="toc-text">Bezier曲面片的拼接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E6%8E%A8-de-Castel-jau-%E7%AE%97%E6%B3%95%EF%BC%88%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%B1%82%E5%80%BC%EF%BC%89"><span class="toc-number">9.5.11.</span> <span class="toc-text">递推(de Castel jau)算法（曲面的求值）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1"><span class="toc-number">9.6.</span> <span class="toc-text">B样条</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E7%9A%84%E9%80%92%E6%8E%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.</span> <span class="toc-text">B样条的递推定义和性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#de-boor-Cox%E9%80%92%E6%8E%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">9.6.1.1.</span> <span class="toc-text">de boor-Cox递推定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#K%E9%98%B6B%E6%A0%B7%E6%9D%A1%E5%AF%B9%E5%BA%94%E8%8A%82%E7%82%B9%E5%90%91%E9%87%8F%E6%95%B0"><span class="toc-number">9.6.1.2.</span> <span class="toc-text">K阶B样条对应节点向量数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8C%BA%E9%97%B4"><span class="toc-number">9.6.1.3.</span> <span class="toc-text">B样条函数定义区间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.4.</span> <span class="toc-text">B样条基函数的主要性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">9.6.1.5.</span> <span class="toc-text">B样条函数的主要性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">9.6.1.6.</span> <span class="toc-text">B样条曲线类型的划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF-Quasi-uniform-B-spline-curve"><span class="toc-number">9.6.1.7.</span> <span class="toc-text">准均匀B样条曲线(Quasi-uniform B-spline curve)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5Bezier%E6%9B%B2%E7%BA%BF%EF%BC%88Piecewise-Bezier-Curve%EF%BC%89"><span class="toc-number">9.6.2.</span> <span class="toc-text">分段Bezier曲线（Piecewise Bezier Curve）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%EF%BC%88non-uniform-B-spline-curve%EF%BC%89"><span class="toc-number">9.6.3.</span> <span class="toc-text">非均匀B样条曲线（non- uniform B- spline curve）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E9%9D%A2"><span class="toc-number">9.6.4.</span> <span class="toc-text">B样条曲面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%EF%BC%88%E9%9D%A2%EF%BC%89"><span class="toc-number">9.7.</span> <span class="toc-text">NURBS曲线（面）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.7.1.</span> <span class="toc-text">NURBS曲线的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.7.2.</span> <span class="toc-text">NURBS曲线的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NURBS%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.7.3.</span> <span class="toc-text">NURBS曲面的定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%9B%BE%E5%BD%A2%E5%AD%A6"><span class="toc-number">10.</span> <span class="toc-text">真实感图形学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">颜色模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">常用颜色模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">简单光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%89%A9%E7%90%86%E7%9F%A5%E8%AF%86"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">背景物理知识</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%8E%AF%E5%A2%83%E5%85%89-%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%EF%BC%89"><span class="toc-number">10.2.1.</span> <span class="toc-text">Phong光照模型（环境光+漫反射光+镜面反射光）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.3.</span> <span class="toc-text">增量式光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gouraud%E6%98%8E%E6%9A%97%E5%A4%84%E7%90%86"><span class="toc-number">10.3.1.</span> <span class="toc-text">Gouraud明暗处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E6%98%8E%E6%9A%97%E5%A4%84%E7%90%86"><span class="toc-number">10.3.2.</span> <span class="toc-text">Phong明暗处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">10.3.3.</span> <span class="toc-text">两种增量式光照模型比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">局部光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E5%85%89%E5%8F%8D%E5%B0%84"><span class="toc-number">10.4.1.</span> <span class="toc-text">自然光反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E5%8F%8D%E5%B0%84%E7%8E%87"><span class="toc-number">10.4.2.</span> <span class="toc-text">光反射率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E8%A1%B0%E5%87%8F"><span class="toc-number">10.4.3.</span> <span class="toc-text">光的衰减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC"><span class="toc-number">10.4.4.</span> <span class="toc-text">推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">10.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E9%80%8F%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.5.</span> <span class="toc-text">光透射模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Whitted%E5%85%89%E9%80%8F%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.5.1.</span> <span class="toc-text">Whitted光透射模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.6.</span> <span class="toc-text">整体光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA%EF%BC%88Ray-tracing%EF%BC%89"><span class="toc-number">10.6.1.</span> <span class="toc-text">光线跟踪（Ray tracing）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="toc-number">10.7.</span> <span class="toc-text">纹理映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E5%A4%84%E7%90%86"><span class="toc-number">10.8.</span> <span class="toc-text">阴影处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E7%AE%97%E6%B3%95"><span class="toc-number">10.8.1.</span> <span class="toc-text">阴影算法</span></a></li></ol></li></ol></li></ol>
    </div>


<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h2 id="概述部分"><a href="#概述部分" class="headerlink" title="概述部分"></a>概述部分</h2><h3 id="帧缓冲器、分辨率与颜色种类之间的关系"><a href="#帧缓冲器、分辨率与颜色种类之间的关系" class="headerlink" title="帧缓冲器、分辨率与颜色种类之间的关系"></a>帧缓冲器、分辨率与颜色种类之间的关系</h3><ul>
<li>单色图，每个像素1Bit</li>
<li>16色，每个像素4Bit（$2^4=16$）</li>
<li>256色，每个像素1个字节（$2^8=256$）</li>
<li>65,536(64K)色，每个像素2个字节（$2^{16}=65536$）</li>
<li>16,777,216(16.7M)色，每个像素3个字节（$2^{24}=16.7M$）（24位真彩色）</li>
</ul>
<blockquote class="blockquote-note blockquote-note__[info]"><div class="blockquote-note__header">举例</div><div class="blockquote-note__content"><p>2M显存，在$1024*768$分辨率下<br>数值为  $2 * 1024 * 768 =‭ 1,572,864$‬<br>支持64K色，不支持24位真彩色</p>
</div></blockquote>

<h2 id="直线扫描转换算法"><a href="#直线扫描转换算法" class="headerlink" title="直线扫描转换算法"></a>直线扫描转换算法</h2><h3 id="数值微分法（DDA）"><a href="#数值微分法（DDA）" class="headerlink" title="数值微分法（DDA）"></a>数值微分法（DDA）</h3><blockquote>
<p>引进图形学中一个很重要的思想——增量思想</p>
</blockquote>
<p>$$<br>y_i = kx_i+b<br>$$</p>
<p>$$<br>\begin{split}<br>y_{i+1}&amp;=kx_{i+1}+b\\<br>&amp;=k(x_i+1)+b\\<br>&amp;=kx_i+b+k\\<br>&amp;=y_i+k<br>\end{split}<br>$$</p>
<p>$$<br>得到： y_{i+1}=y_i+k<br>$$</p>
<p>即 $当前步的y值 = 前一步的y值 + 斜率k（增量）$</p>
<hr>
<blockquote class="blockquote-note blockquote-note__[info]"><div class="blockquote-note__header">举例</div><div class="blockquote-note__content"><blockquote>
<p>要求：DDA扫描转换连接两点$ P_0(0,0)与P_1(5,3) $的直线段。</p>
<p>过程：$ k= {y_1-y_0 \over x_1-x_0}={3-0 \over 5-0}=0.6 $ <strong>&lt;1</strong> </p>
<p>根据$ y_{i+1}=y_i+k $，得到下表的计算结果</p>
</blockquote>
</div></blockquote>

<table>
<thead>
<tr>
<th align="center">X</th>
<th align="center">Y</th>
<th align="center">int(y+0.5)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0.6</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0.6+0.6</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1.2+0.6</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1.8+0.6</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2.4+0.6</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>但是此算法并不适用于$ |k| &gt;1 $的情况，会导致光栅点太稀疏。</p>
<p>优化后算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DDADrawLine::LineDDA</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> x = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">float</span> y = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">float</span> m = <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//添加增量，实现增量思想</span></span><br><span class="line">	<span class="keyword">float</span> dx = x1 - x0;</span><br><span class="line">	<span class="keyword">float</span> dy = y1 - y0;</span><br><span class="line">	<span class="keyword">if</span>(dx != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m = dy / dx;</span><br><span class="line">		<span class="keyword">if</span>(m &lt;= <span class="number">1</span> &amp;&amp; m &gt;= <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			y = y0;</span><br><span class="line">			<span class="comment">//斜率绝对值&lt;1,x递增绘制像素顶点</span></span><br><span class="line">			<span class="keyword">for</span>(x = x0; x &lt;= x1; x++)</span><br><span class="line">			&#123;</span><br><span class="line">				glVertex2i(x, <span class="keyword">int</span>(y + <span class="number">0.5</span>));</span><br><span class="line">				y += m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m &gt; <span class="number">1</span> || m &lt; <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			m = <span class="number">1</span> / m;<span class="comment">//将斜率设为倒数</span></span><br><span class="line">			x = x0;</span><br><span class="line">			<span class="comment">//斜率绝对值&gt;1,y递增绘制像素顶点</span></span><br><span class="line">			<span class="keyword">for</span>(y = y0; y &lt;= y1; y++)</span><br><span class="line">			&#123;</span><br><span class="line">				glVertex2i(<span class="keyword">int</span>(x + <span class="number">0.5</span>), y);</span><br><span class="line">				x += m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = x0;</span><br><span class="line">		<span class="keyword">int</span> y =<span class="number">0</span>;</span><br><span class="line">		y = (y0 &lt;= y1) ? y0 : y1;</span><br><span class="line">		<span class="keyword">int</span> d = <span class="built_in">fabs</span>((<span class="keyword">double</span>)(y0 - y1));</span><br><span class="line">		<span class="keyword">while</span>(d &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			glVertex2i(x, y);</span><br><span class="line">			y++;</span><br><span class="line">			d--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="中点画线算法"><a href="#中点画线算法" class="headerlink" title="中点画线算法"></a>中点画线算法</h3><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><blockquote>
<p>基本原理采用直线的一般方程：$ F(x,y) = Ax+By+C=0 $ </p>
<p><strong>其中：</strong>$ A=-(\Delta y);  B=(\Delta x);  C=-B(\Delta x)  $</p>
</blockquote>
<p>假定：$ 0 ≤ |k| ≤ 1 $， 因此每次在x方向+1，y方向+1或不变则需要判断。</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="2.1">

<p>当 点Q 在 点M 上方 ，则$ P_u $离直线近，应为下一个像素点</p>
<p>反之则$ P_d $离直线近，应取$ P_d $为下一个像素点</p>
<hr>
<p>为判断Q在M上方还是下方，把M带入理想直线方程：</p>
<ul>
<li><p>$\begin{split}d_i = F(x_m,y_m) &amp;= F(x_i+1,y_i+0.5) \\&amp;= A(x_i+1)+B(y_i+0.5)+C\end{split}$</p>
<ul>
<li><p>当$ d&lt;0 $时，Q在M上方，应取$ P_u $;</p>
</li>
<li><p>当$ d&gt;0 $时，Q在M下方，应取$ P_d $;</p>
</li>
<li><p>当$ d=0 $时，M在直线上，取$ P_u $ 或$ P_d $均可。</p>
</li>
</ul>
</li>
</ul>
<p>但此方法运算效率太低，因此需要优化。</p>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>$ \begin{split}d_0&amp;=F(x_{m0},y_{m0}) \\&amp;=F(A(x_i+1)+B(y_i+0.5))+C\end{split}$</p>
<p>计算出初值$ d_0=A+0.5B $</p>
<ul>
<li>$ d&lt;0 $情况下，推导d的增量关系：<ul>
<li>$\begin{split} d_1&amp;=F(x_{m1},y_{m1}) \\&amp;=F(A(x_i+2)+B(y_i+1.5))+C \\&amp;=F(A(x_i+1)+B(y_i+0.5))+C+A+B\end{split}$</li>
<li><strong>得到：</strong>$ d_1=d_0+A+B $</li>
</ul>
</li>
</ul>
<ul>
<li>$ d≥0 $情况下，推导d的增量关系：<ul>
<li>$\begin{split}d_1&amp;=F(x_{m1},y_{m1}) \\&amp;=F(A(x_i+2)+B(y_i+1.5))+C \\&amp;=F(A(x_i+1)+B(y_i+0.5))+C+A\end{split}$</li>
<li><strong>得到：</strong>$ d_1=d_0+A $</li>
</ul>
</li>
</ul>
<br/>

<h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><blockquote>
<p> Bresenham提供了一个更一般的算法。该算法不仅有好的效率，而且有更广泛的适用范围</p>
</blockquote>
<h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><blockquote>
<p>该算法的思想是通过各行、各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序，计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。</p>
</blockquote>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="2.2">

<p>假设每次x+1，y的递增（减）量为0或1，它取决于实际直线与最近光栅网格点的距离d，这个距离的最大误差为0.5。</p>
<p>误差项d的初值$ d_0=0 $，$ d_n=d_{n-1}+k $<br>一旦$ d≥1 $，就把它减去1，保证d的相对性，且区间为$ [0,1) $</p>
<p>$$<br>即：<br>\begin{cases}<br>  x_{i+1}=x_i+1\\<br>  y_{i+1}=<br>  \begin{cases}<br>   y_i+1 &amp;\text (d&gt;0.5)\\<br>   y_i &amp;\text (d≤0.5)<br>   \end{cases}<br>\end{cases}<br>$$</p>
<hr>
<h4 id="算法优化-1"><a href="#算法优化-1" class="headerlink" title="算法优化"></a>算法优化</h4><p>将此算法效率提升到整数加法</p>
<h5 id="分步改进思路"><a href="#分步改进思路" class="headerlink" title="分步改进思路"></a>分步改进思路</h5><p>改进1：<br>令$ e=d-0.5 $</p>
<p>$$<br>即：<br>\begin{cases}<br>  x_{i+1}=x_i+1\\<br>  y_{i+1}=<br>  \begin{cases}<br>   y_i+1 &amp;\text (e&gt;0)\\<br>   y_i &amp;\text (e≤0)<br>   \end{cases}<br>\end{cases}<br>$$</p>
<p>e&gt;0，y方向递增1；e&lt;0，y方向不递增</p>
<p>e=0时，可任取上、下光栅点显示</p>
<ul>
<li>改进后步骤<ul>
<li>$ e_初 =-0.5$</li>
<li>每走一步有$ e=e+k $</li>
<li>若$ e&gt;0 $，则$ e=e-1 $</li>
</ul>
</li>
</ul>
<hr>
<p>改进2：<br>$$<br>e_初=-0.5，k={dy \over dx}<br>$$</p>
<p>由于算法中只用到误差项的符号，于是可以用$ e·2·Δx $来替换$e$</p>
<ul>
<li>改进后步骤<ul>
<li>$ e_初 =-Δx $</li>
<li>每走一步有$ e=e+2Δy $</li>
<li>若$ e&gt;0 $，则$ e=e-2Δx $</li>
</ul>
</li>
</ul>
<hr>
<h5 id="最终算法思路"><a href="#最终算法思路" class="headerlink" title="最终算法思路"></a>最终算法思路</h5><blockquote>
<p>1.输入直线的两端点$ P(x_0，y_0)和P_1(x_1，y_1)$</p>
<p>2.计算初始值$ Δx、Δy、e=-Δx、x=x_0、y=y_0 $</p>
<p>3.绘制点$ (x,y) $</p>
<p>4.$ e $更新为$ e+2Δy $，判断$ e $的符号</p>
<ul>
<li><p>若$ e&gt;0 $，则$ (x,y) $更新为$ (x+1，y+1) $，同时将$ e $更新为$ e-2Δx $；</p>
</li>
<li><p>否则$ (x,y) $更新为 $ (x+1，y) $</p>
</li>
</ul>
<p>5.当直线没有画完时，重复步骤3和4，否则结束</p>
</blockquote>
<p>此算法不再依赖于直线的方程类型</p>
<h2 id="多边形的扫描转换与区域填充"><a href="#多边形的扫描转换与区域填充" class="headerlink" title="多边形的扫描转换与区域填充"></a>多边形的扫描转换与区域填充</h2><blockquote>
<p>如何在离散的像素集上表示一个连续的二维图形</p>
</blockquote>
<h3 id="多边形的扫描转换"><a href="#多边形的扫描转换" class="headerlink" title="多边形的扫描转换"></a>多边形的扫描转换</h3><blockquote>
<p><strong>定义</strong></p>
<p>多边形有两种重要的表示方法：顶点表示和点阵表示</p>
<ul>
<li><p>凸多边形：任意两顶点间的连线均在多边形内</p>
</li>
<li><p>凹多边形：任意两顶点间的连线有不在在多边形内</p>
</li>
<li><p>含内环的多边形：多边形内包含多边形</p>
</li>
</ul>
<p>光栅图形的一个基本问题是<strong>把任意多边形的顶点表示转换为点阵表示</strong>，这种转换称为多边形的扫描转换</p>
</blockquote>
<h4 id="X-扫描线算法"><a href="#X-扫描线算法" class="headerlink" title="X-扫描线算法"></a>X-扫描线算法</h4><blockquote>
<p><strong>基本思想</strong></p>
<p>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作</p>
</blockquote>
<h5 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h5><div style="float:right;">
    <img src="img/graphics/3.1.png" class="lazy" data-srcset="img/graphics/3.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="3.1" style="zoom:50%;">
</div>按X递增顺序 排列交点的X坐标序列


<ol>
<li><p>确定多边形所占有的<strong>最大扫描线数</strong>，得到多边形顶点的最小和最大y值（$ y_{min}和y_{max} $）</p>
</li>
<li><p>从$ y=y_{min} $到$ y=y_{max} $，每次用一条扫描线进行填充</p>
<ul>
<li>求交：计算扫描线与多边形各边的交点</li>
<li>排序：把所有交点<strong>按递增顺序</strong>进行排序</li>
<li>交点配对：第一个与第二个，第三个与第四个…</li>
<li>区间填色：把这些相交区间内的像素置成不同于背景色的填充色</li>
</ul>
</li>
</ol>
<hr>
<p>当扫描线与多边形顶点相交时，交点的取舍问题（交应保证为偶数个）：</p>
<blockquote>
<p><strong>解决方案</strong></p>
<ol>
<li><p>若共享顶点的两条边 分别落在扫描线的两边，交点只算一个</p>
</li>
<li><p>若共享顶点的两条边 在扫描线的同一边，这时交点作为0个或2个</p>
<ul>
<li>共享顶点的两条边的 另外两个端点的y值若大于交点y值，则算作2个点</li>
<li>共享顶点的两条边的 另外两个端点的y值若小于交点y值，则算作0个点</li>
</ul>
</li>
</ol>
</blockquote>
<p>此算法效率低，求交计算量非常大。</p>
<blockquote>
<p>从三方面考虑加以改进：</p>
<ol>
<li>在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算</li>
<li>考虑扫描线的连贯性。即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似</li>
<li>最后考虑多边形的连贯性。即当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交</li>
</ol>
</blockquote>
<h5 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h5><blockquote>
<p><strong>改进思路</strong></p>
<p>引入一种数据结构</p>
<p>（1）活性边表（AET）：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中。</p>
<p>（2）结点内容（一个结点在数据结构里可用结构来表示）</p>
</blockquote>
<p>$$<br> k={Δy \over Δx}={y_{i+1}-y_i \over x_{i+1}-x_i}<br>$$</p>
<p>$$<br>\implies x_{i+1}=x_i+{1 \over k}<br>$$</p>
<p>$$<br>即： Δx={1 \over k}<br>$$</p>
<p>另外，需要知道一条边何时不再与下一条扫描线相交，以便及时把它从有效边表中删除出去，避免下一步进行无谓的计算X</p>
<table>
<thead>
<tr>
<th align="center">$ x $</th>
<th align="center">$ Δx $</th>
<th align="center">$ y_{max} $</th>
<th align="center">next</th>
</tr>
</thead>
<tbody><tr>
<td align="center">当前扫描线与边的交点坐标</td>
<td align="center">从当扫描线到下条扫描线之间的x增量，即斜率的倒数</td>
<td align="center">该边所交的最高扫描线的坐标值</td>
<td align="center">指向下一条边的指针</td>
</tr>
</tbody></table>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="3.2">

<hr>
<p>为了方便活性边表的建立与更新，需构造一个新边表（NET），用来存放多边形的边的信息，分为4个步骤：<br>（1）首先构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个结点，称为一个吊桶，对应多边形覆盖的每一条扫描线<br>（2）NET挂在与该边低端y值相同的扫描线桶中。<br>也就是说，存放在该扫描线第一次出现的边</p>
<table>
<thead>
<tr>
<th align="center">$ y_{max} $</th>
<th align="center">$ x_{min} $</th>
<th align="center">$ 1 \over k $</th>
<th align="center">next</th>
</tr>
</thead>
<tbody><tr>
<td align="center">该边的$ y_{max} $</td>
<td align="center">该边较低点的x坐标值</td>
<td align="center">该边的斜率</td>
<td align="center">指向下一条具有相同较低端y坐标的边的指针</td>
</tr>
</tbody></table>
<p>每做一次新的扫描线时，要对已有的边进行三个处理</p>
<ol>
<li><p>是否被去除掉；</p>
</li>
<li><p>如果不被去除，第二就要对它的数据进行更新。所谓更新数据就是要更新它的x值</p>
</li>
</ol>
<p>$$<br>即： x+{1 \over k}<br>$$</p>
<ol start="3">
<li>看有没有新的边加入，新的边在NET里，可以插入排序插进来</li>
</ol>
<p>这个算法过程没有求交，这套数据结构避免了求交运算</p>
<p>此算法的<strong>缺点</strong>是无法实现对未知边界的区域填充</p>
<h4 id="边缘填充算法"><a href="#边缘填充算法" class="headerlink" title="边缘填充算法"></a>边缘填充算法</h4><p>基本思想是按任意顺序处理多边形的每条边。</p>
<p>在处理每条边时，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补）多边形的所有边处理完毕之后，填充即完成</p>
<h4 id="栅栏填充算法"><a href="#栅栏填充算法" class="headerlink" title="栅栏填充算法"></a>栅栏填充算法</h4><p>栅栏指的是一条过多边形顶点且与扫描线垂直的直线。</p>
<p>它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补。</p>
<h4 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h4><p>帧缓冲器中对多边形的每条边进行直线扫描转换，亦即对多边形边界所经过的像素打上标志，然后再采用和扫描线算法。</p>
<p>类似的方法将位于多边形内的各个区段着上所需颜色，由于边界标志，算法不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。</p>
<br/>

<h3 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h3><blockquote>
<p><strong>定义</strong></p>
<p>区域-—指已经表示成点阵形式的填充图形，是像素的集合<br>区域填充是指将区域内的一点（常称种子点）赋予给定颜色然后将这种颜色扩展到整个区域内的过程</p>
</blockquote>
<p>区域可采用内点表示和边界表示两种表示形式</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.3.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="3.3">

<p>内点表示：枚举出区域内部的所有像素，内部的所有像素着同一个颜色，边界像素着与内部像素不同的颜色</p>
<p>边界表示：枚举出边界上的所有像素，边界上的所有像素着同一个颜色，内部像素着与边界像素不同的颜色</p>
<p>区域填充算法要求区域是连通的，因为只有在连通区域中，才可能将种子点的颜色扩展到区域内的其它点。</p>
<hr>
<p>区域可分为4向连通区域和8向连通区域</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.4.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3.4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="3.4">

<ul>
<li>4向连通区域：指的是从区域上一点出发，可通过四个方向，即上、下、左、右移动的组合，在不越出区域的前提下，到达区域内的任意像素</li>
<li>8向连通区域：指的是从区域内每一像素出发，可通过八个方向，即上、下、左、右、左上、右上、左下、右下这八个方向的移动的组合来到达</li>
</ul>
<h4 id="简单四连通种子填充算法（区域填充递归算法）"><a href="#简单四连通种子填充算法（区域填充递归算法）" class="headerlink" title="简单四连通种子填充算法（区域填充递归算法）"></a>简单四连通种子填充算法（区域填充递归算法）</h4><blockquote>
<p>原理：假设在多边形区域内部有一像素已知，由此出发找到区域内的所有像素<br>用一定的颜色或灰度来填充假设区域采用边界定义，即区域边界上所有像素均具有某个特定值，区域内部所有像素均不取这一特定值，而边界外的像素则可具有与边界相同的值</p>
</blockquote>
<h5 id="使用栈结构来实现简单的种子填充算法"><a href="#使用栈结构来实现简单的种子填充算法" class="headerlink" title="使用栈结构来实现简单的种子填充算法"></a>使用栈结构来实现简单的种子填充算法</h5><p>算法原理：种子像素入栈，当栈非空时重复执行如下操作：</p>
<ol>
<li>栈顶像素出栈</li>
<li>将出栈像素置成要填充色</li>
<li>按左、上、右、下顺序检查与栈像素相邻的四个像素，若其中某个像素不在边界且未置成填充色，则把该像素入栈</li>
</ol>
<p>种子填充算法的不足之处：</p>
<ol>
<li>有些像素会入栈多次，降低算法效率；栈结构占空间</li>
<li>递归执行，算法简单，但效率不高。区域内每一像素都引进一次递归，进/出栈，费时费内存</li>
<li>改进算法，减少递归次数，提高效率可以采用区域填充的扫描线算法</li>
</ol>
<h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><blockquote class="blockquote-note blockquote-note__[info]"><div class="blockquote-note__header">概念</div><div class="blockquote-note__content"><blockquote>
<p>对直线、圆及椭圆这些最基本元素的生成速度和显示质量的改进，在图形处理系统中具有重要的应用价值但它们生成的线条具有明显的“锯齿形” 即会发生<strong>走样（Liasing）现象</strong></p>
<p>“锯齿”是“走样”（Aliasing）的一种形式。而走样是光栅显示的一种固有性质。产生走样现象的原因是像素本质上的离散性。</p>
<p>用于减少或消除走样效果的技术，称为反走样（Antialiasing）技术</p>
<p>由于图形的走样现象对图形的质量有很大影响，几乎所有图形处理系统都要对基本图形进行反走样处理</p>
</blockquote>
</div></blockquote>

<h3 id="非加权区域采样方法"><a href="#非加权区域采样方法" class="headerlink" title="非加权区域采样方法"></a>非加权区域采样方法</h3><p>根据物体的覆盖率（Coverage）计算像素的颜色</p>
<p>覆盖率 - 指某个像素区域被物体覆盖的比例</p>
<ul>
<li><p>非加权区域采样方法有两个缺点：</p>
<ol>
<li><p>像素的亮度与相交区域的面积成正比）而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应</p>
</li>
<li><p>直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差<br>每个像素的权值是一样的，这是它的主要缺点。所以也称非加权区域采样方法</p>
</li>
</ol>
</li>
</ul>
<h3 id="加权区域采样方法"><a href="#加权区域采样方法" class="headerlink" title="加权区域采样方法"></a>加权区域采样方法</h3><p>这种方法更符合人视觉系统对图像信息的处理方式，反走样效果更好</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/4.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/4.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="4.1">

<p>将直线段看作是具有一定宽度的狭长矩形；当直线段与像素有交时，根据相交区域与像素中心的距离来决定其对像素亮度的贡献</p>
<p>直线段对一个像素亮度的贡献正比于相交区域与像素中心的距离设置相交区域面积与像素中心距离的权函数（高斯函数）反映相交面积对整个像素亮度的贡献大小</p>
<p>利用权函数积分求相交区域面积，用它乘以像素可设置的最大亮度值，即可得到该像素实际显示的亮度值</p>
<h4 id="采用离散计算方法"><a href="#采用离散计算方法" class="headerlink" title="采用离散计算方法"></a>采用离散计算方法</h4><p>将一个像素划分为$ n=3×3 $个子像素，加权表可以取作：</p>
<p>$$<br>\begin{bmatrix}<br>   w_1 &amp; w_2 &amp; w_3 \\<br>   w_4 &amp; w_5 &amp; w_6 \\<br>   w_7 &amp; w_8 &amp; w_9<br>\end{bmatrix}<br>=\begin{bmatrix}<br>   1 &amp; 2 &amp; 1 \\<br>   2 &amp; 4 &amp; 2 \\<br>   1 &amp; 2 &amp; 1<br>\end{bmatrix}<br>$$</p>
<p>加权方案：</p>
<ul>
<li>中心子像素的加权 是角子像素的4倍，是其它像素的2倍，对九个子像素的每个网格所计算出的亮度进行平均</li>
<li>然后求出所有中心落于直线段内的子像素</li>
<li>最后计算所有这些子像素对原像素亮度贡献之和</li>
</ul>
<h2 id="裁剪算法"><a href="#裁剪算法" class="headerlink" title="裁剪算法"></a>裁剪算法</h2><blockquote>
<p><strong>裁剪：</strong></p>
<p>使用计算机处理图形信息时，计算机内部存储的图形往往比较大，而屏幕显示的只是图形的一部分</p>
<p>因此需要确定图形哪些部分落在显示区之内，哪些落在显示区之外。这个选择的过程就称为<em>裁剪</em></p>
<p>最简单的裁剪方法是把各种图形扫描转换为点之后，再判断点是否在窗口内。</p>
</blockquote>
<h3 id="直线裁剪"><a href="#直线裁剪" class="headerlink" title="直线裁剪"></a>直线裁剪</h3><h4 id="算法演变"><a href="#算法演变" class="headerlink" title="算法演变"></a>算法演变</h4><ol>
<li>点的裁剪</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.1">

<p>对于任意一点P（x,y），若满足下列两对不等式：</p>
<p>$x_{left}≤x≤x_{right}$<br>$y_{bottom}≤y≤y_{top}$</p>
<p>则点P在矩形窗口内；否则，点P在矩形窗口之外</p>
<p>判断图形中每个点是否在窗口内，太费时，一般不可取</p>
<ol start="2">
<li>直线的裁剪</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.2">

<p>要裁剪一条直线段，首先要判断：</p>
<ol>
<li>它是否完全落在裁剪窗口内？</li>
<li>它是否完全在窗口外？</li>
<li>如果不满足以上两个条件，则计算它与一个或多个裁剪边界的交点</li>
</ol>
<p>常用的裁剪算法有三种，即Cohen-Sutherland、中点分割法和Liang- Barsky裁剪算法</p>
<h4 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h4><p>又称为编码裁剪算法，算法的基本思想是对母条直线段分三种情况处理：</p>
<ol>
<li><p>若点p1和p完全在裁剪窗口内，则“简取”之，即保留这条直线</p>
</li>
<li><p>若点$p_1(x_1,y_1)$和$p_2(x_2,y_2)$均在窗口外，且满足下列四个条件之一：</p>
</li>
</ol>
<p>$$<br>\begin{cases}<br>x_1&lt;x_{left}且x_2&lt;x_{left}\\<br>x_1&gt;x_{right}且x_2&gt;x_{right}\\<br>y_1&lt;y_{bottom}且y_2&lt;y_{bottom}\\<br>y_1&gt;y_{top}且y_2&gt;y_{top}<br>\end{cases}<br>$$</p>
<p>对这四种类型的直线，“简弃”之</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.3.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.3">

<p>（3）如果直线段既不满足“简取”的条件，也不满足“简弃”的条件</p>
<p>需要对直线段按交点进行分段，分段后判断直线是“简取”还是”简弃”</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.4.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.4">

<p>每条线段的端点都赋以四位二进制码$D_3D_2D_1D_0$，编码规则如下：</p>
<ul>
<li><p>若$x&lt;x_{left}$,则$D_0=1$，否则$D_0=0$</p>
</li>
<li><p>若$x&gt;x_{right}$ ，则$D_1=1$，否则$D_1=0$</p>
</li>
<li><p>若$y&lt; y_{buttom}$，则$D_2=1$，否则$D_2=0$</p>
</li>
<li><p>若$y&gt;y_{top}$，则$D_3=1$，否则$D_3=0$</p>
</li>
</ul>
<p>窗口及其延长线所构成了9个区域。根据该编码规则：</p>
<p>$D_0$对应窗口左边界</p>
<p>$D_1$对应窗口右边界</p>
<p>$D_2$对应窗口下边界</p>
<p>$D_3$对应窗口上边界</p>
<p>裁剪一条线段时，先求出端点$p_1$和$p_2$的编码$code_1$和$code_2$</p>
<p>然后进行二进制“或”运算和“与”运算：</p>
<ul>
<li>若$code_1|code_2=0$，对直线段应”简取”之；</li>
<li>若$code_1 &amp; code_2≠0$，对直线段可”简弃”之；</li>
<li>若上述两条件均不成立，则需求出直线段与窗口边界的交点在交点处把线段一分为二。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">名称</th>
<th align="center">例子</th>
<th align="center">运算功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~</td>
<td align="center">位反</td>
<td align="center">~b</td>
<td align="center">求b的位反</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">与运算</td>
<td align="center">b&amp;c</td>
<td align="center">b和c位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">或运算</td>
<td align="center">b|c</td>
<td align="center">b和c位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">异或运算</td>
<td align="center">b^c</td>
<td align="center">b和b位异或</td>
</tr>
</tbody></table>
<hr>
<p>举例：</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.5.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.5">

<p>首先对$P_1、P_2$进行编码<br>或$_{0100}^{0001} \over _{0101}$</p>
<p>与$_{0100}^{0001} \over _{0000}$</p>
<p>对$P_2、P_3$重复上述处理</p>
<p>或$_{0000}^{0100} \over _{0100}$</p>
<p>与$_{0000}^{0100} \over _{0000}$</p>
<p>剩下的直线段（$P_3、P_4$）再进行进一步判断， $code_1、code_2=0$，全在窗口内，简取之</p>
<hr>
<p>此算法存在的问题：最坏情况下，被裁剪线段与窗口4条边计算交点，然后所得的裁剪结果却可能是全部舍弃</p>
<h4 id="中点分割算法"><a href="#中点分割算法" class="headerlink" title="中点分割算法"></a>中点分割算法</h4><p>和上面讲到的Cohen- Sutherland算法一样，首先对直线段的端点进行编码。</p>
<p>把线段和窗口的关系分成三种情况：</p>
<ol>
<li><p>完全在窗口内</p>
</li>
<li><p>完全在窗口外</p>
</li>
<li><p>和窗口有交点</p>
</li>
</ol>
<p>中点分割算法的核心思想是通过<strong>二分逼近</strong>来确定直线段与窗口的交点。</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.6.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.6">

<p>注意：</p>
<ol>
<li>若中点不在窗口内，则把中点和离窗口边界最远点构成的线段丢掉，以线段上的另一点和该中点再构成线段求其中点</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.7.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.7">

<ol start="2">
<li>如中点在窗口内，则又以中点和最远点构成线段，并求其中点，直到中点与窗口边界的坐标值在规定的误差范围内相等</li>
</ol>
<h4 id="Liang-Barsky裁剪算法"><a href="#Liang-Barsky裁剪算法" class="headerlink" title="Liang-Barsky裁剪算法"></a>Liang-Barsky裁剪算法</h4><h5 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h5><blockquote class="blockquote-note blockquote-note__[info]"><div class="blockquote-note__header">直线参数方程的标准形式为：</div><div class="blockquote-note__content"><p>$\begin{cases}x=x_0+tcosα\\y=y_0+tsinα\end{cases}(t为参数)$</p>
</div></blockquote>

<ol>
<li>用参数方程表示一条直线</li>
</ol>
<p>$\begin{cases}x=x_1+u·(x_2-x_1)=x_1+Δx·u\\y=y_1+u·(y_2-y_1)=y_1+Δy·u\end{cases}(0≤u＜1)$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.8.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.8">

<ol start="2">
<li><p>把被裁剪的直线段看成是一条<strong>有方向的线段</strong>，把窗口的四条边分成两类：<strong>入边</strong>和<strong>出边</strong>。</p>
<p>裁剪结果的线段起点是直线和两条入边的交点以及始端点三个点里最前面的一个点，即参数u最大的那个点；</p>
</li>
</ol>
<p>裁剪线段的终点是和两条出边的交点以及端点最后面的一个点，取参数$u$最小的那个点。</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.9.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.9">

<p>值得注意的是，当$u$从$-∞$到$+∞$遍历直线时，首先对裁剪窗口的两条边界直线（下边和左边）从外面向里面移动，再对裁剪窗口两条边界直线（上边和右边）从里面向外面移动。</p>
<p>如果用$u_1$，$u_2$分别表示线段（$u_1≤u_2$）可见部分的开始和结束</p>
<p>$u_1= max(0, u_r, u_b)$<br>$u_2= min(1,u_t,u_r)$</p>
<h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><p>由参数方程可知：$\begin{cases}x_{left}≤x_1+u·△x≤x_{right}\\y_{bottom}≤y_1+u·Δy≤y_{top}\end{cases}$</p>
<p>$\begin{cases}u·(-Δx)≤x_1-x_{left}\\<br>u·Δx≤x_{right}-x_{1}\\<br>u·(-Δy)≤y_1-y_{bottom}\\<br>u·Δy≤y_{top}-y_{1}\end{cases}$</p>
<p>令：$\begin{cases}<br>p_1=-Δx，q_1=x_1-x_{left}\\<br>p_2=Δx，q_2=x_{right}-x_1\\<br>p_3=-Δy，q_3=y_1-y_{bottom}\\<br>p_4=Δy，q_4=y_{top}-y_1<br>\end{cases}$</p>
<p>于是有：$u·p_k≤q_k，k=1,2,3,4$</p>
<p>$\begin{cases}<br>p_1=-Δx，q_1=x_1-x_{left}\\<br>p_3=-Δy，q_3=y_1-y_{bottom}\\<br>入边：左边和下边<br>\end{cases}$，$\begin{cases}<br>p_2=Δx，q_2=x_{right}-x_1\\<br>p_4=Δy，q_4=y_{top}-y_1\\<br>出边：右边和上边<br>\end{cases}$</p>
<p>（1）分析$P=0$的情况</p>
<ul>
<li>若$P_1=P_2=0$</li>
</ul>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.10.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.10">

<ul>
<li>若$P_3=P_4=0$</li>
</ul>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.11.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.11">

<p>可知，任何平行于窗口某边界的直线，其$p_k=0$</p>
<ul>
<li>如果还满足$q&lt;0$</li>
</ul>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.12.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.12">

<p>则线段完全在边界外，应舍弃该线段</p>
<p>（2）当$p≠0$时</p>
<p>当$p_k&lt;0$时，线段从裁剪边界延长线的外部延伸到内部，是入边交点</p>
<p>当$p_k&gt;0$时，线段从裁剪边界延长线的内部延伸到外部，是出边交点</p>
<p>线段和窗口边界一共有四个交点，根据$p$的符号，就知道哪两个是入交点，哪两个是出交点</p>
<p>当$p_k&lt;0$时：对应入边交点</p>
<p>当$p_k&gt;0$时：对应出边交点</p>
<p>共四个u值，再加上$u=0、u=1$两个端点值，总共六个值</p>
<p>把$p&lt;0$的两个$u$值和0比较找最大，把$p&gt;0$的两个u值和1比较找最小，</p>
<p>这样就得到两个端点的参数值</p>
<p>$u_k={q_k \over p_k}(p_k≠0，k=1,2,3,4)$</p>
<p>$u$是窗口边界及其延长线的交点的对应参数值</p>
<p>分别计算$u_{max}$和$u_{min}$</p>
<p>$\begin{cases}u_{max}=max(0,u_k|<em>{p_k&lt;0},u_k|_{p_k&lt;0})\\<br>u_{min}=min(u_k|_{p_k&gt;0},u_k|</em>{p_k&gt;0},1)\end{cases}$</p>
<p>注意：$p_k&lt;0$，代表入边；$p_k&gt;0$代表出边</p>
<p>若$u_{max}&gt;u_{min}$，则直线段在窗口外，删除该直线</p>
<p>若$u_{max}≤u_{min}$，将$u_{max}$和$u_{min}$<strong>代回直线参数方程</strong>，即求出直线与窗口的两实交点坐标。</p>
<p>注意：因为对于实交点$0≤u≤1$，因此$u_{max}$不能小于0，$u_{min}$不能大于1</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>输入直线段的两端点坐标$(x_1,y_1)、(x_2，y_2)$，以及窗口的四条边界坐标$：wxl、wxr、wyb和wyt$</p>
</li>
<li><p>若$ΔX=0$，则 $p_1=p_2=0$，此时<strong>进一步判断</strong>是否满足$q_1&lt;0$或$q_2&lt;0$</p>
<ul>
<li>若满足，则该直线段不在窗口内，算法转（7）结束。</li>
<li>否则满足$q1≥0且q2≥0$，则进一步计算$u_{max}$和$u_{min}$：</li>
</ul>
</li>
</ol>
<p>$$<br>\begin{cases}<br>u_{max}=max(0,u_k|_{p_k&lt;0})\\<br>u_{min}=min(1,u_k|_{p_k&gt;0})<br>\end{cases}<br>$$</p>
<p>其中，$u_k={q_k \over p_k}(p_k≠0,k=3,4)$。算法转(5)</p>
<ol start="3">
<li>若$Δy=0$，则$p_3=p_4=0$，此时<strong>进一步判断</strong>是否满足$q_3&lt;0$或$q_4&lt;0$，<ul>
<li>若满足，则该直线段不在窗口内，算法转（7）结束。</li>
<li>否则，满足$q_3≥0$且$q_4≥0$，则进一步计算$u_{max}$和$u_{min}$</li>
</ul>
</li>
</ol>
<p>$$<br>\begin{cases}<br>u_{max}=max(0,u_k|_{p_k&lt;0})\\<br>u_{min}=min(1,u_k|_{p_k&gt;0})<br>\end{cases}<br>$$</p>
<p>其中，$u_k={q_k \over p_k}(p_k≠0,k=3,4)$。算法转(5)</p>
<ol start="4">
<li>若上述两条均不满足，则有$p_k≠0(k=1,2,3,4)$，此时计算$u_{max}$和$u_{min}$</li>
</ol>
<p>$$<br>\begin{cases}<br>u_{max}=max(0,u_k|{p_k&lt;0},u_k|{p_k&lt;0})\\<br>u_{min}=min(1,u_k|{p_k&gt;0},u_k|{p_k&gt;0})<br>\end{cases}<br>$$</p>
<p>其中，$u_k={q_k \over p_k}(p_k≠0,k-3,4)$</p>
<ol start="5">
<li><p>求得$u_{max}$和$u_{min}$后，进行判断：</p>
<ul>
<li>若$u_{max}&gt;u_{min}$，则直线段在窗口外，算法转（7）。</li>
<li>若$u_{max}≤u_{min}$，利用直线的参数方程：</li>
</ul>
</li>
</ol>
<p>$$<br>\begin{cases}<br>x=x_1+u·(x_2-x_1)\\<br>y=y_1+u·(y_2-y_1)<br>\end{cases}<br>$$</p>
<ol start="6">
<li><p>利用直线的扫描转换算法绘制在窗口内的直线段。</p>
</li>
<li><p>结束</p>
</li>
</ol>
<h5 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h5><img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.13.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/5.13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="5.13">

<p>令：$\begin{cases}<br>p_1=-Δx，q_1=x_1-x_{left}\\<br>p_2=Δx，q_2=x_{right}-x_1\\<br>p_3=-Δy，q_3=y_1-y_{bottom}\\<br>p_4=Δy，q_4=y_{top}-y_1<br>\end{cases}$</p>
<ul>
<li><p>对于直线AB，有：$\begin{cases}<br>p_1=0，q_1=10\\<br>p_2=0，q_2=-2\\<br>p_3=-4，q_3=4\\<br>p_4=4，q_4=2<br>\end{cases}$，由于$q_2&lt;0$，判断AB完全在右边界之右</p>
</li>
<li><p>对于直线CD，有：$\begin{cases}<br>p_1=0，q_1=2\\<br>p_2=0，q_2=6\\<br>p_3=-3，q_3=5\\<br>p_4=3，q_4=1<br>\end{cases}$，由于$p_1、p_2=0$，$q_1、q_2&gt;0$，采取进一步判断</p>
</li>
</ul>
<p>$$<br>u_3={q_3 \over p_3}=-{5 \over 3},u_4={q_4 \over p_4}={1\over 3}<br>$$</p>
<p>$$<br>∴\begin{cases}<br>u_{max}=max(0,u_k|_{p_k&lt;0})=max(0,-{5 \over 3})=0\\<br>u_{min}=min(1,u_k|_{p_k&gt;0})=min(1,{1 \over 3})={1 \over 3}<br>\end{cases}<br>$$</p>
<p>此时$u_{max}≤u_{min}$，分别代入直线的参数方程：<br>$$<br>\begin{cases}<br>x=x_1+u·(x_2-x_1)\\<br>y=y_1+u·(y_2-y_1)<br>\end{cases}<br>$$<br>得到裁减后直线的两个端点是$(3,7)$和$(3,8)$。</p>
<ul>
<li>对于直线EF，有：$\begin{cases}<br>p_1=-2，q_1=5\\<br>p_2=2，q_2=3\\<br>p_3=-3，q_3=4\\<br>p_4=3，q_4=2<br>\end{cases}$，由于$p_{1,2,3,4}≠0$，$q_{1,2,3,4}&gt;0$，采取进一步判断</li>
</ul>
<p>$$<br>u_1={q_1 \over p_1}=-{5 \over 2},u_2={q_2 \over p_2}={3\over 2}\<br>u_3={q_3 \over p_3}=-{4 \over 3},u_4={q_4 \over p_4}={2\over 3}<br>$$</p>
<p>$$<br>∴\begin{cases}<br>u_{max}&amp;=max(0,u_k|{p_k&lt;0},u_k|{p_k&lt;0})\\&amp;=max(0,-{5 \over 2},-{4 \over 3})=0\\\\<br>u_{min}&amp;=min(1,u_k|{p_k&gt;0},u_k|{p_k&gt;0})\\&amp;=min(1,{3 \over 2},{2 \over 3})={2 \over 3}<br>\end{cases}，此时u_{max}&lt;u_{min}<br>$$</p>
<p>分别代入直线的参数方程：<br>$$<br>\begin{cases}<br>x=x_1+u·(x_2-x_1)\\<br>y=y_1+u·(y_2-y_1)<br>\end{cases}<br>$$<br>得到裁减后直线的两个端点是$(6,6)$和$(8,9)$。</p>
<br/>

<h3 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h3><blockquote>
<p>多边形裁剪算法的输出应该是裁剪后的多边形边界的顶点序列</p>
<p>需要构造能产生一个或多个封闭区域的多边形裁剪算法</p>
</blockquote>
<h4 id="Sutherland-Hodgeman多边形裁剪"><a href="#Sutherland-Hodgeman多边形裁剪" class="headerlink" title="Sutherland-Hodgeman多边形裁剪"></a>Sutherland-Hodgeman多边形裁剪</h4><blockquote>
<p>该算法的基本思想是将多边形边界作为一个整体，每次用窗口的一条边对要裁剪的多边形和中间结果多边形进行裁剪，体现一种分而治之的思想</p>
</blockquote>
<p>根据多边形每一边与窗口边所形成的位置关系，沿着多边形依次处理顶点，会遇到四种情况(方向为从端点S到端点P)：</p>
<ol>
<li><p>S在不可见侧面，而P在可见侧，交点与点P均被加入到输出顶点表中</p>
</li>
<li><p>是S和P都在可见侧，则P被加入到输出顶点表中</p>
</li>
<li><p>S在可见侧，而P在不可见侧，则交点被加入到输出顶点表</p>
</li>
<li><p>如果S和P都在不可见侧，输出顶点表中不增加任何顶点</p>
</li>
</ol>
<p>算法不足之处：在处理凹多边形时会产生多余线段</p>
<br/>

<h3 id="文字裁剪"><a href="#文字裁剪" class="headerlink" title="文字裁剪"></a>文字裁剪</h3><p>字符并不是由直线段组成的。文字裁剪包括以下几种：</p>
<ol>
<li>串精度裁剪</li>
</ol>
<blockquote>
<p>当字符串中的所有字符都在裁剪窗口内时，就全部保留它，否则舍弃整个字符串。</p>
</blockquote>
<ol start="2">
<li>字符精度裁剪</li>
</ol>
<blockquote>
<p>在进行裁剪时，任何与窗口有重叠或落在窗口边界以外的字符都被裁剪掉。</p>
</blockquote>
<ol start="3">
<li>笔划/像素精度裁剪</li>
</ol>
<blockquote>
<p>将笔划分解成直线段对窗口作裁剪。需判断字符串中各字符的哪些像素、笔划的哪一部分在窗口内，保留窗口内部分，裁剪掉窗口外的部分。</p>
</blockquote>
<h2 id="消隐算法"><a href="#消隐算法" class="headerlink" title="消隐算法"></a>消隐算法</h2><h3 id="什么是消隐"><a href="#什么是消隐" class="headerlink" title="什么是消隐"></a>什么是消隐</h3><blockquote>
<p>当我们观察空间任何一个不透明的物体时，只能看到该物体朝冋我们的那些表面，其余的表面由于被物体所遮挡我们看不到</p>
<p>如果把可见和不可见的线都画出来，对视觉会造成多义性</p>
<p>要消除二义性，就必须<strong>在绘制时消除被遮挡的不可见的线或面</strong>，习惯上称作消除隐藏线和隐藏面，简称为<strong>消隐</strong></p>
</blockquote>
<br/>

<h3 id="消隐的分类"><a href="#消隐的分类" class="headerlink" title="消隐的分类"></a>消隐的分类</h3><h4 id="按消隐对象分类"><a href="#按消隐对象分类" class="headerlink" title="按消隐对象分类"></a>按消隐对象分类</h4><blockquote>
<p>线消隐消隐对象是物体上的边，消除的是物体上不可见的边</p>
<p>面消隐消隐对象是物体上的面，消除的是物体上不可见的面，通常做真实感图形消隐时用面消隐</p>
</blockquote>
<h4 id="按消隐空间分类"><a href="#按消隐空间分类" class="headerlink" title="按消隐空间分类"></a>按消隐空间分类</h4><h5 id="物体空间的消隐算法"><a href="#物体空间的消隐算法" class="headerlink" title="物体空间的消隐算法"></a>物体空间的消隐算法</h5><blockquote>
<p>此类算法通常用于线框图的消隐</p>
</blockquote>
<p>以场景中的<strong>物体</strong>为处理单元。<br>假设场景中有$k$个物体，将其中一个物体与其余$k-1$个物体逐一比较仅显示它可见表面以达到消隐的目的</p>
<p>在物体空间里典型的消隐算法有两个：<em>Roberts算法</em>和<em>光线投射法</em></p>
<h5 id="Roberts算法"><a href="#Roberts算法" class="headerlink" title="Roberts算法"></a>Roberts算法</h5><ul>
<li>基本步骤<ul>
<li>逐个的独立考虑每个物体自身，找出为其自身所遮挡的边和面（自消隐）；</li>
<li>将每一物体上留下的边再与其它物体逐个的进行比较，以确定是完全可见还是部分或全部遮挡（两两物体消隐）；</li>
<li>确定由于物体之间的相互贯穿等原因，是否要形成新的显示边等，从而使被显示各物体更接近现实</li>
</ul>
</li>
</ul>
<h5 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h5><p>求光线与场景的交点，该光线就是所谓的视线（如视点与像素连成的线）<br>一条视线与场景中的物体可能有许多交点，求出这些交点后需要排序，在前面的才能被看到。人的眼睛可以一目了然，但计算机做需要大量的运算</p>
<hr>
<h4 id="图像空间的消隐算法"><a href="#图像空间的消隐算法" class="headerlink" title="图像空间的消隐算法"></a>图像空间的消隐算法</h4><blockquote>
<p>这类算法是消隐算法的主流</p>
</blockquote>
<p>以屏幕窗口内的<strong>每个像素</strong>为处理单元。</p>
<p>确定在每一个像素处，场景中的$k$个物体哪一个距离观察点最近，从而用它的颜色来显示该像素</p>
<h5 id="Z缓冲区（Z-Buffer）算法"><a href="#Z缓冲区（Z-Buffer）算法" class="headerlink" title="Z缓冲区（Z-Buffer）算法"></a>Z缓冲区（Z-Buffer）算法</h5><blockquote>
<p>Z缓冲器算法也叫深度缓冲器算法，属于图像空间消隐算法</p>
</blockquote>
<h6 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h6><p>该算法有<strong>帧缓冲器</strong>和<strong>深度缓冲器</strong>。</p>
<p>对应两个数组：</p>
<table>
<thead>
<tr>
<th align="center">intensity(x,y)<br/>属性数组（帧缓冲器）</th>
<th align="center">depth(x,y)<br/>深度数组（z-buffer）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储图像空间 每个可见像素的光强或颜色</td>
<td align="center">存放图像空间 每个可见像素的z坐标</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>算法思想：</strong></p>
<p>先将Z缓冲器中各单元的初始值置为最小值。</p>
<p>当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z缓冲器的单元中）</p>
<p>如果大于原来的z值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色</p>
</blockquote>
<ul>
<li><p>Z-Buffer算法的优点</p>
<ul>
<li>z- Buffer算法比较简单，也很直观</li>
<li>在像素级上以近物取代远物。与物体在屏幕上的出现顺序是无关紧要的，有利于硬件实现</li>
</ul>
</li>
<li><p>Z-Buffer算法的缺点</p>
<ul>
<li>占用空间大</li>
<li>没有利用图形的相关性与连续性，这是Z-Buffer算法的严重缺陷</li>
</ul>
</li>
</ul>
<h6 id="算法改进-1"><a href="#算法改进-1" class="headerlink" title="算法改进"></a>算法改进</h6><blockquote>
<p>一般认为，Z-Buffer算法需要开一个与图象大小相等的缓存数组zb，实际上，可以改进算法，只用一个深度缓存变量zb</p>
</blockquote>
<p><strong>关键问题：</strong>判断像素点$(i,j)$是否在$p_k$的投影多边形之内，不是一件容易的事。</p>
<p>节省了空间但牺牲了时间。计算机的很多问题就是在时间和空间上找平衡。</p>
<h6 id="点与多边形的包含性检测方法"><a href="#点与多边形的包含性检测方法" class="headerlink" title="点与多边形的包含性检测方法"></a>点与多边形的包含性检测方法</h6><blockquote class="blockquote-note blockquote-note__[tip]"><div class="blockquote-note__header">射线法</div><div class="blockquote-note__content"><p>由被测点P处向$y=-∞$方向作射线交点个数是奇数，则被测点在多边形内部交点个数是偶数，表示在多边形外部。</p>
<p>若射线正好经过多边形的顶点，则采用“左开右闭”的原则来实现</p>
<p>即：当射线与某条边的顶点相交时，若边在射线的左侧，则交点有效，计数；若边在射线的右侧，则交点无效，不计数</p>
<ul>
<li>用射线法来判断一个点是否在多边形内的<strong>弊端</strong>：<ul>
<li>计算量大</li>
<li>不稳定</li>
</ul>
</li>
</ul>
</div></blockquote>

<br/>

<blockquote class="blockquote-note blockquote-note__[tip]"><div class="blockquote-note__header">弧长法</div><div class="blockquote-note__content"><p>以p点为圆心，作单位圆，把边投影到单位圆上，对应一段段弧长，规定逆时针为正，顺时针为负，计算弧长代数和：</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="6.3.1">

<ul>
<li><p>代数和为0，点在多边形外部</p>
</li>
<li><p>代数和为2π，点在多边形内部</p>
</li>
<li><p>代数和为π，点在多边形边上</p>
</li>
</ul>
<p>####### 以顶点符号为基础的弧长累加方法</p>
<p>p是被测点，按照弧长法，p点的代数和为$2\pi$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="6.3.2">

<p>不计算角度，做一个规定来取代原来的弧长计算：</p>
<table>
<thead>
<tr>
<th align="center">$p_1$符号</th>
<th align="center">$p_n$符号</th>
<th align="center">弧长变化</th>
<th align="center">象限变化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(+,+)</td>
<td align="center">(+,+)</td>
<td align="center">0</td>
<td align="center">①→①</td>
</tr>
<tr>
<td align="center">(+,+)</td>
<td align="center">(-,+)</td>
<td align="center">$\pi \over 2$</td>
<td align="center">①→②</td>
</tr>
<tr>
<td align="center">(+,+)</td>
<td align="center">(-,-)</td>
<td align="center">$±\pi$</td>
<td align="center">①→③</td>
</tr>
<tr>
<td align="center">(+,+)</td>
<td align="center">(+,-)</td>
<td align="center">$-{\pi \over 2}$</td>
<td align="center">①→④</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>这样当要计算代数和的时候，就不要去投影了，只要根据点所在的象限一下子就判断出多少度，这样几乎没有什么计算量，只有一些简单的判断，效率非常高</p>
</div></blockquote>

<hr>
<h5 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h5><p>该算法放弃Z-Buffer的思想，是一个新的算法，这个算法被认为是消隐算法中最快的之一</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.3.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="6.3.3">

<p>扫描线的交点把这条扫描线分成了若干个区间，每个区间上必然是同样一种颜色</p>
<p>对于有重合的区间，如$a_6a_7$这个区间，要么显示F2的颜色，要么显示F3的颜色，不会出现颜色的跳跃</p>
<p>如果把扫描线和多边形的这些交点都求出来，对每个区间，只要判断一个像素的要画什么颜色，那么整个区间的颜色都解决了，这就是区间扫描线算法的主要思想</p>
<ul>
<li>如何确定小区间的颜色？<ol>
<li>小区间上没有任何多边形，如$[a_4，a_5]$，用背景色显示</li>
<li>小区间只有一个多边形，如$[a_1，a_2]$，显示该多边形的颜色</li>
<li>小区间上存在两个或两个以上的多边，比如$[a_6，a_7]$，必须通过深度测试判断哪个多边形可见</li>
</ol>
</li>
</ul>
<blockquote>
<p>这个算法存在几个问题：</p>
<ol>
<li>真的去求交点？——可以利用增量算法简化求交</li>
<li>每段区间上要求z值最大的面，这就存在一个问题。如何知道在这个区间上有哪些多边形是和这个区间相关的？</li>
</ol>
</blockquote>
<h5 id="区域子分割-Warnock-消隐算法"><a href="#区域子分割-Warnock-消隐算法" class="headerlink" title="区域子分割(Warnock)消隐算法"></a>区域子分割(Warnock)消隐算法</h5><blockquote>
<p>Warnock算法是图像空间中非常经典的一个算法</p>
<p>Warnock算法的重要性不在于它的效率比别的算法高，而在于采用了<strong>分而治之</strong>的思想，利用了堆栈的数据结构</p>
<p>把物体投影到全屏幕窗口上，然后<strong>递归分割</strong>窗口，直到窗口内目标足够简单，可以显示为止</p>
</blockquote>
<ul>
<li>这些情况下，画面足够简单，可以立即显示<ol>
<li>窗口中仅包含一个多边形</li>
<li>窗口与一个多边形相交，且窗口内无其它多边形</li>
<li>窗口为一个多边形所包围</li>
<li>窗口与一个多边形相分离</li>
</ol>
</li>
</ul>
<blockquote class="blockquote-note blockquote-note__[important]"><div class="blockquote-note__header">如何判别一个多边形和窗口是分离的？</div><div class="blockquote-note__content"><img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.4.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="6.3.4">

<p>当满足下列条件时，多边形和窗冂分离：</p>
<p>$$<br>x_{min}&gt;x_R \space {\color{red}or}\space x_{max}&lt;x_L \space {\color{red}or}\space y_{min}&gt;y_T \space {\color{red}or}\space y_{max}&lt;y_B<br>$$</p>
</div></blockquote>

<blockquote class="blockquote-note blockquote-note__[important]"><div class="blockquote-note__header">如何判别一个多边形在窗口内？</div><div class="blockquote-note__content"><img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.5.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/6.3.5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="6.3.5">

<p>当满足下列条件时，多边形被窗口包含：</p>
<p>$$<br>x_{min}≥ x_L \space {\color{red}\&amp;}\space x_{max}≤x_R \space {\color{red}\&amp;}\space y_{min}≥y_B \space {\color{red}\&amp;}\space y_{max}≤y_T<br>$$</p>
<p>多边形与窗口相交的判别：可以采用直线方程作为判别函数来判定一个多边形是否与窗口相交</p>
</div></blockquote>

<hr>
<blockquote>
<p><strong>窗口有多个多边形投影面，如何显示？</strong><br>算法步骤：</p>
<ol>
<li><p>如果窗口内没有物体则按背景色显示</p>
</li>
<li><p>若窗口内只有一个面，则把该面显示出来</p>
</li>
<li><p>否则，窗口内含有两个以上的面，则把窗口<strong>等分成四个子窗口</strong>。对每个小窗口再做上述同样的处理。这样反复地进行下去</p>
<p><em>把四个子窗口压在一个堆栈里（后进先出）</em></p>
</li>
</ol>
<p><strong>如果到某个时刻，窗口仅有像素那么大，而窗内仍有两个以上的面，如何处理？</strong><br>这时不必再分割，只要取窗口内最近的可见面的颜色或所有可见面的平均颜色，作为该像素的值</p>
</blockquote>
<h2 id="二维图形变换"><a href="#二维图形变换" class="headerlink" title="二维图形变换"></a>二维图形变换</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="向量的线性组合"><a href="#向量的线性组合" class="headerlink" title="向量的线性组合"></a>向量的线性组合</h4><p>有两种特殊的线性组合在计算机图形学中很重要</p>
<h5 id="仿射组合"><a href="#仿射组合" class="headerlink" title="仿射组合"></a>仿射组合</h5><p>如果线性组合的<strong>系数</strong>$a_1,a_2,…a_m$的和等于1，那么它就是仿射组合</p>
<p>$$<br>a_1+a_2+…+a_m=1<br>$$</p>
<h5 id="凸组合"><a href="#凸组合" class="headerlink" title="凸组合"></a>凸组合</h5><p>凸组合在数学中具有重要的位置，在图形学中也有很多应用。</p>
<p>凸组合是对仿射组合加以更多的限制得来的</p>
<p>$$<br>a_1+a_2+…+a_m=1(i=1,2,…,m,且a_i≥0)<br>$$</p>
<h4 id="向量的度量和单位向量"><a href="#向量的度量和单位向量" class="headerlink" title="向量的度量和单位向量"></a>向量的度量和单位向量</h4><ol>
<li>对n维向量：$w=(w_1,w_2,…,w_n)$，它的长度（大小）为：</li>
</ol>
<p>$$<br>|w|=\sqrt{w_1^2+w_2^2+…+w_n^2}<br>$$</p>
<ol start="2">
<li><p>有时经常需要缩放向量，使它的长度为1，这一过程叫恃量的归一化。</p>
<p>归一化的结果叫<strong>单位向量</strong>：</p>
</li>
</ol>
<p>$$<br>\hat{a}={a\over |a|}<br>$$</p>
<h4 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h4><h5 id="向量的点积"><a href="#向量的点积" class="headerlink" title="向量的点积"></a>向量的点积</h5><p>$$<br>\vec{a}=(a_1,a_2),\vec{b}=(b_1,b_2)，则\vec{a}·\vec{b}=a_1b_1+a_2b_2<br>$$</p>
<p>也就是说，计算点积时，只需将两个向量相应的分量相乘，然后将结果相加即可：<br>$$<br>d=\vec{v}·\vec{w}=\displaystyle\sum_{i=1}^n{v_iw_i}<br>$$<br>点积最重要的应用就是计算两个向量的夹角，或着两条直线的夹角<br>$$<br>\vec{b}·\vec{c}=|\vec{b}||\vec{c}|\cos\theta(\theta为夹角)<br>$$</p>
<p>$$<br>\cos\theta={\vec{b}·\vec{c}\over |\vec{b}||\vec{c}|}=\hat{\vec{b}}·\hat{\vec{c}}<br>$$</p>
<p>由于两个向量的点积和它们之间夹角的余弦成正比，可以得出以下关于两个非零向量夹角与点积的关系：<br>$$<br>\begin{cases}<br>\vec{b}·\vec{c}&gt;0,\theta&lt;90°\<br>\vec{b}·\vec{c}=0,\theta=90°\<br>\vec{b}·\vec{c}&lt;0,\theta&gt;90°<br>\end{cases}<br>$$</p>
<blockquote class="blockquote-note blockquote-note__[tip]"><div class="blockquote-note__header">余弦定理和新闻的分类</div><div class="blockquote-note__content"><blockquote>
<p>谷歌、百度的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放到一类中</p>
<p>如何设计一个算法来算出任意两篇新闻的相似性？</p>
<p>用一个向量来描述一篇新闻当夹角的余弦接近于1时，两条新闻相似，从而可以归成一类；</p>
<p>夹角的余弦越小，两条新闻越不相关</p>
</blockquote>
</div></blockquote>


<h5 id="向量的叉积"><a href="#向量的叉积" class="headerlink" title="向量的叉积"></a>向量的叉积</h5><p>两个向量的仅积是另一个三维向量。叉积只对三维向量有意义。</p>
<p>它有许多有用的属性，但最常用的一个是它与原来的两个向量都正交。<br>$$<br>\vec{a}=(a_x,a_y,a_z),\vec{b}=(b_x,b_y,b_z)<br>$$</p>
<p>$$<br>\vec{a}×\vec{b}=<br>\begin{vmatrix}<br>i &amp; j &amp; k\<br>a_x &amp; a_y &amp; a_z\<br>b_x &amp; b_y &amp; b_z<br>\end{vmatrix}<br>$$</p>
<ul>
<li><p>$\vec{a}×\vec{b}$和$\vec{a}、\vec{b}$两个向量都正交</p>
</li>
<li><p>$\vec{a}×\vec{b}$的长度等于由$\vec{a}$和$\vec{b}$决定的平行四边形面积：$\vec{a}×\vec{b}=|\vec{a}||\vec{b}|\sin\theta$</p>
</li>
</ul>
<h3 id="图形坐标系"><a href="#图形坐标系" class="headerlink" title="图形坐标系"></a>图形坐标系</h3><h4 id="坐标系的基本概念"><a href="#坐标系的基本概念" class="headerlink" title="坐标系的基本概念"></a>坐标系的基本概念</h4><blockquote>
<p>坐标系是建立图形与数之间对应联系的参考系</p>
</blockquote>
<h5 id="坐标系的分类"><a href="#坐标系的分类" class="headerlink" title="坐标系的分类"></a>坐标系的分类</h5><ul>
<li>从维度上看，可分为一维、二维、三维坐标系</li>
<li>从坐标轴之间的空间关系来看，可分为直角坐标系、极坐标系、圆柱坐标系、球坐标系等</li>
<li>在计算机图形学中，从物体（场景）的建模，到在不同显示设备上显示、处理图形时同样使用一系列的坐标系</li>
</ul>
<p>显然，希望将程序中用于描述对象几何信息的数值，和那些用于表示对象中大小和位置的数值区分开来</p>
<p>前者通常被看作一个建模(modeling)的任务，后者是一个观察(viewing)的任务</p>
<p>图形显示的过程就是<em>几何（对象）模型在不同坐标系之间的映射变换</em></p>
<h4 id="计算机图形学中坐标系的分类"><a href="#计算机图形学中坐标系的分类" class="headerlink" title="计算机图形学中坐标系的分类"></a>计算机图形学中坐标系的分类</h4><ol>
<li><p>世界坐标系</p>
<p>程序员可以用最适合他们手中问题的坐标系来描述对象，并且可以自动的缩放和平移图形，使得其能正确地在屏幕窗口中显示</p>
<p>世界坐标系是一个公共坐标系，是现实中物体或场景的统一参照系。计算机图形系统中涉及的其它坐标系都是参照它进行定义的</p>
</li>
<li><p>建模坐标系</p>
<p>又称为<strong>局部坐标系</strong>。每个物体（对象）有它自己的局部中心和坐标系</p>
<p>建模坐标系<em>独立于世界坐标系</em>来定义物体的几何特性</p>
</li>
<li><p>观察坐标系</p>
<p>观察坐标系主要用于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述</p>
<p>依据观察窗口的方向和形状在世界坐标系中定义的坐标系称为观察坐标系。观察坐标系用于指定图形的输出范围</p>
</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="7.2.1">

<p>二维观察变换的一般方法是在世界坐标系中指定一个观察坐标系统，以该系统为参考通过选定方向和位置来制定矩形剪裁窗口</p>
<ol start="4">
<li><p>设备坐标系</p>
<p>适合特定输出设备输出对象的坐标系。</p>
<p>比如屏幕坐标系在多数情况下，对于每一个具体的显示设备，都有一个单独的坐标系统</p>
</li>
<li><p>规范化坐标系</p>
<p>规范化坐标系独立于设备，能容易地转变为设备坐标系，是一个中间坐标系。</p>
<p>为使图形软件能在不同的设备之间移植，采用规范化坐标，坐标轴取值范围是0-1</p>
</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.2.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="7.2.2">

<h3 id="图形变换"><a href="#图形变换" class="headerlink" title="图形变换"></a>图形变换</h3><h4 id="图形变换的用途"><a href="#图形变换的用途" class="headerlink" title="图形变换的用途"></a>图形变换的用途</h4><p>图形变换和观察是计算机图形学的基础内容之一，也是图形显示过程中不可缺少的一个环节</p>
<p>一个简单的图形，通过各种变换（如：<strong>比例、旋转、镜象、错切、平移</strong>等）可以形成一个丰富多彩的图形或图案</p>
<h4 id="图形变换的基本原理"><a href="#图形变换的基本原理" class="headerlink" title="图形变换的基本原理"></a>图形变换的基本原理</h4><ul>
<li>仿射变换（Affine Transformation 或 Affine Map）是一种二维坐标到二维坐标之间的线性变换<ul>
<li>“平直性”。即：直线经过变换之后依然是直线</li>
<li>“平行性”。即：平行线依然是平行线，且直线上点的位置顺序不变</li>
<li>满足下列式子</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{cases}<br>x’=ax+by+m\\<br>y’=cx+dy+n<br>\end{cases}<br>$$</p>
<p>称为二维仿射变换(Affine transformation)，其中坐标x’和y都是原始坐标x和y的线性函数参数a,b,c,d,m和n是函数的系数</p>
<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>在二维平面内，我们是用一对坐标值$(x,y)$来表示一个点在平面内的确切位置，或着说是用一个向量$(x,y)$来标定一个点的位置</p>
<p>假如变换前的点坐标为$(x,y)$，变换后的点坐标为$(x*,y*)$</p>
<p>这个变换过程可以写成如下矩阵形式：<br>$$<br>[x*,y*]=[x,y]·M<br>$$</p>
<p>$$<br>\begin{cases}<br>x*=a_1x+b_1y+c_1\\<br>y*=a_2x+b_2y+c_2<br>\end{cases}<br>$$</p>
<p>$$<br>[x*,y*]=<br>\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>a_1 &amp; a_2\<br>b_1 &amp; b_2\<br>c_1 &amp; c_2<br>\end{bmatrix}<br>$$</p>
<p>上两式是完全等价的。对于向量(x1,y1)，可以在几何意义上理解为是<em>在第三维为常数的平面上</em>的一个二维向量。</p>
<p>这种用三维向量表示二维向量，或者一般而言，用一个$n+1$维的向量表示一个n维向量的方法称为<strong>齐次坐标表示法</strong></p>
<hr>
<p>如n维向量$(p_1,p_2,…,p_n)$表示为$(hp_1,hp_2,…,hp_n,h)$，其中h称为哑坐标。</p>
<p>普通坐标与齐次坐标的关系为“一对多”：$普通坐标×h \rightarrow 齐次坐标$</p>
<p>当$h=1$时，产生的齐次坐标称为“<strong>规格化坐标</strong>”，因为前n个坐标就是普通坐标系下的n维坐标</p>
<h4 id="基本几何变换"><a href="#基本几何变换" class="headerlink" title="基本几何变换"></a>基本几何变换</h4><h5 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h5><p>平移是指将p点沿直线路径从一个坐标位置移到另一个坐标位置的重定位过程</p>
<p>即新的坐标分别在x方向和y方向增加了一个增量和，使得：<br>$$<br>\begin{cases}<br>x*=x+T_x\\<br>y*=y+T_y<br>\end{cases}<br>$$<br>$T_x,T_y$称为平移矢量<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>T_x &amp; T_y &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x+T_x &amp; y+T_y &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<p>平移是一种不产生变形而移动物体的<strong>刚体变换</strong>，即物体上的每个点移动相同数量的坐标</p>
<h5 id="比例变换"><a href="#比例变换" class="headerlink" title="比例变换"></a>比例变换</h5><p>比例变换是指对p点相对于坐标原点沿×方向放缩$S_x$倍，沿y方向放缩$S_y$倍。其中$S_x$和$S_y$称为比例系数<br>$$<br>\begin{cases}<br>x*=x·S_x\\<br>y*=y·S_y<br>\end{cases}<br>$$<br>比例变换的齐次坐标计算形式如下：<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>S_x &amp; 0 &amp; 0\\<br>0 &amp; S_y &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}S_x·x &amp; S_y·y &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<p>缩放系数$S_x$和$S_y$可赋予任何正整数。值小于1缩小物体的尺寸，值大于1则放大物体，都指定为1，物体尺寸就不会改变</p>
<p>当$S_x=S_y$时，变换成为整体比例变换，用以下矩阵进行计算：<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; S<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; S\end{bmatrix}=<br>\begin{bmatrix}x\over S &amp; y\over S &amp; 1\end{bmatrix}<br>\end{split}<br>$$<br>整体比例变换时，若S&lt;0，图形整体缩小；若S&gt;1，图形整体放大；若0&lt;S&lt;1，发生关于原点的对称等比变换</p>
<h5 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h5><p>对称变换也称为反射变换或镜像变换，变换后的图形是原图形关于某一轴线或原点的镜像。</p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><ol>
<li>关于x轴对称<br>点P经过关于X轴的对称变换后形成点P，则$x*=x$且$y*=-y$，<br>写成齐次坐标的计算形式为：</li>
</ol>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; -y &amp; S\end{bmatrix}<br>\end{split}<br>$$</p>
<h5 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h5><p>二维旋转是指将P点绕坐标原点转动某个角度θ（逆时针为正，顺时针为负）得到新的点P的重定位过程</p>
<p>首先确定当基准点为坐标原点时，点位置P旋转的变换方程</p>
<blockquote>
<p>在极坐标系中点的原始坐标为：$\begin{cases}x=r\cos\alpha\\y=r\sin\alpha\end{cases}$</p>
</blockquote>
<p>应用标准三角特性，利用角度α和θ将转换后的坐标表示为：<br>$$<br>\begin{cases}<br>x*=r\cos(\alpha+\theta)=r\cos\alpha\cos\theta-r\sin\alpha\sin\theta\\<br>y*=r\sin(\alpha+\theta)=r\cos\alpha\sin\theta+r\sin\alpha\cos\theta<br>\end{cases}<br>$$<br>将$\begin{cases}x=r\cos\alpha\\y=r\sin\alpha\end{cases}$代入，就得到相对于原点在位置$(x,y)$处的点旋转θ角的变换方程：<br>$$<br>\begin{cases}<br>x*=r\cos(\alpha+\theta)=x\cos\theta-y\sin\theta\\<br>y*=r\sin(\alpha+\theta)=x\sin\theta+y\cos\theta<br>\end{cases}<br>$$</p>
<br/>

<p>因此二维图形绕原点<strong>逆时针</strong>旋转θ角的齐次坐标计算形式可写为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>\cos\theta &amp; \sin\theta &amp; 0 \\<br>-\sin\theta &amp; \cos\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br> x·\cos\theta-y·\sin\theta &amp; x·\sin\theta·\cos\theta &amp; 1<br> \end{bmatrix}<br>\end{split}<br>$$</p>
<p>因此二维图形绕原点<strong>顺时针</strong>旋转θ角的齐次坐标计算形式可写为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>\cos(-\theta) &amp; \sin(-\theta) &amp; 0\\<br>-\sin(-\theta) &amp; \cos(-\theta) &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<h5 id="错切变换"><a href="#错切变换" class="headerlink" title="错切变换"></a>错切变换</h5><p>在图形学的应用中，有时需要产生弹性物体的变形处理，这就要用到错切变换</p>
<p>x值或y值越小，错切量越小；x值或y值越大，错切量越大</p>
<p>其变换矩阵为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; b &amp; 0\\<br>c &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x+cy &amp; bx+y &amp; 1\end{bmatrix}<br>\end{split}<br>$$<br>例：沿x方向错切</p>
<p>当b=0时，有：$\begin{cases}x*=x+cy\\y*=y\end{cases}$</p>
<h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><p>复合变换是指图形作一次以上的几何变换，变换结果是<strong>每次的变换矩阵相乘</strong></p>
<p>在进行复合变换时，需要注意的是矩阵相乘的顺序</p>
<p>由于矩阵乘法不满足交换率，因此通常$T_1T_2≠T_2T_1$，即矩阵相乘的顺序不可交换</p>
<h4 id="坐标系之间的变换"><a href="#坐标系之间的变换" class="headerlink" title="坐标系之间的变换"></a>坐标系之间的变换</h4><p>图形变换经常需要从一个坐标系变换到另一个坐标系</p>
<blockquote>
<p>为了将$p(x_p,y_p)$点从$x0y$坐标系变换到$x’0’y’$坐标系，需建立变换使$x’0’y’$坐标系与$x0y$坐标系重合</p>
</blockquote>
<h4 id="相对任意参考点的二维几何变换"><a href="#相对任意参考点的二维几何变换" class="headerlink" title="相对任意参考点的二维几何变换"></a>相对任意参考点的二维几何变换</h4><p>比例、旋转变换等均与参考点相关。</p>
<p>如要对某个参考点$(x_f,y_f)$作二维几何变换，其变换过程如下：</p>
<ol>
<li>将固定点移至坐标原点，此时进行平移变换</li>
<li>针对原点进行二维几何变换</li>
<li>进行反平移，将固定点又移回到原来的位置</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于一个变换矩阵$T=\begin{bmatrix}<br>a &amp; b &amp; p\\<br>c &amp; d &amp; q\\<br>l &amp; m &amp; s<br>\end{bmatrix}$，可划分为四个部分</p>
<p>其中：</p>
<p>$T_1=\begin{bmatrix}<br>a &amp; b\\<br>c &amp; d<br>\end{bmatrix}$，影响图形的比例、旋转、对称、错切等变换</p>
<p>$T_2=\begin{bmatrix}l &amp; m\end{bmatrix}$，影响图形的平移变换</p>
<p>$T_3=\begin{bmatrix}p\\q\end{bmatrix}$，影响图形的投影变换，在二维图像显示中一般为$\begin{bmatrix}0\\0\end{bmatrix}$</p>
<p>$T_4=\begin{bmatrix}s\end{bmatrix}$，影响图形整体的比例变换</p>
<hr>
<p>几何变换均可表示成：$P*=P·T$的形式，其中，$P$为变换前二维图形的规范化齐次坐标，$P*$为变换后的规范化齐次坐标，T为变换矩阵。</p>
<ul>
<li>点的变换，通过变换矩阵$\begin{bmatrix}x* &amp; y* &amp; 1\end{bmatrix}=\begin{bmatrix}x &amp; y &amp; 1\end{bmatrix}·T$</li>
<li>直线的变换，直线的变换可以通过对直线<strong>两端点进行变换</strong>，从而改变直线的位置和方向，$\begin{bmatrix}x_1* &amp; y_1* &amp; 1\\x_2* &amp; y_2* &amp; 1\end{bmatrix}=\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\x_2 &amp; y_2 &amp; 1\end{bmatrix}·T$</li>
<li>多边形的变换，多边形变换是将变换矩阵作用到<strong>每个顶点</strong>的坐标位置，并按新的顶点坐标值和当前属性设置来生成新的多边形，$p=\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\x_2 &amp; y_2 &amp; 1\\x_3 &amp; y_3 &amp; 1\\… &amp; … &amp; …\\x_n &amp; y_n &amp; 1\end{bmatrix}$</li>
</ul>
<h3 id="窗口、视区及变换"><a href="#窗口、视区及变换" class="headerlink" title="窗口、视区及变换"></a>窗口、视区及变换</h3><blockquote>
<p>世界坐标系中要显示的区域（通常在观察坐标系内定义）称为<strong>窗口</strong></p>
<p>窗口映射到显示器（设备）上的区域称为<strong>视区</strong></p>
</blockquote>
<h4 id="观察变换"><a href="#观察变换" class="headerlink" title="观察变换"></a>观察变换</h4><blockquote>
<p>将窗口内的图形在视区中显示出来，必须经过将窗口到视区的变换处理，这种变换就是<strong>观察变换</strong>（Viewing Transformation）</p>
</blockquote>
<h4 id="窗口到视区的映射"><a href="#窗口到视区的映射" class="headerlink" title="窗口到视区的映射"></a>窗口到视区的映射</h4><blockquote>
<p>为了全部、如实地在视区中显示出窗口内的图形对象，就必须求出图形在窗口和视区间的映射关系</p>
<p>需要根据用户所定义的参数，找到窗口和视区之间的坐标对应关系</p>
</blockquote>
<p>窗口到视区的映射是基于一个等式，即对每一个在世界坐标下的点$(x,y)$，产生屏幕坐标系中的一个点$(sx,sy)$</p>
<p>这个映射是“保持比例”的映射</p>
<p>保持比例的性质，使得这个映射有<strong>线性形式</strong>：</p>
<p>$$<br>\begin{cases}<br>sx=Ax+C\\<br>sy=By+D<br>\end{cases},其中A、B、C、D为常数<br>$$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.4.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/7.4.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="7.4.1">

<p>首先考虑x的映射。保持比例的性质说明：<br>$$<br>{sx-vl\over sx-yl}={x-wl\over wr-wl}<br>$$</p>
<p>$$<br>sx={x-wl\over wr-wl}(vr-vl)+vl<br>$$</p>
<p>$$<br>sx={vr-vl\over wr-wl}·x+(vl-{vr-vl\over wr-wl}·wl)<br>$$</p>
<p>A看做缩放x的部分，而C看做常数：<br>$$<br>A={vr-vl\over wr-wl},C=vl-A·wl<br>$$</p>
<hr>
<p>同理，y方向上保持比例性质满足：<br>$$<br>{sy-vb\over vt-vb}={y-vb\over wt-wb}<br>$$</p>
<p>$$<br>B={vt-vv\over wt-wb},D=vb-B·wb<br>$$</p>
<p>这个映射可用于任意点$(x,y)$，不管它是否在窗口之中。在窗口中的点映射到视口中的点，在窗口外的点映射到视口外的点</p>
<h2 id="三维图形变换"><a href="#三维图形变换" class="headerlink" title="三维图形变换"></a>三维图形变换</h2><h3 id="三维物体基本几何变换"><a href="#三维物体基本几何变换" class="headerlink" title="三维物体基本几何变换"></a>三维物体基本几何变换</h3><blockquote>
<p>三维物体的几何变换是在二维方法基础上增加了对z坐标的考虑而得到的</p>
<p>与二维变换类似，引入齐次坐标表示</p>
<p>即：三维空间中某点的变换可以表示成点的齐次坐标与四阶的三维变换矩阵相乘</p>
</blockquote>
<p>$$<br>\begin{split}<br>p’&amp;=\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}=p·T_{3D}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>a &amp; b &amp; c &amp; p\\<br>d &amp; e &amp; f &amp; q\\<br>g &amp; h &amp; i &amp; r\\<br>l &amp; m &amp; n &amp; s<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<p>根据$T_{3D}$在变换中所起的具体作用，进一步可将$T_{3D}$分成四个矩阵。</p>
<p>即：<br>$$<br>T_{3D}=\begin{bmatrix}<br>a &amp; b &amp; c &amp; p\\<br>d &amp; e &amp; f &amp; q\\<br>g &amp; h &amp; i &amp; r\\<br>l &amp; m &amp; n &amp; s<br>\end{bmatrix}<br>$$</p>
<p>其中：<br>$$<br>T_1=\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i \\<br>\end{bmatrix},对点进行比例、对称、旋转、错切变换<br>$$</p>
<p>$$<br>T_2=\begin{bmatrix}l &amp; m &amp; n \end{bmatrix},对点进行平移变换<br>$$</p>
<p>$$<br>T_3=\begin{bmatrix}p\\q\\r\end{bmatrix},作用是进行透视投影变换<br>$$</p>
<p>$$<br>T_4=\begin{bmatrix}s\end{bmatrix},作用是产生整体比例变换<br>$$</p>
<h3 id="平移变换-1"><a href="#平移变换-1" class="headerlink" title="平移变换"></a>平移变换</h3><blockquote>
<p>若三维物体沿x,y,z方向上移动一个位置，而物体的大小与形状均不变，则称为平移变换</p>
</blockquote>
<p>点P的平移变换矩阵表示如下：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_t\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>T_x &amp; T_y &amp; T_z &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x+T_x &amp; y+T_y &amp; z+T_z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h3 id="比例变换-1"><a href="#比例变换-1" class="headerlink" title="比例变换"></a>比例变换</h3><blockquote>
<p>比例变换分局部比例变换和整体比例变换</p>
</blockquote>
<h4 id="局部比例变换"><a href="#局部比例变换" class="headerlink" title="局部比例变换"></a>局部比例变换</h4><p>局部比例变换由T_{2D}中<strong>主对角线元素</strong>决定，其它元素均为零。</p>
<p>当对$x,y,z$方向分别进行比例变换时，其变换的矩阵表示为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_s\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>a &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; e &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; i &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}ax &amp; ey &amp; iz &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h4 id="整体比例变换"><a href="#整体比例变换" class="headerlink" title="整体比例变换"></a>整体比例变换</h4><p>整体比例变换，可用以下矩阵表示：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_s\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; s<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; s\end{bmatrix}\\<br>&amp;=\begin{bmatrix}{x\over s} &amp; {y\over s} &amp; {z\over s} &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h4 id="旋转变换-1"><a href="#旋转变换-1" class="headerlink" title="旋转变换"></a>旋转变换</h4><p>三维立体的旋转变换，是指给定的三维立体绕三维空间<strong>某个指定的坐标轴</strong>旋转θ角度</p>
<p>旋转后，立体的空间位置将发生变化，但形状不变。</p>
<blockquote>
<p>θ角的正负按右手规则确定，右手大姆指指向旋转轴的正向，其余四个手指指向旋转角的正向</p>
</blockquote>
<h5 id="绕z轴旋转"><a href="#绕z轴旋转" class="headerlink" title="绕z轴旋转"></a>绕z轴旋转</h5><p>三维空间立体绕z轴正向旋转时，立体上各顶点的<strong>x,y坐标改变，而z坐标不变</strong>。</p>
<p>而x,y坐标可由二维点绕原点旋转公式得到，因此可得：<br>$$<br>\begin{cases}<br>x*=x\cos\theta-y\sin\theta \\<br>y*=xsin\theta+y\cos\theta<br>\end{cases}<br>$$</p>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_{R_z}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>\cos\theta &amp; \sin\theta &amp; 0 &amp; 0\\<br>-\sin\theta &amp; \cos\theta &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x·\cos-y·\sin\theta &amp; x·\sin\theta+y·\cos\theta &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h5 id="绕x轴旋转"><a href="#绕x轴旋转" class="headerlink" title="绕x轴旋转"></a>绕x轴旋转</h5><p>同理，三维点p绕x轴正向旋转θ角的矩阵计算形式为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_{R_x}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; \cos\theta &amp; \sin\theta &amp; 0\\<br>0 &amp; \sin\theta &amp; \cos\theta &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; y·\cos\theta-z·\sin\theta &amp; y·\sin\theta+z·\cos\theta &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h5 id="绕y轴旋转"><a href="#绕y轴旋转" class="headerlink" title="绕y轴旋转"></a>绕y轴旋转</h5><p>三维点p绕y轴正向旋转θ角的矩阵计算形式为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_{R_y}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>\cos\theta &amp; 0 &amp; -\sin\theta &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>\sin\theta &amp; 0 &amp; \cos\theta &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x·\sin\theta+x·\cos\theta &amp; y &amp; z·\cos\theta-x·\sin\theta &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h5 id="绕任意轴旋转"><a href="#绕任意轴旋转" class="headerlink" title="绕任意轴旋转"></a>绕任意轴旋转</h5><blockquote>
<p>求绕任意直线旋转矩阵的原则：</p>
<ol>
<li>任意变换的问题——基本几何变换的问题</li>
<li>绕任意直线旋转的问题——绕坐标轴旋转的问题</li>
</ol>
</blockquote>
<h3 id="对称变换-1"><a href="#对称变换-1" class="headerlink" title="对称变换"></a>对称变换</h3><p>对称变换有关于坐标平面、坐标轴等的对称变换。</p>
<h4 id="关于坐标平面的对称"><a href="#关于坐标平面的对称" class="headerlink" title="关于坐标平面的对称"></a>关于坐标平面的对称</h4><ul>
<li>关于xoy平面进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_{xy}}&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; -z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<ul>
<li>关于yoz平面进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_{yz}}&amp;=\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}-x &amp; y &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<ul>
<li>关于zox平面进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_{zx}}&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; -y &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h4 id="关于坐标轴对称"><a href="#关于坐标轴对称" class="headerlink" title="关于坐标轴对称"></a>关于坐标轴对称</h4><ul>
<li>关于x轴进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_x}&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x &amp; -y &amp; -z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<ul>
<li>关于y轴进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_y}&amp;=\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}-x &amp; y &amp; -z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<ul>
<li>关于z轴进行对称变换</li>
</ul>
<p>$$<br>\begin{split}<br>T_{F_z}=\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; -1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}-x &amp; -y &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><blockquote>
<p>用于在二维平面上显示三维物体</p>
</blockquote>
<p>平面几何投影的投影变换，就是把三维物体投射到投影面上得到二维平面图形</p>
<p>需要记住的一点是，计算机绘图是产生三维物体的二维图像。但在屏幕上绘制图形的时候，必须在三维坐标系下来考虑画法</p>
<p>在创建一个三维图形时，不要考虑二维平面图像</p>
<p>两种投影法的本质区别在于，透视投影的投影中心到投影面之间的距离是有限的；而另一个的距离是无限的</p>
<h4 id="透视-中心-投影法"><a href="#透视-中心-投影法" class="headerlink" title="透视(中心)投影法"></a>透视(中心)投影法</h4><p>在投影中心相对投影面 确定的情况下，空间的一个点在投影面上只存在唯一一个投影</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="8.5.1">

<p>透视投影特点：</p>
<ul>
<li><p>物体的投影视图 由计算投影线与观察平面之交点而得</p>
</li>
<li><p>透视投影生成真实感视图但不保持相关比例</p>
</li>
</ul>
<h4 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h4><p>如果把透视投影的中心移至无穷远处，则各投影线成为相互平行的直线，这种投影法称为平行投影法。</p>
<blockquote>
<p>平行投影特点：</p>
<ul>
<li><p>平行投影保持物体的有关比例不变</p>
</li>
<li><p>变物体的各个面的精确视图由平行投影而得</p>
</li>
<li><p>没有给出三维物体外表的真实性表示</p>
</li>
</ul>
</blockquote>
<p><strong>正投影</strong>根据投影面与坐标轴的夹角可分为两类：三视图和正轴侧图</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="8.5.2">

<blockquote>
<p>当投影面与某一坐标轴垂直时，得到的投影为三视图，这时投影方向与这个坐标轴的方向一致；</p>
<p>否则，得到的投影为正轴侧图</p>
</blockquote>
<h5 id="正投影-三视图"><a href="#正投影-三视图" class="headerlink" title="正投影-三视图"></a>正投影-三视图</h5><blockquote>
<p>通常所说的三视图包括主视图、侧视图和俯视图三种，投影面分别与x轴、y轴和z轴垂直</p>
<p><strong>特点：</strong>物体的一个坐标面平行于投影面，其投影能反映形体的实际尺寸工程制图中常用三视图来测量形体间的距离、角度以及相互位置关系</p>
<p><strong>不足：</strong>一组三视图上只有物体一个面的投影，所以三视图难以形象地表示出形体的三维性质，只有将主、侧、俯三个视图放在一起，才能综合出物体的空间形状</p>
</blockquote>
<p><strong>计算步骤：</strong></p>
<ol>
<li>确定三维物体上各点的位置坐标</li>
<li>引入齐次坐标，求出所作变换相应的变换矩</li>
<li>将所作变换用矩阵表示，通过运算求得三维物体上各点经变换后的点坐标值</li>
<li>由变换后得到的二维点绘出三维物体投影后的三视图</li>
</ol>
<hr>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/8.5.2.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="8.5.2.1">

<h6 id="主视图"><a href="#主视图" class="headerlink" title="主视图"></a>主视图</h6><p>由投影变换前后三维物体上点到主视图上点的关系</p>
<p>投影变换的变换矩阵应为：<br>$$<br>T_v=T_{xOz}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br>通常称$T_v$为<strong>主视图</strong>的投影变换矩阵。</p>
<p>于是，由三维物体到主视图的投影变换矩阵表示为：<br>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_v\\<br>&amp;=\begin{bmatrix}x &amp; 0 &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$<br><br/></p>
<h6 id="俯视图"><a href="#俯视图" class="headerlink" title="俯视图"></a>俯视图</h6><p>将三维物体x0y面（又称H面）作垂直投影得到俯视图</p>
<p>其投影变换矩阵应为：<br>$$<br>T_H=T_{xOy}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_H\\<br>&amp;=\begin{bmatrix}x &amp; y &amp; 0 &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<p>为了使俯视图与主视图都画在一个平面内，就要使H面绕x轴顺时针转90°</p>
<p>即应有一个旋转变换，其变换矩阵为：<br>$$<br>\begin{split}<br>T_{R_x}&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; \cos(-90°) &amp; \sin(-90°) &amp; 0\\<br>0 &amp; -\sin(-90°) &amp; \cos(-90°) &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<p>为了使主视图和俯视图有一定的间距，还要使H面沿z方向<strong>平移</strong>一段距离$-z_0$，</p>
<p>其变换矩阵为：<br>$$<br>T_{t_z}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; -z_0 &amp; 1<br>\end{bmatrix}<br>$$<br>于是，俯视图的投影变换矩阵：<br>$$<br>\begin{split}<br>T_H&amp;=T_{xOy}·T_{R_x}·T_{t_z}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>·\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>·\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; -z_0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; -z_0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_H\\<br>&amp;=\begin{bmatrix}x &amp; 0 &amp; -(y+z_0) &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<br/>

<h6 id="侧视图"><a href="#侧视图" class="headerlink" title="侧视图"></a>侧视图</h6><p>将三维物体yOz面（又称W面）作垂直投影得到侧视图</p>
<p>其投影变换矩阵应为：<br>$$<br>T_W=T_{yOz}=\begin{bmatrix}<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p>
<p>为了使侧视图与主视图也在一个平面内，就要使W面绕轴正转90°</p>
<p>其旋转变换换矩阵为：<br>$$<br>\begin{split}<br>T_{R_z}&amp;=\begin{bmatrix}<br>\cos90°  &amp; \sin90° &amp; 0 &amp; 0\\<br>-\sin90°  &amp; \cos90° &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$<br>为使主视图和侧视图有一定的间距，还要使W面沿负x方向平移一段距离$-x_0$</p>
<p>该平移变换矩阵为：<br>$$<br>T_{t_x}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>-x_0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br>于是，侧视图的投影变换矩阵为：<br>$$<br>\begin{split}<br>T_W&amp;=T_{yOz}·T_{R_z}·T_{t_x}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>·\begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>·\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>-x_0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>-1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>-x_0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_W\\<br>&amp;=\begin{bmatrix}-(y+x_0) &amp; 0 &amp; z &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><blockquote class="blockquote-note blockquote-note__[important]"><div class="blockquote-note__header">视图投影矩阵</div><div class="blockquote-note__content"><blockquote>
<p>主视图：$\begin{split}\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_v<br>&amp;=\begin{bmatrix}x &amp; 0 &amp; z &amp; 1\end{bmatrix}\end{split}$</p>
<p>俯视图：$\begin{split}\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_H<br>&amp;=\begin{bmatrix}x &amp; 0 &amp; -(y+z_0) &amp; 1\end{bmatrix}\end{split}$</p>
<p>侧视图：$\begin{split}\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·T_W<br>&amp;=\begin{bmatrix}-(y+x_0) &amp; 0 &amp; z &amp; 1\end{bmatrix}\end{split}$</p>
<p>三个视图中的y均为0，表明三个视图均落在xOz面上</p>
</blockquote>
</div></blockquote>

<h5 id="正投影-正轴测图"><a href="#正投影-正轴测图" class="headerlink" title="正投影-正轴测图"></a>正投影-正轴测图</h5><p>正轴测有等轴测、正二测和正三测三种：</p>
<ul>
<li>当投影面与三个坐标轴之间的夹角<strong>都相等</strong>时 为等轴测</li>
<li>当投影面与<strong>两个</strong>坐标轴之间的夹角相等时 为正二测</li>
<li>当投影面与三个坐标轴之间的夹角<strong>都不相等</strong>时 为正三测</li>
</ul>
<p>8.5.2.2](img/8.5.2.2.png)</p>
<p>空间物体的正轴测图是以V面为轴测投影面，先将物体绕Z轴转γ角，接着绕X轴转-α角，最后向V面投影。</p>
<p>其变换矩阵为：</p>
<p>$$<br>\begin{split}<br>T_正&amp;=T_Z·T_X·T_V\\<br>&amp;=\begin{bmatrix}<br>\cosγ &amp; \sinγ &amp; 0 &amp; 0\\<br>-\sinγ &amp; \cosγ &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; \cosγ &amp; -\sinγ &amp; 0\\<br>0 &amp; \sinγ &amp; \cosγ &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\cosγ &amp; 0 &amp; -\sinγ\sinα &amp; 0\\<br>-\sinγ &amp; 0 &amp; -\cosγ\sinα &amp; 0\\<br>0 &amp; 0 &amp; \cosα &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<p>$$<br>即：\begin{cases}<br>x*=x\cosγ-y\sinγ\\<br>y*=0\\<br>z*=-x\sinγ\sinα-y\cosγ\sinα+z\cosα<br>\end{cases}<br>$$</p>
<h6 id="正等轴测图"><a href="#正等轴测图" class="headerlink" title="正等轴测图"></a>正等轴测图</h6><p>根据画法几何学，作正等轴测投影时，$γ=45°，α=-35.26°$</p>
<p>将Y、α代入上式，其变换矩阵为：<br>$$<br>T_{正等轴测}=\begin{bmatrix}<br>0.7071 &amp; 0 &amp; -0.4082 &amp; 0\\<br>-0.7071 &amp; 0 &amp; -0.4082 &amp; 0\\<br>0 &amp; 0 &amp; 0.8165 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p>
<h6 id="正二测图"><a href="#正二测图" class="headerlink" title="正二测图"></a>正二测图</h6><p>做正二测图时，$γ=20.7°，α=19.47°$</p>
<p>其变换矩阵为：<br>$$<br>T_{正二等}=\begin{bmatrix}<br>0.9354 &amp; 0 &amp; -0.1178 &amp; 0\\<br>-0.7071 &amp; 0 &amp; -0.3118 &amp; 0\\<br>0 &amp; 0 &amp; 0.9428 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p>
<h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><blockquote>
<p>透视投影（ Perspective Projection）是为了获得接近真实三维物体的视觉效果，而在二维的纸或者画布平面上绘图或者渲染的一种方法，能逼真地反映形体的空间形象，也称为透视图。</p>
<p>透视投影是3D渲染的基本概念，也是3D程序设计的基础。</p>
</blockquote>
<p>$$<br>T_{3D}=<br>\begin{bmatrix}<br>a &amp; b &amp; c &amp; p\\<br>d &amp; e &amp; f &amp; q\\<br>g &amp; h &amp; i &amp; r\\<br>l &amp; m &amp; n &amp; s<br>\end{bmatrix}，<br>其中\begin{bmatrix}p\\q\\r\end{bmatrix}为透视投影效果<br>$$</p>
<h5 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h5><ol>
<li>假设$q≠0，p=r=0$。然后对点$(x,y,z)$进行变换：</li>
</ol>
<p>$$<br>\begin{split}<br>\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; q\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; \color{red}qy+1\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x\over{qy+1} &amp; y\over{qy+1} &amp; z\over{qy+1} &amp; 1\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>\end{split}<br>$$</p>
<p>当$y=0$时，得：$\begin{cases}x’=x\\y’=0\\z’=z\end{cases}$，说明处于y=0平面内的点，经过变换以后没有发生变化</p>
<p>当$y→∞$时，得：$\begin{cases}x’=0\\y’={1\over q}\\z’=z\end{cases}$，说明当$y→∞$时，所有点的变换结果都集中到了y轴上的$1\over q$处</p>
<p>即所有平行于y轴的直线将延伸相交于点$(0,{1\over q}，0)$</p>
<p>该点称为灭点，而像这样形成个灭点的透视变换，称为一点透视</p>
<br/>

<p>根据同样的道理，当$p≠0$，$q=r=0$时，则将在x轴上的$1\over q$处产生一个灭点，其坐标值为$({1\over q},0,0)$。</p>
<p>这种情况下，所有平行于x轴的直线将延伸交于该点<br>$$<br>\begin{split}<br>\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; p\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>&amp;=\begin{bmatrix}x &amp; y &amp; z &amp; \color{red}px+1\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x\over{px+1} &amp; y\over{px+1} &amp; z\over{px+1} &amp; 1\end{bmatrix}\\<br>&amp;=\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>\end{split}<br>$$<br>当$r≠0，q=p=0$时，则将在z轴上的$1\over r$处产生一个灭点，其坐标值为$(0,0,{1\over r})$。在这种情况下，所有平行于z轴的直线将延伸交于该点。</p>
<h5 id="多点透视"><a href="#多点透视" class="headerlink" title="多点透视"></a>多点透视</h5><p>根据一点透视的原理予以推广，如果$p,q,r$三个元素中有两个为非零元素时，将会生成两个灭点，因此得到两点透视。</p>
<p>如当$p≠0，r≠0$时，结果为：<br>$$<br>\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; p\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; r\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>=\begin{bmatrix}x &amp; y &amp; z &amp; \color{red}px+rz+1\end{bmatrix}<br>$$<br>经过齐次化处理后结果为：<br>$$<br>\begin{cases}<br>x’={x\over (px+rz+1)}\\<br>y’={y\over (px+rz+1)}\\<br>z’={z\over (px+rz+1)}<br>\end{cases}<br>$$<br>从以上结果可以看到：</p>
<p>当$x→∞$时，一个灭点在x轴上的$1\over p$处</p>
<p>当$z→∞$时，一个灭点在z轴上的$1\over r$处</p>
<p>同理，当p,q,r三个元素全为非零时，结果将会产生三个灭点，从而形成<strong>三点透视</strong>。产生的三个灭点分别在x轴上的$1\over p$处、y轴上的$1\over q$处和z轴上的$1\over r$处</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ol>
<li><p>一点透视</p>
<p>一点透视只有一个灭点。进行透视投影，要很好地考虑图面布局，以避免三维物体的平面或直线积聚成直线或点而影响直观性。</p>
<p>具体地说，就是要考虑下列几点：</p>
<ol>
<li>三维形体与画面（投影面）的相对位置</li>
<li>视距，即视点（投影中心）与画面的距离</li>
<li>视点的高度</li>
</ol>
</li>
</ol>
<p>假定视点（投影中心）在z轴上（z=-d处），投影面在$xOy$面上，则一点透视的骤如下：</p>
<ol>
<li>将三维物体平移到适当位置|、m、n</li>
<li>进行透视变换</li>
<li>最后，为了绘制的方便，向$xOy$平面作在投影变换，将结果变换到$xOy$平面上。</li>
</ol>
<p>$$<br>T_{p1}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>l &amp; m &amp; n &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 1\over d\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; \color{red}0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p>
<p>得到三维物体中任一点$(x,y,z)$<strong>一点透视变换矩阵</strong>形式：<br>$$<br>T_{p1}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 1\over d\\<br>l &amp; m &amp; 0 &amp; {n\over d}+1<br>\end{bmatrix}<br>$$</p>
<p>$$<br>\begin{split}<br>  \begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\end{bmatrix}<br>  &amp;=\begin{bmatrix}x &amp; y &amp; z &amp; 1\end{bmatrix}·<br>  \begin{bmatrix}<br>  1 &amp; 0 &amp; 0 &amp; 0\\<br>  0 &amp; 1 &amp; 0 &amp; 0\\<br>  0 &amp; 0 &amp; 0 &amp; 1\over d \\<br>  l &amp; m &amp; 0 &amp; {n\over d}+1<br>  \end{bmatrix}\\<br>  &amp;=\begin{bmatrix}<br>  {x+l}\over{n+z\over d} +1 &amp; {y+m}\over {n+z\over d}+1 &amp; 0 &amp; 1<br>  \end{bmatrix}<br>\end{split}<br>$$</p>
<hr>
<ol start="2">
<li>二点透视<ol>
<li>将物体平移到适当位置$l、m、n$</li>
<li>将物体绕y轴旋转θ角</li>
<li>进行透视变换</li>
<li>最后向$xOy$面做正投影，即得二点透视图</li>
</ol>
</li>
</ol>
<p>$$<br>\begin{split}<br>T_{p2}&amp;=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; 0\\<br>l &amp; m &amp; n &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>\cos\theta &amp; 0 &amp; -\sin\theta &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>\sin\theta &amp; 0 &amp; \cos\theta &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; p\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; 1 &amp; r\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>0 &amp; 0 &amp; \color{red}0 &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\cos\theta &amp; 0 &amp; 0 &amp; p·cos\theta-r\sin\theta\\<br>0 &amp; 1 &amp; 0 &amp; 0\\<br>\sin\theta &amp; 0 &amp; 0 &amp; p·\sin\theta+r·\cos\theta\\<br>l·\cos\theta+n·\sin\theta &amp; m &amp; 0 &amp; p(l·\cos\theta+n·\sin\theta+r(n·\cos\theta-l·\sin\theta)+1)<br>\end{bmatrix}<br>\end{split}<br>$$</p>
<hr>
<ol start="3">
<li>三点透视<ol>
<li>将物体平移到适当位置</li>
<li>将物体绕y轴旋转θ角</li>
<li>再绕x轴旋转α角</li>
<li>进行透视变换</li>
<li>最后向$xOy$面做正投影，即得三点透视图</li>
</ol>
</li>
</ol>
<h2 id="曲线曲面"><a href="#曲线曲面" class="headerlink" title="曲线曲面"></a>曲线曲面</h2><h3 id="曲线曲面基础"><a href="#曲线曲面基础" class="headerlink" title="曲线曲面基础"></a>曲线曲面基础</h3><h4 id="显示、隐式和参数表示"><a href="#显示、隐式和参数表示" class="headerlink" title="显示、隐式和参数表示"></a>显示、隐式和参数表示</h4><p>曲线和曲面的表示方程<strong>有参数表示</strong>和<strong>非参数表示</strong>之分，非参数表示又分为<strong>显式表示</strong>和<strong>隐式表示</strong></p>
<blockquote>
<p>对于一个平面曲线，显式表示一般形式是：$y=f(x)$</p>
<p>在此方程中，一个x值与一个y值对应，所以显式方程不能表示封闭或多值曲线</p>
<p>如果一个平面曲线方程，表示成$f(x,y)=0$的形式，称之为<strong>隐式表示</strong>。</p>
<p>隐式表示的优点是易于判断一个点是否在曲线上</p>
</blockquote>
<p>显式或隐式表示存在的问题：</p>
<ul>
<li>与坐标轴相关</li>
<li>用隐函数表示不直观，作图不方便</li>
<li>用显函数表示存在多值性</li>
<li>会出现斜率为无穷大的情形</li>
</ul>
<h4 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h4><p>为了克服以上问题，曲线曲面方程通常表示成参数的形式</p>
<p>假定用t表示参数，平面曲线上任一点P可表示为：<br>$$<br>p(t)=[x(t),y(t)]<br>$$</p>
<p>空间曲线上任意三维点P可表示为：<br>$$<br>p(t)=[x(t),y(t),z(t)]<br>$$</p>
<p>它等价于笛卡儿分量表示：<br>$$<br>p(t)=x(t)i+y(t)j+z(t)k<br>$$</p>
<p>这样，给定一个t值，就得到<strong>曲线上一点</strong>的坐标。</p>
<hr>
<p>假设曲线段对应的参数区间为$[a,b]$，即$a≤t≤b$。</p>
<p>为方便期间，可以将区间$[a,b]$规范化成$[0,1]$，参数变换为：<br>$$<br>t’={t-a\over b-a}<br>$$<br>参数<strong>曲线</strong>一般可写成：<br>$$<br>p=p(t),t∈[0,1]<br>$$<br><br/></p>
<p>类似地，可把<strong>曲面</strong>表示成为双参数u和v的矢量函数<br>$$<br>p(u,v)=p(x(u,v),y(u,v),z(u,v)),(u,v)∈[0,1]×[0,1]<br>$$<br><br/></p>
<p>最简单的参数曲线是<strong>直线段</strong>，端点为P1、P2的直线段参数方程可表示为：<br>$$<br>p(t)=p_1+(p_2-p_1)t,t∈[0,1]<br>$$</p>
<h4 id="位置矢量"><a href="#位置矢量" class="headerlink" title="位置矢量"></a>位置矢量</h4><p>曲线上任一点的位置矢量可表示为：<br>$$<br>P(t)=[x(t),y(t),z(t)]<br>$$</p>
<h4 id="切矢量"><a href="#切矢量" class="headerlink" title="切矢量"></a>切矢量</h4><p>选择弧长s作为参数，当Δt→0时，弦长Δs→0，但方向不能趋向于0<br>$$<br>\begin{split}<br>T&amp;={dP\over ds}\\<br>&amp;=\lim_{Δs→0}{ΔP\over Δs}<br>\end{split}<br>$$</p>
<p>根据弧长微分公式有：<br>$$<br>ds^2=(dx)^2+(dy)^2+(dz)^2<br>$$</p>
<p>引入参数t，可改写为：<br>$$<br>\begin{split}<br>({ds\over dt})^2=({dx\over dt})^2+({dy\over dt})^2+({dz\over dt})^2=|P’(t)|^2<br>\end{split}<br>$$</p>
<p>$$<br>\begin{split}<br>T={dP\over ds}={dP\over dt}·{dt\over ds}={P’(t)\over |P’(t)|}<br>\end{split}<br>$$</p>
<p>即T是单位切矢量</p>
<h4 id="曲率"><a href="#曲率" class="headerlink" title="曲率"></a>曲率</h4><p>切向量求导，求导以后还是一个向量，称为曲率，其几何意义是曲线的单位切向量对弧长的转动率，即刻画这一点的曲线的弯曲程度<br>$$<br>\begin{split}<br>k=|T’|=\lim_{Δs→0}|{ΔT\over Δs}|=\lim_{Δs→0}|{T(s+Δs)-T(s)\over Δs}|=\lim_{Δs→0}|{Δθ\over Δs}|<br>\end{split}<br>$$<br>曲率越大，表示曲线的弯曲程度越大</p>
<p>曲率k的倒数$ρ={1\over k}$称为曲率半径。</p>
<p>曲率半径越大，圆弧越平缓；曲率半径越小，圆弧越陡。</p>
<h4 id="法矢量"><a href="#法矢量" class="headerlink" title="法矢量"></a>法矢量</h4><p>法矢量是与切矢量垂直的向量</p>
<p>N、B构成的平面称为法平面，N、T构成的平面称为密切平面，B、T构成的平面称为从切平面</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.1.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.1.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="9.1.1">

<p>T（切矢量）、N（主法矢量）和B（副法矢量）构成了曲线上的活动坐标架<br>$$<br>B=T×N<br>$$</p>
<h4 id="挠率"><a href="#挠率" class="headerlink" title="挠率"></a>挠率</h4><p>空间曲线不但要弯曲，而且还要扭曲，即要离开它的密切平面。</p>
<p>为了能刻画这一扭曲程度，等价于去研究密切平面的法矢量（即曲线的副法矢量）关于弧长的变化率。</p>
<p>挠率$τ$的绝对值等于副法线方向（或密切平面）对于弧长的转动率<br>$$<br>|τ|=\lim_{Δs}|{Δθ\over Δs}|<br>$$</p>
<h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>自由曲线和自由曲面一般通过少数分散的点生成，这些点叫做“型值点”、“样本点”或“控制点”</p>
<p>给定一组有序的数据点$P_i(i=0,1,2，…n)$，要求构造一条曲线顺序通过这些数据点，称为对这些数据点进行插值(interpolation)，所构造的曲线称为插值曲线</p>
<ol>
<li>线性插值：假设给定函数$f(x)$在两个不同点x和x2的值，用一个线形函数：$y=ax+b$，近似代替，称为的线性插值函数</li>
<li>抛物线插值：已知三个点的坐标，要求构造一个抛物线函数</li>
</ol>
<h4 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h4><p>构造一条曲线，使之在某种意义下最接近给定的数据点（但未必通过这些点），所构造的曲线为拟合曲线</p>
<blockquote>
<p>在计算数学中，逼近通常指用一些性质较好的函数近似表示一些性质不好的函数。</p>
<p>在计算机图形学中，逼近继承了这方面的含义，因此插值和拟合都可以视为逼近</p>
</blockquote>
<p>对于逼近样条，连接控制点序列的折线通常被显示出来，以提醒设计者控制点的次序</p>
<p>般将连接有一定次序控制点的直线序列称为控制多边形或特征多边形</p>
<h4 id="光顺"><a href="#光顺" class="headerlink" title="光顺"></a>光顺</h4><p>指曲线的拐点不能太多（有一、二阶导数等）</p>
<p>对平面曲线而言，相对光顺的条件是</p>
<ol>
<li><p>具有二阶几何连续性（$G^2$）</p>
</li>
<li><p>不存在多余拐点和奇异点</p>
</li>
<li><p>曲率变化较小</p>
</li>
</ol>
<h3 id="曲线连续性"><a href="#曲线连续性" class="headerlink" title="曲线连续性"></a>曲线连续性</h3><p>当许多参数曲线段首尾相连构成一条曲线时，如何保证各曲线段在连接处具有合乎要求的连续性是一个重要问题。</p>
<p>假定参数曲线段$p_i$以参数形式进行描述：<br>$$<br>p_i=p_i(t),t∈[t_{i0},t_{i1}]<br>$$<br>这里讨论参数曲线两种意义上的连续性：即<strong>参数连续性</strong>和<strong>几何连续性</strong></p>
<h4 id="参数连续性"><a href="#参数连续性" class="headerlink" title="参数连续性"></a>参数连续性</h4><ul>
<li><p>0阶参数连续性</p>
<p>记作$C^0$连续性，是指曲线的几何位置连接，即第一个曲线段在$t_{i1}$处的x,y,z值与第二个曲线段在$t_{(i+1)0}$处的x,y,z值相等</p>
</li>
</ul>
<p>$$<br>p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})<br>$$</p>
<ul>
<li><p>1阶参数连续性</p>
<p>记作$C^1$连续性，指代表两个相邻曲线段的方程在相交点处有相同的一阶导数（切线）：</p>
</li>
</ul>
<p>$$<br>p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})\<br>且p’<em>i(t</em>{i1})=p’<em>{(i+1)}(t</em>{(i+1)0})<br>$$</p>
<p>一阶连续性对数字化绘画及一些设计应用已经足够</p>
<ul>
<li><p>2阶参数连续性</p>
<p>记作$C^2$连续性，指两个相邻曲线段的方程在相交点处具有相同的一阶和二阶导数。</p>
<p>类似地，还可定义高阶参数连续性</p>
</li>
</ul>
<p>对于$C^2$连续性，交点处的切向量变化率相等，即切线从一个曲线段平滑地变化到另一个曲线段</p>
<p>二阶连续性对电影中的动画途径和很多精密CAD需求有用</p>
<hr>
<p>经典的参数连续性在图形学里是不适合的，因为太苛刻，所以引进了几何连续性的概念</p>
<p>汽车曲面的设计美观要求很高，但有时候车身的一条曲线并不是参数连连续的，但人眼看上去已经是很光滑的了，因此需要一种更弱的连续性</p>
<h4 id="几何连续性"><a href="#几何连续性" class="headerlink" title="几何连续性"></a>几何连续性</h4><p>曲线段相连的另一个连续性条件是几何连续性。</p>
<p>与参数连续性不同的是，它只需曲线段在相交处的参数导数<strong>成比例</strong>即可</p>
<ul>
<li><p>0阶几何连续性</p>
<p>记作$G^0$连续性。与0阶参数连续性的定义相同，满足：</p>
</li>
</ul>
<p>$$<br>p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})<br>$$</p>
<ul>
<li><p>1阶几何连续性</p>
<p>记作$G^1$连续性。若要求在结合处达到$G^1$连续就是说两条曲线在结合处在满足$G^0$连续的条件下，并有公共的切矢</p>
</li>
</ul>
<p>$$<br>Q’(0)=αP’(1)\space(α&gt;0)<br>$$</p>
<ul>
<li><p>2阶几何连续性</p>
<p>记作$G^2$连续性。就是说两条曲线在结合处在满足$G^1$连续的条件下，并有公共的曲率</p>
</li>
</ul>
<p>!&gt;<strong>一阶导数相等和有公共切向量这两个概念差别是什么？</strong>导数相等是大小方向都相等，而公共切矢意味着方向相同但大小不等。所谓参数连续意味着导数相等，导数相等意味着两个切向量，不但方向相等而且长度也相等。<em>条件减弱了</em></p>
<h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><blockquote>
<p>过三点P、P1和P2构造参数表示的插值多项式是唯一的还是有多个呢？</p>
<p>插值多项式可以有无数条，这是因为对应地参数t在[0,1]中可以有无数种取法</p>
</blockquote>
<p>$$<br>t_0=0,t_1={1\over 2},t_2=1<br>$$</p>
<p>$$<br>t_0=0,t_1={1\over 3},t_2=1<br>$$</p>
<p>$$<br>参数方程:\begin{cases}<br>x(t)=a_1t^2+a_2t+a_3\<br>y(t)=b_1t^2+b_2t+b_3<br>\end{cases}<br>$$</p>
<p>插值问题实际上就是解方程组的问题。但如果参数取的不一样的话，结果是不一样的</p>
<p>每个参数值称为节点(knot)。对于一条插值曲线，$p_0、 p_1、p_2$这些点称为型值点</p>
<p>对于一条插值曲线，型值点$p_0,p_1,…,p_n$。与其参数域$t∈[t_0，t_1]$内的节点之间有一种对应关系。对于一组有序的型值点，所确定一种参数分割，称之这组型值点的参数化</p>
<hr>
<p><strong>例：</strong>现在给定3个点$p_0、p_1、p_2$，坐标是$(0,0)、(100,50)、(200,0)$，求一条2次的多项式曲线来插值这三个点。</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.3.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.3.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="9.3.1">

<p>假设第一个点参数$t=0$，第二个点参数取$t={1\over 2}$，第三个点的参数取$t=1$。</p>
<p>即$t_1=0,t_2={1\over 2},t_3=1$，带入参数方程$\begin{cases}x(t)=a_1t^2+a_2t+a_3\y(t)=b_1t^2+b_2t+b_3\end{cases}$</p>
<p>得到：<br>$$<br>\begin{cases}0=x(0)=a_3\\<br>0=y(0)=b_3<br>\end{cases}<br>$$<br>$$<br>\begin{cases}<br>100=x({1\over 2})={a_1\over 4}+{a_2\over 2}+a_3\\<br>50=y({1\over 2})={b_1\over 4}+{b_2\over 2}+b_3<br>\end{cases}<br>$$<br>$$<br>\begin{cases}200=x(1)=a_1+a_2+a_3\\<br>0=y(1)=b_1+b_2+b_3\end{cases}<br>$$</p>
<p>6个方程6个未知数，插值问题的本质是方程的个数和未知数的个数是一致的</p>
<blockquote>
<p><strong>为何取参数$t_1=0,t_2={1\over 2},t_3=1$？</strong>因为要使参数更接近/符合点的分布。参数化的本质就是找一组恰当的参数t来匹配这一组不同的型值点。给定一组不同的型值点，就要给出不同的参数化，即不同的t值，这样才使得这条曲线美观、合理。</p>
</blockquote>
<blockquote>
<p><strong>参数化常用方法：</strong></p>
<ol>
<li><p>均匀参数化</p>
<p>节点在参数轴上呈等距分布。如$0、{1\over 10}、{2\over 10}…$</p>
</li>
<li><p>累加弦长参数化（根据长度的比例关系来确定t）</p>
<p>$\begin{cases}t_0=0\\t_i=t_{i-1}+|ΔP_{i-1}|,i=1,2,…,n\end{cases};ΔP_i=P_{i+1}-P_i$</p>
<p>这种参数法如实反映了型值点按弦长的分布情况，能够克服型值点按弦长分布不均匀的情况下采用均匀参数化所岀现的问题</p>
</li>
<li><p>向心参数化法</p>
<p>$\begin{cases}t_0=0\\t_i=t_{i-1}+|ΔP_{i-1}|^{1\over 2},i=1,2,…,n\end{cases};ΔP_i=P_{i+1}-P_i$</p>
<p>向心参数化法假设在一段曲线弧上的向心力与曲线切矢从该弧段始端至末端的转角成正比，加上一些简化假设，得到向心参数化法。此法尤其适用于非均匀型值点分布</p>
</li>
</ol>
</blockquote>
<h3 id="参数曲线的代数和几何形式"><a href="#参数曲线的代数和几何形式" class="headerlink" title="参数曲线的代数和几何形式"></a>参数曲线的代数和几何形式</h3><p>以<strong>三次参数曲线</strong>为例，讨论参数曲线的代数和几何形式</p>
<ol>
<li>代数形式</li>
</ol>
<p>$$<br>\begin{cases}<br>x(t)=a_{3x}t^3+a_{2x}t^2+a_{1x}t+a_{0x}\\<br>y(t)=b_{3y}t^3+b_{2y}t^2+b_{1y}t+b_{0y}\\<br>z(t)=c_{3z}t^3+c_{2z}t^2+c_{1z}t+c_{0z}\\<br>\end{cases},t∈[0,1]<br>$$</p>
<p>上述代数式写成矢量式是：<br>$$<br>P(t)=a_3t^3+a_2t^2+a_1t+a_0,t∈[0,1]<br>$$</p>
<blockquote>
<p><strong>注意：</strong>$a_3，a_2，a_1，a$是参数曲线的系数，但记住不是常数而是向量。$a_3$对应刚才的$a_{3x}$、$a_{3y}$、$a_{3z}$。改变系数曲线如何变化是不清楚的，这是代数形式的缺点</p>
</blockquote>
<ol start="2">
<li>几何形式</li>
</ol>
<p>几何形式是利用一条曲线端点的几何性质来刻画一条曲线。所谓端点的几何性质，就是指曲线的端点位置、切向量、各阶导数等端点的信息。</p>
<p>将$P(0)$、$P(1)$、$P’(0)$和$P’(1)$简记为：$P_0、P_1、P’_0、P’_1$<br>$$<br>P(t)=a_3t^3+a_2t^2+a_1t+a_0,t∈[0,1]<br>$$<br>得到：$\begin{cases}P_0=a+0\\<br>P_1=a_3+a_2+a_1+a_0\\<br>P’_0=a_1\\<br>P’_1=3a_3+2a_2+a_1\end{cases}\implies<br>\begin{cases}a_0=P_0\\<br>a_1=P’_0\\<br>a_2=-3P_0-3P_1-2P’_0-P’_0\\<br>a_3=2P_0-2P_1+P’_0+P’_1\end{cases}$</p>
<p>再代入$P(t)=a_3t^3+a_2t^2+a_1t+a_0$</p>
<p>得：$P(t)=(2t^3-3t^2+1)p_0+(-2t^3+3t^2)p_1+(t^3-2t^2-t)p’_0+(t^3-t^2)p’_1$</p>
<p>对上式化简，令：<br>$$<br>F(0)=2t^3-3t^2+1，F(1)=-2t^3+3t^2\\<br>G(0)=t^3-2t^2-t，G(1)=t^3-t^2<br>$$<br>简化后得：<br>$$<br>{\color{red}*}P(t)=F_0P_0+F_1P_1+G_0P’_0+G_1P’_1,t∈[0,1]<br>$$<br>上式是三次<strong>Hermite曲线</strong>（三次哈密特曲线）的几何形式，几何系数是$P_0、P_1、P’_0、P’_1$；$F(0)、F(1)、G(O)、G(1)$称为调和函数（或混合函数）</p>
<h3 id="Bezier曲线与曲面"><a href="#Bezier曲线与曲面" class="headerlink" title="Bezier曲线与曲面"></a>Bezier曲线与曲面</h3><blockquote>
<p>想法基点是在进行汽车外形设计时，先用折线段勾画出汽车的外形大致轮廓，然后用光滑的参数曲线去逼近这个折线多边形</p>
<p>这个折线多边形被称为<strong>特征多边形</strong>。</p>
<p>逼近该特征多边形的曲线被称为Bezier曲线。</p>
</blockquote>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>针对Bezier曲线，给定空间n+1个点的位置矢量$P_i$</p>
<p>贝塞尔把参数n次曲线表示为：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^na_if_{i,n}(t)，0≤t≤1<br>$$<br>其中系数矢量$a_i(i=0,1,…n)$顺序首尾相接，从$a_0$的末端到$a_n$的末端所形成的折线称为控制多边形或贝塞尔多边形<br>$$<br>f_{i,n}(t)=\begin{cases}<br>1,i=0\\<br>{(-t)^i\over(i-1)!} {d^{i-1}\over dt^{i-1}} ({(1-t)^{n-1}-1 \over t})<br>\end{cases}称为贝塞尔基函数<br>$$<br>上式可以简化成<strong>伯恩斯坦基函数</strong>：<br>$$<br>B_{i,n}(t)={n!\over i!(n-i)!}t^i(1-t)^{n-i}=C_n^it^i(1-t)^{n-i},(i=0,1,…,n)<br>$$</p>
<p>$C_n^it^i(1-t)^{n-i}$正是牛顿二项式定理</p>
<h4 id="一次Bezier曲线"><a href="#一次Bezier曲线" class="headerlink" title="一次Bezier曲线"></a>一次Bezier曲线</h4><p>当n=1时，有两个控制点$p_0$和$p_1$，Bezier多项式是一次多项式：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^1a_if_{i,1}(t)<br>=P_0B_{0,1}(t)+P_1B_{1,1}(t)<br>$$</p>
<p>$$<br>\begin{cases}<br>B_{0,1}(t)={1!\over 0!(1-0)!}t^0(1-t)^{1-0}=1-t\\<br>B_{1,1}(t)={1!\over 1!(1-1)!}t^1(1-t)^{1-1}=t<br>\end{cases}<br>$$</p>
<p>因此：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^1a_if_{i,1}(t)<br>=P_0B_{0,1}(t)+P_1B_{1,1}(t)\\<br>=(1-t)P_0+tP_1<br>$$<br>这恰好是连接起点$P_0$和终点$P_1$的直线段</p>
<h4 id="二次Bezier曲线"><a href="#二次Bezier曲线" class="headerlink" title="二次Bezier曲线"></a>二次Bezier曲线</h4><p>当n=2时，有3个控制点$p_0、p_1和p_2$，Bezier多项式是二次多项式：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^2a_if_{i,2}(t)<br>=P_0B_{0,2}(t)+P_1B_{1,2}(t)+P_2B_{2,2}(t)<br>$$</p>
<p>$$<br>\begin{cases}<br>B_{0,2}(t)={2!\over 0!(2-0)!}t^0(1-t)^{2-0}=(1-t)^2\\<br>B_{1,2}(t)={2!\over 1!(2-1)!}t^1(1-t)^{2-1}=2t(1-t)\\<br>B_{2,2}(t)={2!\over 2!(2-2)!}t^2(1-t)^{2-2}=t^2<br>\end{cases}<br>$$</p>
<p>因此：<br>$$<br>\begin{split}<br>p(t)&amp;=\displaystyle\sum_{i=0}^2a_if_{i,2}(t)<br>&amp;=P_0B_{0,2}(t)+P_1B_{1,2}(t)+P_2B_{2,2}(t)\\<br>&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2\\<br>&amp;=(P_2-2P_1+P_0)t^2+2(P_1-P_0)t+P_0<br>\end{split}<br>$$<br>二次Bezier曲线为抛物线，其矩阵形式为：<br>$$<br>p(t)=\begin{bmatrix}<br>t^2 &amp; t &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>1 &amp; -2 &amp; 1\\<br>-2 &amp; 2 &amp; 0\\<br>1 &amp; 0 &amp; 0<br>\end{bmatrix}·<br>\begin{bmatrix}<br>P_0\\P_1\\P_2<br>\end{bmatrix},t∈[0,1]<br>$$</p>
<h4 id="三次Bezier曲线"><a href="#三次Bezier曲线" class="headerlink" title="三次Bezier曲线"></a>三次Bezier曲线</h4><p>三次Bezier曲线由4个控制点生成，这时n=3，有4个控制点$p_0、p_1、p_2$和$p_3$，Bezier多项式是三次多项式：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^3a_if_{i,3}(t)<br>=P_0B_{0,3}(t)+P_1B_{1,3}(t)+P_2B_{2,3}(t)+P_3B_{3,3}(t)<br>$$</p>
<p>$$<br>\begin{cases}<br>B_{0,3}(t)={3!\over 0!(3-0)!}t^0(1-t)^{3-0}=(1-t)^3\\<br>B_{1,3}(t)={3!\over 1!(3-1)!}t^1(1-t)^{3-1}=3t(1-t)^2\\<br>B_{2,3}(t)={3!\over 2!(3-2)!}t^2(1-t)^{3-2}=3t^2(1-t)\\<br>B_{3,3}(t)={3!\over 3!(3-3)!}t^3(1-t)^{3-3}=t^3<br>\end{cases}，为三次Bezier曲线的基函数<br>$$</p>
<p>因此：<br>$$<br>p(t)=\displaystyle\sum_{i=0}^3a_if_{i,3}(t)<br>=(1-t^3)P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3<br>$$<br>这四条基函数曲线均是三次曲线，任何三次Bezier曲线都是这四条曲线的线形组合</p>
<p>把 Bezier三次曲线多项式写成矩阵形式：<br>$$<br>\begin{split}<br>p(t)&amp;=\begin{bmatrix}<br>t^3 &amp; t^2 &amp; t &amp; 1<br>\end{bmatrix}·<br>\begin{bmatrix}<br>-1 &amp; 3 &amp; -3 &amp; 1\\<br>3 &amp; -6 &amp; 3 &amp; 0\\<br>-3 &amp; 3 &amp; 0 &amp; 0\\<br>1 &amp; 0 &amp; 0 &amp; 0<br>\end{bmatrix}·<br>\begin{bmatrix}<br>P_0\\P_1\\P_2\\P_3<br>\end{bmatrix},t∈[0,1]\\<br>&amp;=T·M_{be}·G_{be}<br>\end{split}<br>$$<br>其中，$M_{be}$是三次Bezier曲线系数矩阵，为常数；$G_{be}$是4个控制点位置矢量</p>
<blockquote>
<p>Bezier曲线不可能对曲线形状进行局部控制，如果改变任一控制点位置，整个曲线会受到影响</p>
</blockquote>
<h4 id="Bernstein基函数的性质"><a href="#Bernstein基函数的性质" class="headerlink" title="Bernstein基函数的性质"></a>Bernstein基函数的性质</h4><ol>
<li>正性（非负性）</li>
<li>权性<ul>
<li>基函数有n+1项，n+1个基函数的和加起来正好等1</li>
</ul>
</li>
<li>端点性质</li>
<li>对称性<ul>
<li>可以证明，假如保持n次 Bezier曲线控制多边形的顶点位置不变，而把次序颠倒过来，则此时曲线仍不变，只不过曲线的走向相反而已</li>
</ul>
</li>
<li>递推性<ul>
<li>即n次的Bernstein基函数可由两个n-1次的 Bernstein基函数线性组合而成。</li>
</ul>
</li>
<li>导函数<ul>
<li>$B’_{i,n}(t)=n[B_{i-1,n-1}(t)-B_{i,n-1}(t)],i=0,1,…,n$</li>
</ul>
</li>
<li>最大值<ul>
<li>$B_{i,n}(t)$在$t={i\over n}$处达到最大值</li>
</ul>
</li>
<li>积分<ul>
<li>$\int_0^1B_{i,n}(t)dt={1\over n+1}$</li>
</ul>
</li>
<li>降阶公式<ul>
<li>$B_{i,n}(u)=(1-u)B_{i,n-l}(u)+uB_{i-l,n-l}(u)$</li>
<li>一个n次Bernstein基函数能表示成两个n-1次基函数的线性和</li>
</ul>
</li>
<li>升阶公式</li>
</ol>
<h4 id="Bezier曲线的性质"><a href="#Bezier曲线的性质" class="headerlink" title="Bezier曲线的性质"></a>Bezier曲线的性质</h4><ol>
<li>端点性质<ul>
<li>顶点$p_0$和$p_n$分别位于实际曲线段的起点和终点上</li>
</ul>
</li>
<li>一阶导数<ul>
<li>Bezier曲线的起点和终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致</li>
</ul>
</li>
<li>几何不变性<ul>
<li>指某些几何特性不随坐标变换而变化的特性。Bezier曲线的形状仅与控制多边形各顶点的相对位置有关，而与坐标系的的选择无关</li>
</ul>
</li>
<li>变差缩减性<ul>
<li>若Bezier曲线的特征多边形是一个平面图形，则平面内任意直线与p(t)的交点个数不多于该直线与其特征多边形的交点个数，这一性质叫变差缩减性质</li>
</ul>
</li>
</ol>
<h4 id="Bezier曲线的生成"><a href="#Bezier曲线的生成" class="headerlink" title="Bezier曲线的生成"></a>Bezier曲线的生成</h4><ol>
<li><p>根据定义直接生成Bezier曲线</p>
<ul>
<li><p>首先给出$C^i_n$的递归计算式：$C^i_n={n!\over i!(n-i)!}={n-i+1\over i}C^{i-1}_n,n≥i$</p>
</li>
<li><p>将$p(t)=\displaystyle\sum^n_{i=0}P_iB_{i,n}(t)$表示成分量坐标形式<br>$$<br>\begin{cases}<br>x(t)=\displaystyle\sum^n_{i=0}x_iB_{i,n}(t)\\<br>y(t)=\displaystyle\sum^n_{i=0}y_iB_{i,n}(t)\\<br>z(t)=\displaystyle\sum^n_{i=0}z_iB_{i,n}(t)<br>\end{cases},t∈[0,1]<br>$$</p>
<p>根据以上的公式可以直接写出绘制Bezier曲线的程序</p>
</li>
</ul>
</li>
<li><p>Bezier曲线的递推(de Castel jau)算法</p>
<ul>
<li><p>根据Bezier曲线的定义确定的参数方程绘制Bezier曲线，因其计算量过大，不太适合在工程上使用</p>
</li>
<li><p>Bezier曲线上的任一个点P(t)，都是<strong>其它相邻线段的同等比例(t)点处的连线</strong>，再取同等比例(t)的点再连线，一直取到<strong>最后那条线段的同等比例(t)处</strong>，该点就是Beizer曲线上的点P(t)</p>
</li>
<li><p>由(n+1)个控制点$P_i(i=0,1,…,n)$定义的n次Bezier曲线$P_0^n$。n可被定义为分别由前、后n个控制点定义的两条(n-1)次Bezier曲线$P_0^{n-1}$与$P_1^{n-1}$的线性组合</p>
</li>
<li><p>由此得到Bezier曲线的递推计算公式：<br>$$<br>P_i^k=\begin{cases}<br>P_i\space k=0\\<br>(1-t)P_i^{k-1}+tP_{i+1}^{k-1}\space,k=1,2,…,n\space /\space i=0,1,…,n-k<br>\end{cases}<br>$$</p>
</li>
</ul>
</li>
</ol>
<h4 id="Bezier曲线的拼接"><a href="#Bezier曲线的拼接" class="headerlink" title="Bezier曲线的拼接"></a>Bezier曲线的拼接</h4><blockquote>
<p>几何设计中，一条Bezier曲线往往难以描述复杂的曲线形状。这是由于增加特征多边形的顶点数，会引起Bezier曲线次数的提高，而高次多项式又会带来计算上的困难</p>
<p>采用分段设计,然后将各段曲线相互连接起来,    并在接合处保持一定的连续条件</p>
</blockquote>
<p>给定两条Bezier曲线P(t)和Q(t)，相应控制点为$P(i=0,1,…,n)$和$Q(i=0,1…,m)$</p>
<ul>
<li>要使它们达到$G^0$连续,则：$P_n=Q_0$</li>
<li>要使它们达到$G^1$连续,只要保证$P_{n-1},P_n=Q,Q_1$三点共线就行了</li>
</ul>
<p>Bezier曲线的起点和终点处的切线方向 和特征多边形的第一条边及最后一条边的走向一致</p>
<h4 id="Bezier曲线的升阶与降阶"><a href="#Bezier曲线的升阶与降阶" class="headerlink" title="Bezier曲线的升阶与降阶"></a>Bezier曲线的升阶与降阶</h4><ol>
<li>Bezier曲线的升阶</li>
</ol>
<blockquote>
<p>假设有一个二次多项式：<br>$$<br>a_0+a_1t+a_2t^2=0<br>$$<br>能否找一个三次多项式近似逼近这个二次多项式，或精确地转成一个三次多项式？<br>$$<br>a_0+a_1t+a_2t^2+0*t^3=0<br>$$<br>所谓升阶就是<strong>保证曲线的形状和方向保持不变</strong>，但是要<strong>增加顶点个数</strong></p>
<p>但是，伯恩斯坦基函数不是简单的$t^2、t^3$，2次Bezier基函数是$B_{i,2}$，3次是$B_{i,3}$，如何从$B_{i,2}$转化成$B_{i,3}$的形式?</p>
</blockquote>
<p>所谓升阶是指<strong>保持Bezier曲线的形状与方向不变，增加定义它的控制顶点数</strong>，即提高该Bezier曲线的次数。</p>
<ul>
<li>增加一个顶点后,仍定义同一条曲线的新控制顶点为$P_0^*,P_1^*,…,P_{n+1}^*$，则有：</li>
</ul>
<p>$$<br>\displaystyle\sum^n_{i=0}C^i_nP_it^i(1-t)^{n-i}<br>=\displaystyle\sum^n_{i=0}C^i_{n+1}P^*_it^i(1-t)^{n-i}<br>$$</p>
<ul>
<li>新的多边形更加靠近曲线。在80年代初，有人证明如果直升阶升下去的话，控制多边形收敛这条曲线</li>
</ul>
<ol start="2">
<li>Bezier曲线的降阶</li>
</ol>
<blockquote>
<p>降阶是升阶的逆过程</p>
<p>假设有一个三次多项式：<br>$$<br>a_0+a_1t+a_2t^2+a_3t^3<br>$$<br>能否找一个二次多项式近似逼近这个三次多项式，或精确地转成一个二次多项式？<br>$$<br>a_0+a_1t+a_2t^2+a_3t^3=b_0+b_1t+b_2t^2<br>$$<br>如果$a_3$不等于0，想找一个二次多项式精确等于它是不可能的。如果一定要降下来，那只能近似逼近</p>
<p>如果把$a_3t^3$扔掉，也不是不可以，但误差太大。必须想办法找到一个二次多项式，尽量逼近这个三次多项式</p>
</blockquote>
<p>假定$P_i$是由$P_i^*$升阶得到，则由升阶公式有：<br>$$<br>P_i={n-i\over n}P_i^*+{i\over n}P_{i-1}^*<br>$$</p>
<p>从这个方程可以导出两个递推公式：<br>$$<br>\begin{cases}<br>P_i^*={nP_i-iP_{i-1}^* \over n-i},\space i=0,1,…,n-1\\<br>P_{i-1}^*={nP_i-(n-i)P_i^* \over i},\space i=n,n-1,…,1<br>\end{cases}<br>$$</p>
<p>可以综合利用上面两个式子进行降解，但仍然不精确</p>
<h5 id="Bezier曲线曲面升降阶的重要性"><a href="#Bezier曲线曲面升降阶的重要性" class="headerlink" title="Bezier曲线曲面升降阶的重要性"></a>Bezier曲线曲面升降阶的重要性</h5><ol>
<li>它是CAD系统之间<strong>数据传递与交换</strong>的需要</li>
<li>它是系统中分段（片）线性逼近的需要。通过逐次降阶，把曲面化为直线平面，便于求交和曲面绘制</li>
<li>它是外形信息压缩的需要。降阶处理以后可以减少存储的信息量</li>
</ol>
<h4 id="Bezier曲面"><a href="#Bezier曲面" class="headerlink" title="Bezier曲面"></a>Bezier曲面</h4><p>基于Bezier曲线的讨论，可以给出 Bezier曲面的定义和性质， Bezier曲线的一些算法也可以很容易扩展到Bezier曲面的情况</p>
<h5 id="Bezier曲面的定义"><a href="#Bezier曲面的定义" class="headerlink" title="Bezier曲面的定义"></a>Bezier曲面的定义</h5><p>设$p_{i,j}(0,1,…,n;j=0,1,…,m)$为$(n+1)×(m+1)$个空间点</p>
<p>则$m×n$的Bezier曲面定义为：<br>$$<br>P(u,v)=\displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}P_{ij}B_{i,m}(u)B_{j,n}(v),\space u,v∈[0,1]<br>$$<br>其<strong>伯恩斯坦基函数</strong>为：<br>$$<br>\begin{cases}<br>B_{i,m}(u)=C_m^i u^i(1-u)^{m-i}\\<br>B_{i,n}(v)=C_n^j v^j(1-v)^{n-j}<br>\end{cases}<br>$$<br>Bezier曲面的矩阵表示式是：<br>$$<br>P(u,v)=\begin{bmatrix}<br>B_{0,n}(u) &amp; B_{1,n}(u) &amp; … &amp; B_{m,n}(u)<br>\end{bmatrix}<br>\begin{bmatrix}<br>P_{00} &amp; P_{01} &amp; … &amp; P_{0m}\\<br>P_{10} &amp; P_{11} &amp; … &amp; P_{1m}\\<br>… &amp; … … &amp; …\\<br>P_{n0} &amp; P_{n1} &amp; … &amp; P_{nm}<br>\end{bmatrix}<br>\begin{bmatrix}<br>B_{0,m}(v)\\B_{1,m}(v)\\…\\B_{n,m}(v)<br>\end{bmatrix}<br>$$<br>上式的曲面称为$m×n$次的，在一般应用中，$n,m$不大于4</p>
<h5 id="Bezier曲面的性质"><a href="#Bezier曲面的性质" class="headerlink" title="Bezier曲面的性质"></a>Bezier曲面的性质</h5><p>Bezier曲线的很多性质可推广到 Bezier曲面</p>
<ol>
<li>Bezier曲面特征网格的四个角点正好是 Bezier曲面的四个角点，即：</li>
</ol>
<p>$$<br>\begin{cases}<br>P(0,0)=P_{00}\\<br>P(1,0)=P_{m0}\\<br>P(0,1)=P_{0n}\\<br>P(1,1)=P_{mn}<br>\end{cases}<br>$$</p>
<ol start="2">
<li>Bezier曲面特征网格最外一圈顶点定义Bezier曲面的四条边界</li>
<li>几何不变性</li>
<li>对称性</li>
<li>凸包性</li>
</ol>
<h5 id="Bezier曲面片的拼接"><a href="#Bezier曲面片的拼接" class="headerlink" title="Bezier曲面片的拼接"></a>Bezier曲面片的拼接</h5><p>设两张$m×n$次Bezier曲面片：<br>$$<br>\begin{cases}<br>P(u,v)=\displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}P_{ij}B_{i,m}(u)B_{j,n}(v)\\<br>Q(u,v)=\displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}Q_{ij}B_{i,m}(u)B_{j,n}(v)<br>\end{cases},\space u,v∈[0,1]<br>$$<br>分别由控制顶点$P_{ij}$和$Q_{ij}$定义。</p>
<ul>
<li><p>如果要求两曲面片达到$G^0$连续，则它们有公共的边界，即：$P(1,v)=Q(0,v)$</p>
<p>于是有：$P_{ni}=Q_{0i},\space (i=0,1,…,m)$</p>
</li>
<li><p>如果又要求沿该公共边界达到G连续，则两曲面片在该边界上有公共的切平面，因此曲面的法向应当是跨界连续的，即：</p>
</li>
</ul>
<p>$$<br>Q_u(0,v)×Q_v(0,v)=α(v)P_u(1,v)×P_v(1,v)<br>$$</p>
<h4 id="递推-de-Castel-jau-算法（曲面的求值）"><a href="#递推-de-Castel-jau-算法（曲面的求值）" class="headerlink" title="递推(de Castel jau)算法（曲面的求值）"></a>递推(de Castel jau)算法（曲面的求值）</h4><p>Bezier曲线的递推(de Castel jau)算法，可以推广到Bezier曲面的情形<br>$$<br>P_{ij}(i=0,1,…,m;j=0,1,…,n)<br>$$</p>
<p>$$<br>P(u,v)=\displaystyle\sum_{i=0}^{m-k}\displaystyle\sum_{j=0}^{n-l}P_{i,j}^{k,l}B_{i,m}(u)B_{j,n}(v)=…=P_{00}^{m,n},\space u,v∈[0,1]<br>$$</p>
<p>一条曲线可以表示成两条低一次曲线的组合，一张曲面可以表示成低一次的四张曲面的线性组合</p>
<p>其中：<br>$$<br>\begin{equation}<br>P_{i,j}^{k,l}=\begin{cases}<br>P_{ij},\space (k=l=0)\\<br>(1-u)P_{ij}^{k-1,0}+uP_{i+1,j}^{k-1,0},\space (k=1,2,…,m;l=0)\\<br>(1-v)P_{0,j}^{m,l-1}+vP_{0,j+1}^{m,l-1},\space (k=m;l=1,2,…,n)<br>\end{cases}<br>\end{equation}<br>$$<br>或<br>$$<br>\begin{equation}<br>P_{ij}^{k,l}=\begin{cases}<br>P_{ij},\space (k=l=0)\\<br>(1-v)P_{ij}^{0,l-1}+vP_{i,j+1}^{0,l-1},\space (k=0;l=1,2,…,n)\\<br>(1-u)P_{i0}^{k-1,n}+uP_{i+1,0}^{k-1,n},\space (k=1,2,…,m;l=n)<br>\end{cases}<br>\end{equation}<br>$$</p>
<ul>
<li>当按（1）式方案执行时，先以u参数值对控制网格u向的n+1个多边形执行曲线 de Castel jau算法，m级递推后，得到沿v向由n+1个顶点$P^{m0}_{0j}$构成的多边形。再以v参数值对它执行曲线的 de Castel jau算法n级递推以后，得到一个$P^{mn}_{00}$即所求曲面上的点。</li>
</ul>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.6.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.6.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="9.6.1">

<h3 id="B样条"><a href="#B样条" class="headerlink" title="B样条"></a>B样条</h3><blockquote>
<p>Bezier曲线有几点不足：</p>
<ol>
<li>一旦确定了特征多边形的顶点数（n+1个），也就决定了曲线的阶次（n次）</li>
<li>Bezier曲线或曲面的拼接比较复杂</li>
<li>Bezier曲线或曲面不能作局部修改</li>
</ol>
</blockquote>
<p>B样条的特点</p>
<ul>
<li><p>整条曲线用一个完整的表达形式，但内在的量是一段一段的，比如一堆的3次曲线拼接，两条之间满足2次连续</p>
</li>
<li><p>这样既克服了波动现象，曲线又是低次的。既有统一的表达式，又有统一的算法</p>
</li>
</ul>
<p>如何进行分段？</p>
<ul>
<li>现在有n+1个点，每两点之间构造一条多项式，n+1个点有n个小区间</li>
<li>每个小区间构造一条三次多项式，变成了n段的三次多项式拼接在一起，段与段之间要两次连续，这就是三次样条</li>
<li>如有5个点，构造一个多项式，应该是个四次多项式。现在采用样条方式构造四段曲线，每一段都是三次的，且段与段之问间要$C^2$连续</li>
</ul>
<h4 id="B样条的递推定义和性质"><a href="#B样条的递推定义和性质" class="headerlink" title="B样条的递推定义和性质"></a>B样条的递推定义和性质</h4><p>B样条曲线的数学表达式为：<br>$$<br>P(u)=\displaystyle\sum_{i=0}^n{P_iB_{i,k}(u)},\space u∈[u_{k-1},u_{n+1}]<br>$$<br>$P(i=0,1,…,n)$是控制多边形的顶点</p>
<p>$B_{i,k}(u)$称为k阶（k-1次）B样条基函数，k是刻画次数。其中k可以是2到控制点个数n+1之间的任意整数</p>
<p>对Bezier曲线来说，阶数和次数是一样的；但对于B样条，阶数是次数+1</p>
<p>B样条基函数是一个称为节点矢量的非递减的参数u的序列所决定的k阶分段多项式，这个序列称为节点向量</p>
<h5 id="de-boor-Cox递推定义"><a href="#de-boor-Cox递推定义" class="headerlink" title="de boor-Cox递推定义"></a>de boor-Cox递推定义</h5><p>B样条基函数可以有各种各样的定义方式，但是公认的最容易理解的是de boor-Cox递推定义</p>
<p>它的原理是，只要是k阶（k-1次）的B样条基函数，构造一种递推的公式，由0次构造1次，1次构造2次，2次构造3次……依次类推<br>$$<br>\begin{cases}<br>    B_{i,1}(u)=\begin{cases}<br>        1,\space u_i&lt;u&lt;u_{i+1}\\<br>        0,\space Otherwise<br>    \end{cases}\\<br>    B_{i,k}(u)={u-u_i \over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)<br>\end{cases},\space 约定{0\over 0}=0<br>$$</p>
<blockquote>
<p>该递推公式表明：若确定第$i$个$k$阶B样条$B_{i,k}(u)$，需要用到$u_i,u_{i+1},…,u_{i+k}$共k+1个节点，称区间$[u_i，u_{i+k}]$为$B_{i,k}(u)$的支承区间</p>
</blockquote>
<h5 id="K阶B样条对应节点向量数"><a href="#K阶B样条对应节点向量数" class="headerlink" title="K阶B样条对应节点向量数"></a>K阶B样条对应节点向量数</h5><p>$$<br>deboor-Cox递推公式\begin{cases}<br>    B_{i,1}(u)=\begin{cases}<br>        1,\space u_i&lt;u&lt;u_{i+1}\\<br>        0,\space Otherwise<br>    \end{cases}\\<br>    B_{i,k}(u)={u-u_i\over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)<br>\end{cases},\space 约定{0\over 0}=0<br>$$</p>
<p>对于$B_{i,1}$（1阶0次基函数）来说，涉及$u_i$到$u_{i+1}$一个区间，即一阶的多项式涉及一个区间两个节点</p>
<p>$B_{i,2}$是由$B_{i,1}$和$B_{i+1,1}$，因此$B_{i,2}$涉及2个区间，3个节点。</p>
<p>$B_{i,3}$涉及3个区间，4个节点……$B_{i,k}$涉及k个区间，k+1个节点</p>
<h5 id="B样条函数定义区间"><a href="#B样条函数定义区间" class="headerlink" title="B样条函数定义区间"></a>B样条函数定义区间</h5><p>$$<br>P(u)=\displaystyle\sum_{i=0}^n{P_iB_{i,k}(u)},\space u∈[u_{k-1},u_{n+1}]<br>$$</p>
<p>以k=4，n=4为例，节点矢量为<br>$$<br>U={u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8}<br>$$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.7.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/9.7.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="9.7.1">

<p>上图区间是$u_3$到$u_5$（从$u_{k-1}$到$u_{n+1}$），B样条基函数<strong>严重依赖于节点向量的分布</strong></p>
<p>上面的曲线被分成两段：$u_3u_4,u_4u_5$。如有5个顶点$P_0、P_1、P_2、P_3、P_4$，B样条一段段过渡过去</p>
<p>哪些基函数是在$u_3u_4$区间里有定义？正好是$P_0P_1P_2P_3$</p>
<p>$P_1P_2P_3P_4$在$u_4u_5$区间里有定义，两端之间有三个顶点是一样这样就保证了两段拼接的效果非常好</p>
<h5 id="B样条基函数的主要性质"><a href="#B样条基函数的主要性质" class="headerlink" title="B样条基函数的主要性质"></a>B样条基函数的主要性质</h5><ol>
<li>局部支承性</li>
</ol>
<p>$$<br>B_{i,1}(u)\begin{cases}<br>        ≥0,\space u∈[u_i,u_{i+1}]\\<br>        =0,\space Otherwise<br>    \end{cases};而Bezier在整个区间非0<br>$$</p>
<p>反过来，对每一个区间$(u_i,u_{i+k})$，至多只有k个基函数在其上非零</p>
<ol start="2">
<li>权性</li>
</ol>
<p>$$<br>\displaystyle\sum_{i=0}^n{P_iB_{i,k}(u)}≡1,\space u∈[u_{k-1},u_{n+1}]<br>$$</p>
<ol start="3">
<li><p>连续性</p>
<p>$B_{i,k}(u)$在r重节点处的连续阶不低于$k-1-r$</p>
</li>
<li><p>分段参数多项式</p>
</li>
</ol>
<p>$B_{i,k}(u)$在每个长度非零的区间$[u_i,u_{i+1})$上都是次数不高于k-1的多项式，它在整个参数轴上是分段多项式</p>
<h5 id="B样条函数的主要性质"><a href="#B样条函数的主要性质" class="headerlink" title="B样条函数的主要性质"></a>B样条函数的主要性质</h5><ol>
<li>局部性</li>
</ol>
<blockquote>
<p>k阶B样条曲线上的一点至多与k个控制顶点有关，与其它控制顶点无关</p>
<p>移动曲线的第$i$个控制顶点$P_i$，至多影响到定义在区间上那部分曲线的形状，对曲线其余部分不发生影响</p>
</blockquote>
<ol start="2">
<li>变差缩减性</li>
</ol>
<blockquote>
<p>设平面内n+1个控制顶点构成B样条曲线P(t)的特征多边形。在该平面内的任意一条直线与P(t)的交点个数不多于该直线和特征多边形的交点个数</p>
</blockquote>
<ol start="3">
<li>几何不变性</li>
</ol>
<blockquote>
<p>B样条曲线的形状和位置与坐标系的选择无关</p>
</blockquote>
<ol start="4">
<li>凸包性</li>
</ol>
<blockquote>
<p>B样条曲线落在$P_i$构成的凸包之中。其凸包区域小于或等于同一组控制顶点定义的Bezier曲线凸包区域。</p>
<p>凸包就是包含右边这6个顶点的最小凸多边形。凸多边形是把多边形的每条边延长，其它边都在它的同一侧。</p>
<p>该性质导致顺序k+1个顶点重合时，由这些顶点定义的k次B样条曲线段退化到这一个重合点.</p>
</blockquote>
<h5 id="B样条曲线类型的划分"><a href="#B样条曲线类型的划分" class="headerlink" title="B样条曲线类型的划分"></a>B样条曲线类型的划分</h5><ol>
<li>均匀B样条曲线(uniform B-spline curve)</li>
</ol>
<p>当节点沿参数轴均匀等距分布，即$u_{i+1}-u_i=常数&gt;0$时，表示均匀B样条函数</p>
<p>均匀B样条的基函数呈周期性。即给定n和k，所有的基凼数有相同形状。每个后续基函数仅仅是前面基函数在新位置上的重复：<br>$$<br>B_{i,1}(u)=B_{i+1,1}(u+Δu)=B_{i+2,1}(u+2Δu)<br>$$<br>其中，Δu是相邻节点值的间距</p>
<br/>

<p>※下面以均匀二次（三阶）B样条曲线为例来说明均匀周期性B样条函数的计算：</p>
<p>假定有四个控制点，取参数值n=3，k=3，则n+k=6，$u=(0,1,2,3,4,5,6)$</p>
<p>根据de boor-Cox递推公式：<br>$\begin{cases}<br>    B_{i,1}(u)=\begin{cases}<br>        1,\space u_i&lt;u&lt;u_{i+1}\\<br>        0,\space Otherwise<br>    \end{cases}\\<br>    B_{i,k}(u)={u-u_i \over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)<br>\end{cases}$</p>
<p>$B_{0,1}(u)=\begin{cases}<br>    1,\space 0≤u&lt;1\\<br>    0,\space 其它<br>\end{cases}$</p>
<p>$\begin{split}<br>B_{0,2}(u)&amp;=uB_{0,1}(u)+(2-u)B_{1,1}(u)\\<br>&amp;=uB_{0,1}(u)+(2-u)B_{1,1}(u)\\<br>&amp;=\begin{cases}<br>    u,\space 0≤u&lt;1\\<br>    2-u,\space 1≤u&lt;2<br>\end{cases}\end{split}$</p>
<p>$\begin{split}<br>B_{0,3}(u)&amp;={u\over 2}B_{0,2}(u)+{(3-u)\over 2}B_{1,2}(u-1)\\<br>&amp;=\begin{cases}<br>    {1\over 2}u^2,\space 0≤u&lt;1\<br>    {1\over 2}u(2-u)+{1\over 2}(u-1)(3-u),\space 1≤u&lt;2\\<br>    {1\over 2}(3-u)^2,\space 2≤u&lt;3<br>\end{cases}\end{split}$</p>
<p>$B_{1,3}(u)=\begin{cases}<br>    {1\over 2}(u-1)^2,\space 1≤u&lt;2\\<br>    {1\over 2}(u-1)(3-u)+{1\over 2}(u-2)(4-u),\space 1≤u&lt;3\\<br>    {1\over 2}(4-u)^2,\space 3≤u&lt;4<br>\end{cases}$</p>
<h5 id="准均匀B样条曲线-Quasi-uniform-B-spline-curve"><a href="#准均匀B样条曲线-Quasi-uniform-B-spline-curve" class="headerlink" title="准均匀B样条曲线(Quasi-uniform B-spline curve)"></a>准均匀B样条曲线(Quasi-uniform B-spline curve)</h5><blockquote>
<p>与均匀B样条曲线的差别在于两端节点具有重复，这样的节点矢量定义了准均匀的B样条基函数</p>
<p>均匀B样条曲线没有保留 Bezier曲线端点的几何性质，采用准均匀的B样条曲线解决了这个问题</p>
</blockquote>
<p>均匀：$u=(0,1,2,3,4,5,6)$</p>
<p>准均匀：$u=(0,0,0,1,2,3,4,5,5,5)$</p>
<h4 id="分段Bezier曲线（Piecewise-Bezier-Curve）"><a href="#分段Bezier曲线（Piecewise-Bezier-Curve）" class="headerlink" title="分段Bezier曲线（Piecewise Bezier Curve）"></a>分段Bezier曲线（Piecewise Bezier Curve）</h4><blockquote>
<p>节点矢量中两端节点具有重复度k，所有内节点重复度为k-1，这样的节点矢量定义了分段的 Bernstein基</p>
<p>B样条曲线用分段Bezier曲线表示后，各曲线段就具有了相对的独立性\</p>
<p>另外， Bezier曲线一整套简单有效的算法都可以原封不动地采用</p>
<p>缺点：增加了定义曲线的数据，控制顶点数及节点数</p>
</blockquote>
<h4 id="非均匀B样条曲线（non-uniform-B-spline-curve）"><a href="#非均匀B样条曲线（non-uniform-B-spline-curve）" class="headerlink" title="非均匀B样条曲线（non- uniform B- spline curve）"></a>非均匀B样条曲线（non- uniform B- spline curve）</h4><blockquote>
<p>当节点沿参数轴的分布不等距，即$u_{i+1}-u_i≠常数$时，表示非均匀B样条函数</p>
</blockquote>
<h4 id="B样条曲面"><a href="#B样条曲面" class="headerlink" title="B样条曲面"></a>B样条曲面</h4><blockquote>
<p>给定参数轴u和v的节点矢量<br>$\begin{cases}U=[u_0,u_1,…,u_{m+p}]\\V=[v_0,v_1,…,v_{n+q}]\end{cases}$<br>$p×q$阶B样条曲面定义如下：<br>$P(u,v)=\displaystyle\sum^m_{i=0}\displaystyle\sum_{j=0}^n{P_{i,j}N_{i,p}(u)N_{j,q}(v)},\space u∈[u_{k-1},u_{n+1}]$<br>$P_{i,j}$构成一张控制网格，称为B样条曲面的特征网格</p>
<p>$N_{i,p}(u)$和$N_{j,q}(v)$是B样条基，分别由节点矢量U和V按de Boor-Cox递推公式决定</p>
</blockquote>
<h3 id="NURBS曲线（面）"><a href="#NURBS曲线（面）" class="headerlink" title="NURBS曲线（面）"></a>NURBS曲线（面）</h3><blockquote>
<p>NURBS曲线（面）的提出</p>
<p>Bezier曲线（面）$\implies$B样条曲线（面）</p>
<p>B样条方法在表示与设计自由型曲线、曲面形状时显示了强大的威力，然而在表示与设计初等曲线、曲面时时却遇到了麻烦。B样条曲线（面）和 Bezier曲线（面）不能精确表示出抛物线以外的二次曲线（面），如圆弧、圆。</p>
<p>而在工程应用特别是在工业设计当中，都用到图纸。而表示图纸的元素就是直线、圆弧和一些标注信息</p>
</blockquote>
<blockquote>
<p>NURBS(Non-Uniform Rational B-Splines)：非均匀有理B样条方法，主要是为了找到与描述自由型曲线曲面的B样条方法既相统一，又能精确表示二次曲线曲面（圆弧、抛物线、椭圆等）的数学方法</p>
<p>NURBS一种最一般最有代表性的表示方法。既为标准解析形状（即前面提到的初等曲线曲面），又为自由型曲线曲面的精确表示与设计提供了一个公共的数学形式，广泛应用在各种3D造型系统中，如3DMAX，Maya等</p>
</blockquote>
<h4 id="NURBS曲线的定义"><a href="#NURBS曲线的定义" class="headerlink" title="NURBS曲线的定义"></a>NURBS曲线的定义</h4><p>NURBS（Non-Uniform Rational B-Splines）非均匀有理B样条的缩写</p>
<p>有理（Rational）函数是两个多项式之比。</p>
<p>因此，有理B样条可描述为：<br>$$<br>\begin{split}<br>P(u)&amp;={\displaystyle\sum_{i=0}^nω_iP_iB_{i,k}(u)\over \displaystyle\sum_{i=0}^nω_iB_{i,k}(u)}\\<br>&amp;=\displaystyle\sum_{i=0}^n P_iR_{i,k}(u),\space\space R_{i,k}(u)={ω_iB_{i,k}(u) \over \displaystyle\sum_{j=0}^nω_jB_{j,k}(u)}<br>\end{split}<br>$$</p>
<p>$ω_i$：是控制顶点的权因子。其大小决定曲线偏离控制顶点的距离。值越大，曲线越靠近控制顶点$P_i$。</p>
<h4 id="NURBS曲线的性质"><a href="#NURBS曲线的性质" class="headerlink" title="NURBS曲线的性质"></a>NURBS曲线的性质</h4><p>NURBS曲线与B样条曲线具有类似的几何性质：</p>
<ol>
<li>局部性质</li>
<li>变差减小性质</li>
<li>凸包性</li>
<li>在仿射与透射变换下的不变性</li>
<li>在曲线定义域内有与有理基函数同样的可微性</li>
</ol>
<h4 id="NURBS曲面的定义"><a href="#NURBS曲面的定义" class="headerlink" title="NURBS曲面的定义"></a>NURBS曲面的定义</h4><p>$\begin{split}<br>P(u)&amp;={\displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}ω_{ij}P_{ij}B_{i,p}(u)N_{j,q}(v)\over \displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}ω_iB_{i,p}(u)N_{j,q}(v)}\\<br>&amp;=\displaystyle\sum^m_{i=0}\displaystyle\sum^n_{j=0}P_{ij}R_{i,p;j,q}(u,v)<br>,\space u,v∈[0,1]<br>\end{split}$</p>
<p>$基函数：R_{i,p;j,q}(u,v)={ω_{ij}N_{i,p}(u)N_{j,p}(v)\over \displaystyle\sum^m_{r=0}\displaystyle\sum^n_{s=0}ω_{rs}N_{r,p}(u)N_{s,q}(v)}$</p>
<h2 id="真实感图形学"><a href="#真实感图形学" class="headerlink" title="真实感图形学"></a>真实感图形学</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>简单地说，就是希望用计算机生成像照相机拍的照片一样逼真的图形图像。</p>
<p>要实现这个目标，需要三部曲：</p>
<ol>
<li>建立三维场景（建模）；</li>
<li>消隐解决物体深度的显示及确定物体之内的相互关系；</li>
<li>在解决了消隐问题之后，在可见面上进行明暗光泽的处理，然后进行绘制（渲染）。</li>
</ol>
</blockquote>
<h4 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h4><blockquote>
<p><strong>什么是颜色：</strong></p>
<ol>
<li><p>颜色是人的视觉系统对可见光的感知结果，感知到的颜色由光波的波长决定。</p>
</li>
<li><p>人眼对于颜色的观察和处理是一种生理和心理现象，其机理还没有完全搞清楚。</p>
</li>
<li><p>视觉系统能感觉的波长范围为380~780nm。</p>
</li>
</ol>
<p><strong>什么是颜色模型？</strong></p>
<ol>
<li>颜色模型（空间），是表示颜色的一种数学方法，人们用它来指定颜色和标定产生的颜色。通常用三个参数表小。</li>
<li>几乎所有的颜色模型都是从RGB颜色模型导出</li>
<li>目前现有颜色模型还没有一个完全符合人的视觉感知特性、颜色本身的物理特性或发光物体和光反射物体的特性。</li>
</ol>
</blockquote>
<h5 id="常用颜色模型"><a href="#常用颜色模型" class="headerlink" title="常用颜色模型"></a>常用颜色模型</h5><ol>
<li>RGB颜色工业模型</li>
<li>其它颜色工业模型<ul>
<li>主要用于彩色电视信号传输标准，主要有YIQ、YUV、 YCbCr彩色模型。</li>
<li>三种彩色模型中，Y分量均代表黑白亮度分量，其余分量用于显示彩色信息。这样，只需利用Y分量进行图像显示，彩色图像就转换为灰度图像</li>
</ul>
</li>
<li>颜色视觉模型<ul>
<li>以上彩色模型是从色度学或硬件实现的角度提出的，但用色调（Hue）、饱和度（ Saturation，也称彩度）、亮度（Illumination）三要素来描述彩色空间能更好地与人的视觉特性相匹配。<ul>
<li>色调（Hue）：由物体反射光线中占优势的波长决定的，是彩色互相区分的基本特性。</li>
<li>饱和度（ Saturation）或彩度：彩色的深浅程度，它取决于彩色中白色的含量。饱和度越高，彩色越深，白色光越少。</li>
<li>亮度（Illumination）：光波作用于感受器所发生的效应，它取决于物体的反射系数。反射系数越大，物体亮度越大</li>
</ul>
</li>
</ul>
</li>
<li>其他颜色视觉模型<ul>
<li>HSV（hue, saturat ion and value彩色模型<ul>
<li>A.R. Smith根据颜色的直观特性于1978年创建的，是颜色的倒六角锥体模型。</li>
</ul>
</li>
<li>HSL与HSV<ul>
<li>HSL采用亮度L（lightness）、HSV采用明度V（ value）作为坐标。</li>
</ul>
</li>
</ul>
</li>
</ol>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.1.1.jpg" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.1.1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.1.1">

<h3 id="简单光照模型"><a href="#简单光照模型" class="headerlink" title="简单光照模型"></a>简单光照模型</h3><blockquote>
<ol>
<li>光照模型<ul>
<li>当物体的几何形态确定之后，光照决定了整个场景的显示结果。因此，真实感图形的生成取决于如何建立个合适的光照模型（illumination model）。</li>
</ul>
</li>
<li>光照明模型：模拟物体表面的光照明物理现象的数学模型。<ul>
<li>简单光照明模型只考虑光源对物体的直接光照</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="背景物理知识"><a href="#背景物理知识" class="headerlink" title="背景物理知识"></a>背景物理知识</h5><ol>
<li><p>光的传播规律反射定律</p>
<ul>
<li>入射角等于反射角，而且反射光线、入射光线与法向量在同一平面上。</li>
</ul>
</li>
<li><p>折射定律折射定律</p>
<ul>
<li>折射线在入射线与法线构成的平面上，折射角与入射角满足：</li>
</ul>
</li>
</ol>
<p>$$<br>{η_1\over η_2}={\sinφ \over \sinθ}<br>$$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.2.1">

<ol start="3">
<li>能量关系<ul>
<li>在光的反射和折射现象中的能量分布（满足能量守恒）</li>
</ul>
</li>
</ol>
<h4 id="Phong光照模型（环境光-漫反射光-镜面反射光）"><a href="#Phong光照模型（环境光-漫反射光-镜面反射光）" class="headerlink" title="Phong光照模型（环境光+漫反射光+镜面反射光）"></a>Phong光照模型（环境光+漫反射光+镜面反射光）</h4><img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.2.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.2.2">

<ul>
<li><p>环境光</p>
<ul>
<li>邻近各物体所产生的光的多次反射最终达到平衡时的种光。可近似认为同一环境下的环境光，其光强分布是均匀的。</li>
<li>$I_{ambient}=I_aK_a\\I_a-环境光强度；K_a-环境光反射系数$</li>
</ul>
</li>
<li><p>漫反射光</p>
<ul>
<li><p>光照射到比较粗糙的物体表面，物体表面某点的明暗程度不随观测者的位置变化，这种等同地向各个方向散射的现象称为光的漫反射。</p>
</li>
<li><p>漫反射光强近似服从Lambert定律：</p>
<p>$I_{diffuse}=I_pK_d(L·N)\\I_p-点光源光强；K_d-物体表面漫反射率$</p>
</li>
</ul>
</li>
<li><p>镜面反射光</p>
<ul>
<li><p>光照射到相当光滑的物体表面，就产生镜面反射光，其特点是在光滑表面会产生高光区域。</p>
</li>
<li><p>一般用Phong提出的经验模型表达：</p>
<p>$I_{spec}=I_pK_s(R·V)^n\\I_p-点光源光强；K_s-物体表面某点的高光亮系数；n-镜面反射指数，1^2000，反映光滑程度$</p>
</li>
</ul>
</li>
</ul>
<p>得出Phong光照模型：<br>$$<br>\begin{split}<br>I&amp;=I_{ambient}+I_{diffuse}+I_{spec}\\<br>&amp;=I_aK_a+I_pK_d(L·N)+I_pK_s(R·V)^n<br>\end{split}<br>$$<br>结合RGB颜色模型， Phong光照明模型最终有如下的形式：<br>$$<br>\begin{cases}<br>I_r=I_{ar}K_{ar}+I_{pr}K_{dr}(L·N)+I_{pr}K_{sr}(R·V)^n\\<br>I_g=I_{ag}K_{ag}+I_{pg}K_{dg}(L·N)+I_{pg}K_{sg}(R·V)^n\\<br>I_b=I_{ab}K_{ab}+I_{pb}K_{db}(L·N)+I_{pb}K_{sb}(R·V)^n<br>\end{cases}<br>$$</p>
<blockquote>
<p>Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型，生成图象的真实度已经达到可以接受的程度。</p>
<p>Phone模型用来模拟光从物体表面到观察者眼睛的反射。尽管这种方法符合一些基本的物理法则，但它更多的是基于对现象的观察，所以被看成是一种经验式的方法。</p>
<p>在实际的应用中，由于Phonηg光照模型是一个经验模型，因此还具有以下的一些问题：</p>
<ul>
<li>显示出的物体象塑料，无质感变化</li>
<li>没有考虑物体间相互反射光</li>
<li>镜面反射颜色与材质无关</li>
<li>镜面反射入射角大，会产生失真现象</li>
</ul>
</blockquote>
<h3 id="增量式光照模型"><a href="#增量式光照模型" class="headerlink" title="增量式光照模型"></a>增量式光照模型</h3><blockquote>
<p><strong>为什么要进行明暗处理？</strong></p>
<ul>
<li>三维物体通常用多边形（三角形）来近似模拟。</li>
<li>由于每一个多边形的法向一致，因而多边形内部的像素的颜色都是相同的，而且在不同法向的多边形邻接处，光强突变，使具有不同光强的两个相邻区域之间的光强不连续性（马赫带效应）。</li>
</ul>
<p><strong>如何进行明暗处理？</strong></p>
<ul>
<li>基本思想：每一个多边形的顶点处计算出光照强度或参数，然后在各个多边形内部进行均匀插值</li>
<li>常用方法：<ul>
<li>Gouraud明暗处理（双线性光强插值算法）</li>
<li>Phong明暗处理（双线性法向插值算法）</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Gouraud明暗处理"><a href="#Gouraud明暗处理" class="headerlink" title="Gouraud明暗处理"></a>Gouraud明暗处理</h4><ol>
<li>计算多边形顶点的平均法向量<br>与某个顶点相邻的所有多边形的法向平均值近似作为该顶点的近似法向量，顶点A相邻的多边形有k个，它的法向量计算为：</li>
</ol>
<p>$$<br>N_a={1\over k}(N_1+N_2+…+N_k)<br>$$</p>
<ol start="2">
<li><p>用Phong光照模型计算顶点的光强</p>
<p>Phong光照模型出现前，采用如下光照模型计算：<br>$$<br>I=I_aK_a+I_pK_d(L·N_a)/(r+k)<br>$$</p>
</li>
<li><p>插值计算离散边上个点的光强</p>
</li>
</ol>
<p>$$<br>I_A=uI_1+(1-u)I_2,\space u={AV_2\over V_1V_2}<br>$$<br>$$<br>I_B=vI_1+(1-u)I_3,\space v={BV_3\over V_1V_3}<br>$$</p>
<ol start="4">
<li>插值计算多边形内域中各点的光强</li>
</ol>
<p>$$<br>I_p=tI_A+(1-t)I_B,\space t={PB\over AB}<br>$$</p>
<blockquote>
<p>求任一点的光强需进行两次插值计算</p>
</blockquote>
<ul>
<li>为减少计算量，采用增量计算方法</li>
</ul>
<p>$$<br>新扫描线：\begin{cases}<br>I_{A,j+1}=I_{A,j}+ΔI_A\\<br>I_{B,j+1}=I_{B,j}+ΔI_B\\<br>ΔI_A=(I_1-I_2)/(y_1-y_2)\\<br>ΔI_B=(I_1-I_3)/(y_1-y_3)<br>\end{cases}<br>$$</p>
<blockquote>
<p>Gouraud明暗处理有一个最大的缺点，就是不能有镜面反射光（高光）。</p>
<p>双线性插值是把能量往四周均匀，平均的结果就是光斑被扩大了，本来没有光斑的地方一插值反而出现了光斑。</p>
<p>解决办法：Phong明暗处理</p>
</blockquote>
<h4 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h4><blockquote>
<p>与 Gouraud明暗处理有何不同？</p>
<ul>
<li>双线性光强插值&gt;&gt;双线性法向插值</li>
<li>以时间为代价，引入镜面反射，解决高光问题</li>
</ul>
</blockquote>
<p>Phong明暗处理基本步骤：</p>
<ol>
<li>计算每个多边形顶点处的平均单位法矢量，这一步骤与Gour aud明暗处理方法的第一步相同。</li>
<li>用双线性插值方法求得多边形内部各点的法矢量。</li>
<li>最后按光照模型确定多边形内部各点的光强。</li>
</ol>
<p>Phong明暗处理是先算角点的法向量，再算内部点的法向量最后再用新的光照模型算内部点的颜色值。</p>
<h4 id="两种增量式光照模型比较"><a href="#两种增量式光照模型比较" class="headerlink" title="两种增量式光照模型比较"></a>两种增量式光照模型比较</h4><table>
<thead>
<tr>
<th align="center">Phong方法</th>
<th align="center">Gouraud方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1、产生的效果高光明显；<br/>2、高光多位于多边形内部；<br/>3、明暗变化缺乏层次感。</td>
<td align="center">1、效果并不明显；<br/>2、多边形内部无高光；<br/>3、光强度变化均匀，与实际效果更接近。</td>
</tr>
</tbody></table>
<ul>
<li>增量式光照模型总结<ul>
<li>双线性光强插值（Gouraud模型）能有效的显示漫反射曲面，计算量小，速度快。</li>
<li>双线性法向插值（Phong模型）可以产生正确的高光区域，但是计算量要大的多。</li>
<li>增量式光照明模型的不足<ul>
<li>物体边缘轮廓是折线段而非光滑曲线</li>
<li>等间距扫描线会产生不均匀效果</li>
<li>插值结果取决于插值方向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部光照模型"><a href="#局部光照模型" class="headerlink" title="局部光照模型"></a>局部光照模型</h3><blockquote>
<p>局部光照模型：仅处理光源直接照射物体表面的光照模型。</p>
<p>简单光照模型是一个比较粗糙的经验模型，不足之处：镜面反射项与物体表面的材质无关。</p>
<p>从光电学知识和物体微平面假设出发，介绍镜面反射与物体材质有关的普遍局部光照模型。</p>
</blockquote>
<h4 id="自然光反射"><a href="#自然光反射" class="headerlink" title="自然光反射"></a>自然光反射</h4><ul>
<li>自然光反射率系数可用Fresnel公式计算</li>
</ul>
<p>$$<br>ρ={1\over 2}\left({tg^2(θ-φ)\over tg^2(θ+φ)}+{sin^2(θ-φ)\over sin^2(θ+φ)}\right)<br>$$</p>
<p>θ是入射角，若发生反射的物体表面两侧折射率分别为和$n_1，n_2$那么φ满足这样的一个式子：$\sin φ={n_1\over n_2}\sin θ$</p>
<ul>
<li>反射率与折射率有关，是波长的函数$ρ(θ,λ)$</li>
</ul>
<h4 id="光反射率"><a href="#光反射率" class="headerlink" title="光反射率"></a>光反射率</h4><ul>
<li><p>微观情况下，物体表面粗糙不平。</p>
</li>
<li><p>宏观上看，这是一个平面，法向朝上。实际上它是由许多微小平面构成的，微小平面的法向是各异的。</p>
</li>
<li><p>微平面是理想镜面，反射率可用Fresnel公式计算，而粗糙表面的反射率与表面的粗糙度有关。</p>
</li>
<li><p>实际物体反射率：$DGρ(θ,λ)$</p>
<ul>
<li>D为微平面法向的分布函数</li>
<li>G为由于微平面的相互遮挡或屏蔽而使光产生的衰减因子</li>
</ul>
</li>
<li><p>Torrance和Sparrow采用Gauss分布函数模拟法向分布：</p>
<ul>
<li>$D=ke^{(-a/m)^2}$<ul>
<li>k为常系数</li>
<li>a为微平面的法向与平均法向的夹角，即(N·H)</li>
<li>m为微平面斜率的均方根，表示表面的粗糙程度<ul>
<li>$m=\sqrt{m_1^2+m_2^2+…+m_n^2\over n}$</li>
</ul>
</li>
<li>也可采用Berkmann分布函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="光的衰减"><a href="#光的衰减" class="headerlink" title="光的衰减"></a>光的衰减</h4><ul>
<li>衰减因子G在局部光照明模型中也可以反映物体表面的粗糙程度。</li>
<li>衰减因子是由于微平面的相互遮挡或屏蔽而产生的</li>
<li>微平面相互遮挡的光衰减因子G，有三种情况：</li>
</ul>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.1.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.4.1">



<h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><ul>
<li><p>Cook和Torrance于1981年提出了局部光照模型。</p>
<ul>
<li><p>$R_{bd}$表示物体对入射光的反射率系数<br>$$<br>R_{bd}={I_r\over E_i}<br>$$</p>
</li>
<li><p>$I_r$—反射光的光强</p>
</li>
<li><p>$E_i$—单位时间内单位面积上的入射光能量</p>
</li>
</ul>
</li>
<li><p>入射光能量$E_i$，可用入射光的光强$I_i$和单位面积向光源所张的立体角$dω$表示为：</p>
</li>
</ul>
<p>$$<br>E_i=I_i\cosθ·dω=I_i(N·L)dω<br>$$</p>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.2.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.4.2">

<ul>
<li>于是有反射光光强</li>
</ul>
<p>$$<br>I_r=R_{bd}E_i=R_{bd}I_i(N·L)dω<br>$$</p>
<ul>
<li><p>反射率系数可表示为漫反射率与镜面反射率的代数和：<br>$$<br>R_{bd}=K_dR_d+K_sR_s<br>$$</p>
<ul>
<li>$K_d+K_s=1$ 漫反射与镜面反射系数</li>
<li>物体表面的漫反射率：$R_d=R_d(λ)$</li>
<li>物体表面的镜面反射率：$R_s={DGρ(θ,λ)\over\pi(N·L)(N·V)}$</li>
</ul>
</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>加入环境光的计算，局部光照模型表示为：<br>$$<br>I_r=I_aK_a+I_i(N·L)dω(K_dR_d+K_sR_s)<br>$$</p>
<ul>
<li>$I_r$物体表面反射光强</li>
<li>$I_aK_a$表示环境光的影响</li>
<li>最后一项是考虑了物体表面性质后的反射光强度量，是该局部光照模型的复杂性与普遍性所在。</li>
</ul>
</li>
<li><p>相对于简单光照模型而言</p>
<ul>
<li>基于入射光能量导出的光辐射模型</li>
<li>反映表面的粗糙度对反射光强的影响</li>
<li>高光颜色与材料的物理性质有关</li>
<li>改进入射角很大时的失真现象</li>
<li>考虑了物体材质的影响，可以模拟磨光的金属光泽</li>
</ul>
</li>
</ul>
<h3 id="光透射模型"><a href="#光透射模型" class="headerlink" title="光透射模型"></a>光透射模型</h3><blockquote>
<p> 简单和局部光照模型没有考虑光的透射现象</p>
<p> 适用于场景中有透明或者半透明的物体的光照处理</p>
<p> 早期用颜色调和法进行模拟</p>
</blockquote>
<h4 id="Whitted光透射模型"><a href="#Whitted光透射模型" class="headerlink" title="Whitted光透射模型"></a>Whitted光透射模型</h4><blockquote>
<p>1980年Whitted提出了第一个整体光照模型，并给出了一般光线跟踪算法的范例，综合考虑了光的反射、折射、透射和阴影等。被认为是计算机图形领域的一个里程碑。</p>
</blockquote>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.3.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.4.3">

<p>在简单光照明模型的基础上，加上透射光项就得到Whitted光透射模型：<br>$$<br>I=I_a·K_a+I_p·K_d·(L·N)+I_p·K_s·(R·V)^n+I’_t·K’_t<br>$$<br>再加上镜面反射光项，就得到Whitted整体光照模型：<br>$$<br>I=I_a·K_a+I_p·K_d·(L·N)+I_p·K_s·(R·V)^n+I’_t·K’_t+I’_s·K’_s<br>$$</p>
<h3 id="整体光照模型"><a href="#整体光照模型" class="headerlink" title="整体光照模型"></a>整体光照模型</h3><blockquote>
<p>简单和局部光照模型不能很好地模拟光的折射、反射和阴影等，也不能用来表示物体间的相互光照影响</p>
<p>整体光照模型是更精确的光照模型，主要有<strong>光线跟踪</strong>和<strong>辐射度</strong>两种方法。</p>
</blockquote>
<h4 id="光线跟踪（Ray-tracing）"><a href="#光线跟踪（Ray-tracing）" class="headerlink" title="光线跟踪（Ray tracing）"></a>光线跟踪（Ray tracing）</h4><blockquote>
<p>光线跟踪算法是真实感图形学中的主要算法之一，该算法具有原理简单、实现方便和能够生成各种逼真的视觉效果等突出的优点，综合考虑了光的反射、折射、阴影等</p>
</blockquote>
<img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.4.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.4.4">

<blockquote>
<p>光线跟踪怎么停止？</p>
<ul>
<li><p>在算法应用的意义上，可以有以下几种终止条件。</p>
<ul>
<li>该光线未碰到任何物体</li>
<li>该光线碰到了背景光线在经过许多次反射和折射以后，就会产生衰减</li>
<li>光线对于视点的光强贡献很小</li>
<li>光线反射或折射次数即跟踪深度大于一定值</li>
</ul>
</li>
</ul>
<p>光线跟踪的缺陷</p>
<ul>
<li>光线跟踪方法由于要进行大量的求交运算，且每一条射线都要和所有的物体求交，因此效率很低，需要耗费大量的计算时间。</li>
<li>光线跟踪方法可以进行加速<ul>
<li>提是高求交速度：针对性的几何算法、……</li>
<li>减成少求交次数：包围盒、空间索引、……</li>
<li>减少光线条数：颜色插值、自适应控制、……</li>
<li>采用广义光线和采用并行算法等</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><blockquote>
<p>在真实感图形学中，可以用下列两种方法来定义纹理：</p>
<ol>
<li>图象纹理：将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值。</li>
<li>函数纹理：用数学函数定义简单的二维纹理图案，如方格地毯；或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理。</li>
</ol>
<p><strong>纹理映射（Texture Mapping）：</strong>通过将数字化的纹理图像覆盖或投射到物体表面，而为物体表面增加表面细节的过程。</p>
</blockquote>
<p>颜色纹理坐标转换通常使用下列两种方法：</p>
<ol>
<li><p>在绘制一个三角形时，为每个顶点指定纹理坐标，角形内部点的纹理坐标由纹理三角形的对应点确定。</p>
<p>即指定：<br>$$<br>\begin{split}<br>(x_0,y_0,z_0)\implies(u_0,v_0)\\<br>(x_1,y_1,z_1)\implies(u_1,v_1)\\<br>(x_2,y_2,z_2)\implies(u_2,v_2)<br>\end{split}<br>$$</p>
</li>
<li><p>指定映射关系：<br>$$<br>\begin{split}<br>u=a_0x+a_1y+a_2z+a_3\\<br>v=b_0x+b_1y+b_2z+b_3<br>\end{split}<br>$$</p>
</li>
</ol>
<hr>
<p>几何纹理使用一个称为扰动函数的数学函数进行定义</p>
<p>扰动函数通过对景物表面各采样点的位置作微小扰动来改变表面的微观几何形状。</p>
<p>设景物表面由下述参数方程定义：$Q=Q(u,v)$</p>
<p>则表面任一点(u,v)处的法线为：$N=N(u,v)={Q_u^(u,v)×Q_v(u,v)\over |Q_u^(u,v)×Q_v(u,v)|}$</p>
<p>设扰动函数为：$P(u,v)$</p>
<p>扰动后的表面为：$Q’=Q(u,v)+P(u,v)N$</p>
<h3 id="阴影处理"><a href="#阴影处理" class="headerlink" title="阴影处理"></a>阴影处理</h3><img src="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.5.png" class="lazy" data-srcset="/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/10.4.5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="10.4.5">

<ul>
<li><p>本影</p>
<ul>
<li><strong>umbra-本影区：</strong>场景中的一个点P，如果它不被光源的任何部分所照射到，就称为在本影区里。本影就是不被任何光原所照到的区域。</li>
</ul>
</li>
<li><p>半影</p>
<ul>
<li><strong>Occluder-遮挡物：</strong>阴影的生成是因为空间有遮挡物。这些遮挡物把光源挡住了，所以在receivers上有些部分就很阴暗</li>
<li>阴影是本影和半影的组合。求出本影和半影的并集(union)来绘出阴影</li>
</ul>
</li>
<li><p>阴影</p>
<ul>
<li><strong>自身阴影：</strong>由于物体自身的遮挡而使光线照射不到它上面的某些面；</li>
<li><strong>投射阴影：</strong>由于物体遮挡光线，使场景中位于它后面的物体或区域受不到光照射而形成的。</li>
</ul>
</li>
</ul>
<h4 id="阴影算法"><a href="#阴影算法" class="headerlink" title="阴影算法"></a>阴影算法</h4><ul>
<li>阴影体法(Shadow Volume)<ul>
<li>由一个点光源和一个三角形可以生成一个无限大的阴影体。落在这个阴影体中的物体，就处于阴影中。</li>
<li>在对光线进行跟踪的过程中，如果这条射线穿过了阴影体的一个正面（朝向视点的一个面），则计数器加1.如果这条射线穿过了阴影体的一个背面（背向视点的一个面），则计数器减1.如果最终计数器的数值大于0，则说明这个像素处于阴影中，否则处于阴影之外。</li>
</ul>
</li>
<li>阴影图法(Shadow Mapping)<ul>
<li>这种方法的主要思想是使用Z缓冲器算法，从投射阴影的光源位置对整个场景进行绘制。</li>
<li>这时，对于Z缓冲器的每一个像素，它的z深度值包括了这个像素到距离光源最近点的物体的距离。一般将Z缓冲器中的整个内容称为阴影图(Shadow Map)，有时候也称为阴影深度图。</li>
<li>为了使用阴影图，需要对场景进行次绘制，不过这次是从视点的角度来进行的。</li>
<li>在对每个图元进行绘制的时候，将它们的位置与阴影图进行比较，如果绘制点距离光源比阴影图中的数值还要远，那么这个点就在阴影中，否则就不在阴影中。</li>
</ul>
</li>
</ul>

    </div>
     
    <div class="post-footer__meta">
    <p>
        updated at 2020-10-12
    </p>
</div> 
    <div class="post-meta__cats">
    
        <a href="/blogs/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-cats__link button">图形学</a>
    
    
        <a href="/blogs/tags/%E7%AE%97%E6%B3%95/" class="post-tags__link button"># 算法</a>
    
</div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/blogs/2020/07/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            操作系统
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/blogs/2020/04/29/dataBase/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            数据库概述
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
    
    
        <span id="busuanzi_container_site_uv" hidden>
            <span></span>
            <span id="busuanzi_value_site_uv"></span>
            <span>名访客</span>
            
                <span>,</span>
            
        </span>
    
    
        <span id="busuanzi_container_site_pv" hidden>
            <span></span>
            <span id="busuanzi_value_site_pv"></span>
            <span>次访问</span>
            
        </span>
    
 
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2019&nbsp;-&nbsp;2020 <a href="/blogs/">AlertNote</a>
        </p>
    
    
        
            <p>&lt;创作不易，且行且珍惜&gt;</p>

        
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 

  



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 


    <script>
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
                loader: {
                    source: {
                        '[tex]/amsCd': '[tex]/amscd',
                        '[tex]/AMScd': '[tex]/amscd'
                    }
                },
                tex: {
                    inlineMath: {'[+]': [['$', '$']]},
                    tags: 'ams'
                },
                options: {
                    renderActions: {
                        findScript: [10, doc => {
                            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                                const display = !!node.type.match(/; *mode=display/);
                                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                                const text = document.createTextNode('');
                                node.parentNode.replaceChild(text, node);
                                math.start = {node: text, delim: '', n: 0};
                                math.end = {node: text, delim: '', n: 0};
                                doc.math.push(math);
                            });
                        }, '', false],
                        insertedScript: [200, () => {
                            document.querySelectorAll('mjx-container').forEach(node => {
                                let target = node.parentNode;
                                if (target.nodeName.toLowerCase() === 'li') {
                                    target.parentNode.classList.add('has-jax');
                                }
                            });
                        }, '', false]
                    }
                }
            };
            (function () {
                var script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
                script.defer = true;
                document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    </script>
 

 




    </body>
</html>
