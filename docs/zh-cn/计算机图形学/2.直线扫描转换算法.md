# 直线扫描转换算法

## 数值微分法（DDA）

> 引进图形学中一个很重要的思想——增量思想

$ y_i = kx_i+b $

$ y_{i+1} = kx_{i+1}+b  \\=k(x_i+1)+b \\=kx_i+b+k \\=y_i+k $

**得到：**$ y_{i+1}=y_i+k $

即 当前步的y值 = 前一步的y值 + 斜率k（增量）

------


> [!note|style:flat|label:举例|labelVisibility:visible|iconVisibility:visible]
>
> 要求：DDA扫描转换连接两点$ P_0(0,0)与P_1(5,3) $的直线段。
> 
> 过程：$ k= {y_1-y_0 \over x_1-x_0}={3-0 \over 5-0}=0.6 $ **<1** 
> 
> 根据$ y_{i+1}=y_i+k $，得到下表的计算结果

|  X   |    Y    | int(y+0.5) |
| :--: | :-----: | :--------: |
|  0   |    0    |     0      |
|  1   |   0.6   |     1      |
|  2   | 0.6+0.6 |     1      |
|  3   | 1.2+0.6 |     2      |
|  4   | 1.8+0.6 |     2      |
|  5   | 2.4+0.6 |     3      |

但是此算法并不适用于$ |k| >1 $的情况，会导致光栅点太稀疏。

优化后算法
```c
void DDADrawLine::LineDDA(int x0, int y0, int x1, int y1)
{
	float x = 0.0;
	float y = 0.0;
	float m = 0.0;
	//添加增量，实现增量思想
	float dx = x1 - x0;
	float dy = y1 - y0;
	if(dx != 0)
	{
		m = dy / dx;
		if(m <= 1 && m >= -1)
		{
			y = y0;
			//斜率绝对值<1,x递增绘制像素顶点
			for(x = x0; x <= x1; x++)
			{
				glVertex2i(x, int(y + 0.5));
				y += m;
			}
		}
		if(m > 1 || m < -1)
		{
			m = 1 / m;//将斜率设为倒数
			x = x0;
			//斜率绝对值>1,y递增绘制像素顶点
			for(y = y0; y <= y1; y++)
			{
				glVertex2i(int(x + 0.5), y);
				x += m;
			}
		}
	}
	else
	{
		int x = x0;
		int y =0;
		y = (y0 <= y1) ? y0 : y1;
		int d = fabs((double)(y0 - y1));
		while(d >= 0)
		{
			glVertex2i(x, y);
			y++;
			d--;
		}
	}
}
```

## 中点画线算法

### 核心思路

> 基本原理采用直线的一般方程
> 
> $ F(x,y) = Ax+By+C=0 $ 
> 
> **其中：**$ A=-(\Delta y);  B=(\Delta x);  C=-B(\Delta x)  $

假定：$ 0 ≤ |k| ≤ 1 $， 因此每次在x方向+1，y方向+1或不变则需要判断。

![2.1](\img\2.1.png)

当 点Q 在 点M 上方 ，则$ P_u $离直线近，应为下一个像素点

反之则$ P_d $离直线近，应取$ P_d $为下一个像素点

------

为判断Q在M上方还是下方，把M带入理想直线方程：

- $ d_i = F(x_m,y_m) = F(x_i+1,y_i+0.5) \\= A(x_i+1)+B(y_i+0.5)+C$

  - 当$ d<0 $时，Q在M上方，应取$ P_u $;

  - 当$ d>0 $时，Q在M下方，应取$ P_d $;

  - 当$ d=0 $时，M在直线上，取$ P_u $ 或$ P_d $均可。

但此方法运算效率太低，因此需要优化。

### 算法优化
$ d_0=F(x_{m0},y_{m0}) \\=F(A(x_i+1)+B(y_i+0.5))+C $

计算出初值$ d_0=A+0.5B $

- $ d<0 $情况下，推导d的增量关系：
  - $ d_1=F(x_{m1},y_{m1}) \\=F(A(x_i+2)+B(y_i+1.5))+C \\=F(A(x_i+1)+B(y_i+0.5))+C+A+B $
  - **得到：**$ d_1=d_0+A+B $


- $ d≥0 $情况下，推导d的增量关系：
  - $ d_1=F(x_{m1},y_{m1}) \\=F(A(x_i+2)+B(y_i+1.5))+C \\=F(A(x_i+1)+B(y_i+0.5))+C+A $
  - **得到：**$ d_1=d_0+A $

------

## Bresenham算法

