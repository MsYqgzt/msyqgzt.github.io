还没整理格式，还很瞎眼！

# 多边形的扫描转换与区域填充

> 如何在离散的像素集上表示一个连续的二维图形

## 多边形的扫描转换
> **定义**
>
> 多边形有两种重要的表示方法：顶点表示和点阵表示
>
> （1）凸多边形：任意两顶点间的连线均在多边形内
> 
> （2）凹多边形：任意两顶点间的连线有不在在多边形内
> 
> （3）含内环的多边形：多边形内包含多边形
> 
> 光栅图形的一个基本问题是**把任意多边形的顶点表示转换为点阵表示**，这种转换称为多边形的扫描转换
> 

### X-扫描线算法
> **基本思想**
> 
> 按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作

#### 核心思路
> 按X递增顺序 排列交点的X坐标序列
> 
> 1. 确定多边形所占有的**最大扫描线数**，得到多边形顶点的最小和最大y值（$ y_{min}和y_{max} $）
> 2. 从$ y=y_{min} $到$ y=y_{max} $，每次用一条扫描线进行填充
>   - 求交：计算扫描线与多边形各边的交点
>   - 排序：把所有交点**按递增顺序**进行排序
>   - 交点配对：第一个与第二个，第三个与第四个…
>   - 区间填色：把这些相交区间内的像素置成不同于背景色的填充色

![3.1](img\3.1.png)

- 当扫描线与多边形顶点相交时，交点的取舍问题（交应保证为偶数个）

> **解决方案**
> 1. 若共享顶点的两条边 分别落在扫描线的两边，交点只算一个
> 2. 若共享顶点的两条边 在扫描线的同一边，这时交点作为0个或2个
>   - 共享顶点的两条边的 另外两个端点的y值若大于交点y值，则算作2个点
>   - 共享顶点的两条边的 另外两个端点的y值若小于交点y值，则算作0个点

此算法效率低，求交计算量非常大。

> 从三方面考虑加以改进：
> 1. 在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算
> 2. 考虑扫描线的连贯性。即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似
> 3. 最后考虑多边形的连贯性。即当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交

#### 算法改进

> 改进思路
> 引入一种数据结构
> （1）活性边表（AET）：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中。
> （2）结点内容（一个结点在数据结构里可用结构来表示）


$ k={Δy \over Δx}={y_{i+1}-y_i \over x_{i+1}-x_i} \\ \implies x_{i+1}=x_i+{1 \over k} $

即：$ Δx={1 \over k} $

另外，需要知道一条边何时不再与下一条扫描线相交，以便及时把它从有效边表中删除出去，避免下一步进行无谓的计算X

|            x             |                       Δx                        |         $ y_{max} $          |        next        |
| :----------------------: | :---------------------------------------------: | :--------------------------: | :----------------: |
| 当前扫描线与边的交点坐标 | 从当扫描线到下条扫描线之间的x增量，即斜率的倒数 | 该边所交的最高扫描线的坐标值 | 指向下一条边的指针 |

![3.2](img\3.2.png)

------

为了方便活性边表的建立与更新，需构造一个新边表（NET），用来存放多边形的边的信息，分为4个步骤：
（1）首先构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个结点，称为一个吊桶，对应多边形覆盖的每一条扫描线
（2）NET挂在与该边低端y值相同的扫描线桶中。
也就是说，存放在该扫描线第一次出现的边

|    $ y_{max} $    |     $ x_{min} $     | $ 1 \over k $ |                  next                   |
| :---------------: | :-----------------: | :-----------: | :-------------------------------------: |
| 该边的$ y_{max} $ | 该边较低点的x坐标值 |  该边的斜率   | 指向下一条具有相同较低端y坐标的边的指针 |

每做一次新的扫描线时，要对已有的边进行三个处理

1. 是否被去除掉；

2. 如果不被去除，第二就要对它的数据进行更新。所谓更新数据就是要更新它的x值

   即：$ x+{1 \over k} $

3. 看有没有新的边进来，新的边在NET里，可以插入排序插进来

这个算法过程从来没有求交，这套数据结构避免了求交运算

此算法的缺点是无法实现对未知边界的区域填充

### 边缘填充算法

其基本思想是按任意顺序处理多边形的每条边。在处理每条边时，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补）多边形的所有边处理完毕之后，填充即完成

### 栅栏填充算法
栅栏指的是一条过多边形顶点且与扫描线垂直的直线。它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补

### 边界标志算法
帧缓冲器中对多边形的每条边进行直线扫描转换，亦即对多边形边界所经过的象素打上标志然后再采用和扫描线算法类似的方法将位于多边形内的各个区段着上所需颜色由于边界标志算法不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级

## 区域填充
> **定义**
>
> 区域-—指已经表示成点阵形式的填充图形，是像素的集合
> 区域填充是指将区域内的一点（常称种子点）赋予给定颜色然后将这种颜色扩展到整个区域内的过程
> 
区域可采用内点表示和边界表示两种表示形式



![3.3](img\3.3.png)



内点表示：枚举出区域内部的所有像素，内部的所有像素着同一个颜色，边界像素着与内部像素不同的颜色

边界表示：枚举出边界上的所有像素，边界上的所有像素着同一个颜色，内部像素着与边界像素不同的颜色

区域填充算法要求区域是连通的，因为只有在连通区域中，才可能将种子点的颜色扩展到区域内的其它点。

区域可分为4向连通区域和8向连通区域

![3.4](img\3.4.png)

4向连通区域指的是从区域上一点出发，可通过四个方向，，即上、下、左、右移动的组合，在不越出区域的前提下，到达区域内的任意象素

8向连通区域指的是从区域内每一象素出发，可通过八个方向，即上、下、左、右、左上、右上、左下、右下这八个方向的移动的组合来到达

### 简单四连通种子填充算法（区域填充递归算法）

种子填充算法的原理是：假设在多边形区域内部有一像素已知，由此出发找到区域内的所有像素，用一定的颜色或灰度来填充假设区域采用边界定义，即区域边界上所有像素均具有某个特定值，区域内部所有像素均不取这一特定值，而边界外的像素则可具有与边界相同的值



使用栈结构来实现简单的种子填充算法
算法原理如下种子像素入栈，当栈非空时重复执行如下三步操作
（1）栈顶像素出栈
（2）将出栈像素置成要填充色
（3）按左、上、右、下顺序检查与栈像素相邻的四个像素，若其中某个像素不在边界且未置成填充色，则把该像素入栈



种子填充算法的不足之处
（1）有些像素会入栈多次，降低算法效率；栈结构占空间
（2）递归执行，算法简单，但效率不高。区域内每一像素都引进一次递归，进/出栈，费时费内存
（3）改进算法，减少递归次数，提高效率可以采用区域填充的扫描线算法