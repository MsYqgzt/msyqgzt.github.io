[{"title":"jQuery 样式篇","date":"2020-11-21T16:00:00.000Z","url":"/blogs/2020/11/22/jQuery%20Styles/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"],["前端","/blogs/tags/%E5%89%8D%E7%AB%AF/"],["Web框架","/blogs/tags/Web%E6%A1%86%E6%9E%B6/"]],"categories":[["JavaScript","/blogs/categories/JavaScript/"],["Node","/blogs/categories/Node/"]],"content":"初探jQuery jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。由于减少了一些代码，使得该版本比 jQuery 1.x 更小、更快。 如果开发者比较在意老版本 IE 用户，只能使用 jQuery 1.9 及之前的版本了。这里为了兼容性问题，使用的是 1.9 以上版本。 jQuery 每一个系列版本分为：压缩版(compressed) 与 开发版(development) 我们在开发过程中使用开发版（开发版本便于代码修改及调试） 项目上线发布使用压缩版（因为压缩版本体积更小，效率更快）。 jQuery是一个JavaScript脚本库，不需要特别的安装，只需要我们在页面&lt;head&gt; 标签内中，通过script标签引入 jQuery库即可。 为什么没有在 &lt;script&gt; 标签中使用 type=”text/javascript” ？ 在 HTML5 中，不必那样做了。JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！ 老规矩 - HelloWorld最简单的案例，当页面加载完成后，在页面中以居中的方式显示“Hello World”，效果如下： Hello World $(document).ready的作用是等页面的文档（document）中的节点都加载完毕后，再执行后续的代码，因为我们在执行代码的时候，可能会依赖页面的某一个元素，我们要确保这个元素真正的的被加载完毕后才能正确的使用。 jQuery对象与DOM对象的区别 这里先做个大概印象，后面再深入分析 我们需要清楚认识一点：jQuery对象与DOM对象是不一样的 举个🌰，我们要获取页面上这个id为test的p元素，然后给这个文本节点增加一段文字：“你好”，并且让文字颜色变成红色。 普通处理方式，通过标准JavaScript处理 通过原生DOM模型提供的document.getElementById(“test”)方法获取的DOM元素就是一个DOM对象，再通过innerHTML与style属性处理文本与颜色。 jQuery的处理 通过$(&#39;#test&#39;)方法会得到一个$p的jQuery对象，$p是一个类数组对象。这个对象里面包含了DOM对象的信息，然后封装了很多操作方法，调用自己的方法html与css，得到的效果与标准的JavaScript处理结果是一致的。 jQuery对象与DOM对象的转换jQuery库本质上还是JavaScript代码，它只是对JavaScript语言进行包装处理。我们使用jQuery的同时也能混合JavaScript原生代码一起使用。 在很多场景中，我们需要jQuery与DOM能够相互的转换，它们都是可以操作的DOM元素，jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。 jQuery转DOM 利用数组下标的方式读取到jQuery中的DOM对象 HTML代码 JavaScript代码 通过jQuery自带的get()方法 jQuery对象自身提供一个.get()方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供一个元素的索引： 其实我们翻开源码，看看就知道了，get方法就是利用的第一种方式处理的，只是包装成一个get让开发者更直接方便的使用。 DOM转jQuery相比较jQuery转化成DOM，开发中更多的情况是把一个DOM对象加工成jQuery对象。$(参数)是一个多功能的方法，通过传递不同的参数而产生不同的作用。 如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象 举个🌰： HTML代码 JavaScript代码 对象是一个数组合集(3个div元素)。通过$(div)方法转化成jQuery对象，通过调用jQuery对象中的first与css方法查找第一个元素并且改变其颜色。 jQuery选择器基本选择器 选择器 描述 注意 $(&#39;#id&#39;) 获取元素id id是唯一的，每个id值在一个页面中只能使用一次。 $(&#39;.class&#39;) 获取元素类名 将获取拥有这个类的元素合集 $(&#39;element&#39;) 获取元素html对象 将获取对应的元素合集 $(&#39;*&#39;) 全选择器 获取文档中所有的元素 层级选择器 选择器 描述 注意 $(&#39;parent &gt; child&#39;) 子选择器：选择所有指定parent元素中指定的child的直接子元素 $(&#39;ancestor descendant&#39;) 后代选择器：选择给定的祖先(ancestor)元素的所有后代(descendant)元素 一个元素的后代可能是子元素、孙子元素、曾孙元素等 $(&#39;prev + next&#39;) 相邻兄弟选择器：选择所有紧接在prev元素后的next元素 只用于选取相邻的元素 $(&#39;prev ~ siblings&#39;) 一般兄弟选择器：匹配prev元素之后的所有siblings（兄弟元素） 基本筛选选择器筛选选择器用:开头，用法与CSS中的伪元素相似，因此元素的某些属性也通过筛选器查找。 举个🌰：$(&#39;:checked&#39;)— 获取拥有checked属性的元素 选择器 描述 $(&#39;:first&#39;) 匹配第一个元素 $(&#39;:last&#39;) 匹配最后一个元素 $(&#39;:net(selector)&#39;) 过滤选择器，选择所有元素，同时去除给定的选择器(selector)元素 $(&#39;:eq(index)&#39;) 在匹配的集合中选择索引值为index的元素 $(&#39;:gt(index)&#39;) 选择匹配集合中所有大于给定index（索引值）的元素 $(&#39;:even&#39;) 选择索引值为偶数的元素，从0开始计数 $(&#39;:odd&#39;) 选择索引值为奇数的元素，从0开始计数 $(&#39;:lt(index)&#39;) 选择匹配集合中所有索引值小于给定index参数的元素 $(&#39;:header&#39;) 选择所有标题元素，像h1,h2,h3等 $(&#39;:lang(language)&#39;) 选择指定语言(language)的所有元素 $(&#39;:root&#39;) 选择该文档的根元素 $(&#39;:animated&#39;) 选择所有正在执行动画效果的元素 内容筛选选择器 选择器 描述 $(&#39;:contains(text)&#39;) 选择所有包含指定文本(text)的元素 $(&#39;:parent&#39;) 选择所有含有子元素或者文本的元素 $(&#39;:empty&#39;) 选择所有没有子元素的元素（包含文本节点） $(&#39;:has(selector)&#39;) 选择元素中至少包含指定选择器的元素 可见性筛选选择器 选择器 描述 $(&#39;:visible&#39;) 选择所有显示的元素 $(&#39;:hidden&#39;) 选择所有隐藏的元素 :hidden选择器，不仅仅包含样式是display=&quot;none&quot;的元素，还包括隐藏表单、visibility等等。 说白了，如果元素占据文档中一定的空间，元素就被认为是可见的，否则就是隐藏元素。 有几种方式可以不显示一个元素： CSSdisplay的值是none type=&quot;hidden&quot;的表单元素 宽度和高度都显式设置为0 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSSvisibility的值是hidden CSSopacity的值是0 但元素的visibility:hidden或opacity:0被认为是可见的，因为仍然占用空间布局。 属性筛选选择器属性选择器让你可以基于属性来定位一个元素。 可以只指定该元素的某个属性，这样所有使用该属性的元素都将被定位。 选择器 描述 注意 `$(“[attribute =’value’]”)` 选择指定属性值等于给定字符串或**以该文字串为前缀(该字符串后跟一个连字符”-“)**的元素 $(&quot;[attribute*=&#39;value&#39;]&quot;) 选择指定属性包含一个给定的子字符串的元素(给定的属性包含某些值) 最实用 $(&quot;[attribute~=&#39;value&#39;]&quot;) 选择指定属性 用空格分隔的值中 包含一个给定值的元素 $(&quot;[attribute=&#39;value&#39;]&quot;) 选择指定属性是给定值的元素 $(&quot;[attribute!=&#39;value&#39;]&quot;) 选择不存在指定属性，或指定的属性值不等于给定值的元素 $(&quot;[attribute^=&#39;value&#39;]&quot;) 选择指定属性是以给定字符串开始的元素 $(&quot;[attribute$=&#39;value&#39;]&quot;) 选择指定属性是以给定值结尾的元素 这个比较区分大小写 $(&quot;[attribute]&quot;) 选择所有具有指定属性的元素，该属性可以是任何值 最实用 $(&quot;[attributeFilter1][attributeFilterN]&quot;) 选择匹配所有指定的属性筛选器的元素 笔记： [att=val]、[att]、[att|=val]、[att~=val] 属于CSS 2.1规范 [ns|attr]、[att^=val]、[att*=val]、[att$=val] 属于CSS3规范 [name!=&quot;value&quot;] 属于jQuery扩展的选择器 [attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等 [attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件 子元素筛选选择器"},{"title":"C#中?、??与?:的使用","date":"2020-11-14T16:00:00.000Z","url":"/blogs/2020/11/15/CSharp%20QuestionMarks/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["C#","/blogs/categories/C/"]],"content":"今天研究别人的轮子，遇到了很有趣的代码。 研究了一下，决定记录并整理下类似符号的用法。 可空类型修饰符（?）被?修饰的变量类型可以是空值null 空合并运算符(??)用于定义可空类型和引用类型的默认值。 如果此运算符的左操作数不为null，则此运算符将返回左操作数，否则返回右操作数。 例如：a ?? b，当a=null时返回b，a!=null时则返回a本身。 三元（运算符）表达式（?:)x?y:z表示如果表达式x为true，则返回y；如果x为false，则返回z，是省略if{}else{}的简单形式。 举个🌰一般这些符号的使用有助于提高代码的健壮性。 比如：在不报异常的情况下，取为null的List集合的个数 "},{"title":"C# 移位操作符\"<<\" & \">>\"","date":"2020-11-13T16:00:00.000Z","url":"/blogs/2020/11/14/CSharp%20Operator/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["C#","/blogs/categories/C/"]],"content":"移位操作符是将二进制数据进行的操作 左移操作符(&lt;&lt;)举个🌰，十进制数2转化成二进制数是10，若将2的二进制数左移1个操作符，即：$$\\begin{split}2 &lt;&lt; 1 &amp;=&gt; 10_{(2)} &lt;&lt; 1\\\\&amp;=100_{(2)}\\\\&amp;=4\\end{split}$$ 将第一个操作数向左移动第二个操作数指定的位数，空出的位置补0。左移相当于乘。左移1位相当于乘2；左移2位相当于乘4；左移3位相当于乘8……左移n位相当于乘$2^n$ 右移操作符(&gt;&gt;)右移位运算符（&gt;&gt;）是把数向右移位，所有的位都向右移动指定的次数$$\\begin{split}4 &gt;&gt; 1 &amp;=&gt; 100_{(2)} &gt;&gt; 1\\\\&amp;=10_{(2)}\\\\&amp;=2\\end{split}$$右移相当于除。右移1位相当于除2；右移2位相当于除以4；右移3位相当于除以8……右移n位相当于除以$2^n$，然后取其整数。 变量的赋值移位运算可简写： "},{"title":"Unity 使用Mirror框架制作多人游戏","date":"2020-10-20T16:00:00.000Z","url":"/blogs/2020/10/21/Unity%20Mirror/","tags":[["游戏编程","/blogs/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"],["游戏引擎","/blogs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"],["C#","/blogs/tags/C/"]],"categories":[["Unity","/blogs/categories/Unity/"],["游戏","/blogs/categories/%E6%B8%B8%E6%88%8F/"]],"content":"Mirror入门 Mirror是uMMORPG、vival和Cubica的开发人员为MMO规模的网络而构建和测试的。Mirror使联网变得容易，简洁和可维护。使用少于6000行代码即可实现uMMORPG。我们只需要一个网络库来启动我们的游戏就可以了。 准备工作 Unity Assets Store内下载Mirror，导入后重启Unity 确保游戏版本基于.NET Framework 4.x 以上 基本网络环境的建立在游戏场景内添加空物体，名为Network Manager，挂载以下脚本 Network Manager - 游戏网络管理组件 Network Info Network Address：服务器的ip地址，主机上的运行默认为localhost。 Max Connections：连接到服务器的最大客户端数量，即最大玩家数。 Spawn Info Player Prefab：作为玩家代表的角色产生的预制体 Auto Create Player：玩家进入游戏场景时是否自动产生预制角色 Registered Spawnable Prefabs：可生成的预制体列表。在游戏场景中临时产生的物体，如子弹等模型，都需要作为预制体注册进这个列表 Network Manager HUD LAN Host：作为服务器，同时作为客户端登陆游戏场景。 LAN Client IP：仅作为客户端连接到指定IP地址的游戏场景。 LAN Server Only：仅作为服务器创建场景，不产生玩家。 创建一个简单服务器一个多人游戏是如何构成的呢？多人游戏就是多个玩家在同一个游戏世界里，每个玩家都有自己的客户端进入这个世界。 那么首先就需要一个提供多个客户端数据传输的载体，也就是服务器。玩家通过客户端对服务器发起请求，最终在同一个游戏世界相遇。 先造个玩家吧作为入门的部分，我们以最简单的方式表达玩家。创建一个Cube，对其挂载一个简单的移动脚本，让它在X，Y轴上在(4,4)到(-4,-4)之间取随机位置。 接着把挂载完成的游戏对象保存为预制体(Prefabs) 将预制体赋予Network Manager脚本中的Player Prefab属性，并勾选Auto Create Player选项。 脚本需要做的更改： using Mirror 脚本继承类改为NetworkBehaviour（继承自MonoBehaviour） 玩家预制体内需要的脚本： NetworkIdentity：该组件是网络的核心，由服务器Spwan(卵生)的物体都必须具备,该组件在卵生的时候会自动分配assetID和权限。 ServerOnly勾选后物体只在服务器中存在 Local Player Authority勾选后在客户端中存在 运行游戏在编辑器内尝试运行游戏，会看到HUD的UI界面 点击LAN Host，场景内就会出现一个立方体，代表一个Player进入了该服务器 模拟多客户端效果在引擎菜单选择建立并运行(Build And Run)，点击LAN Host创建服务器，同时在引擎中运行游戏，相当于两个客户端在同时运行。在引擎中选择LAN Client，此时两个游戏端口都出现了两个立方体，若关闭作为服务器的端口，玩家们被踢出，游戏场景会被清空。 服务器内玩家的移动将预制物体挂载Network Transform组件 Compress Rotation用于控制服务器对于物体旋转的字节压缩，也可以选择无旋转 Network Sync Mode用于控制服务器同步模式，默认是Observes观察者，每个人都将在网络中获得同步；或者选择Owner所有者，只有拥有玩家的端口获得网络同步。 Client Authority：客户端玩家是否获得服务器授权。若要在客户端控制角色并同步到服务器，需要勾选此项。 Network Sync Interval：用于控制服务器的同步间隔 多人游戏中玩家的移动控制举个🌰以下脚本实现了双人乒乓球的球拍移动，并同步至服务器 与服务器的同步常用特征 [SyncVar] 用于标识序列化变量，实现同步数据 例: (把Hp标识,就可以实现同步减血) 这种特性的数据的修改只能从服务端修改，客户端是没有权限修改的，只能读取。要怎么修改呢？要通过有[ServerCallBack]，[Server]的方法 [Server] 方法直接在服务器执行 [ServerCallback] 表示服务器执行的回调，在服务端做判断调用。 比如子弹中的碰撞：OnTriggerEnter()，在前面加一个[ServerCallBack]的特性，这个判定则在服务端判定，相当于告诉服务器，要是撞到了就调用这个方法。 [Client] 表示只能在客户端调用 [ClientCallBack] 表示客户端执行的回调，在客户端做判断调用。 [Command] 函数名以Cmd开头 表示客户端向服务端发送的命令，在服务端执行 比如客户端角色想要发射子弹，发送命令到服务器，服务端内的玩家角色发射子弹。 [ClientPrc] 函数名以Rpc开头 表示服务端向客户端发送的命令，在客户端执行 比如物体碰撞产生的声音，服务端向客户端发送播放碰撞声音的命令，所有客户端都播放声音。 [TargetRpc] 函数名以Rpc开头 表示服务端向符合条件的指定客户端发送的命令，在客户端执行 比如玩家的得分条件，玩家击杀敌人，服务器会给这些客户端发送一个“你该得分了”的信号。 举些🌰角色外观在服务器中，每个玩家都有自己独特的外观，为了实现不同玩家不同颜色，通常会想到随机的材质颜色。 但在服务器上，每个端口看到的随机颜色都是不一样的，这是因为随机的数据只在本机上计算，颜色数据与服务器没有产生关联。 改造一下脚本，将颜色定义为同步变量，在加入服务器时进行随机： 发射子弹"},{"title":"Unity StartCoroutine 与 yield return 深入研究","date":"2020-10-18T16:00:00.000Z","url":"/blogs/2020/10/19/Unity%20StartCoroutine/","tags":[["游戏编程","/blogs/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"],["游戏引擎","/blogs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"],["C#","/blogs/tags/C/"]],"categories":[["Unity","/blogs/categories/Unity/"],["游戏","/blogs/categories/%E6%B8%B8%E6%88%8F/"]],"content":"初次见面字面意思很好理解，StartCoroutine就是开启一个协程，yield return是迭代器块返回调用迭代的地方。 先看一下Unity官方的解释 MonoBehaviour.StartCoroutine Coroutine StartCoroutine(lEnumerator routine); Starts a coroutine. The execution of a coroutine can be paused at any point using the yield statement. The yield return value specifies when the coroutine is resumed. Coroutines are excellent when modelling behaviour over several frames. Coroutines have virtually no performance overhead. StartCoroutine function always returns immediately, however you can yield the result. This will wait until the coroutine has finished execution. 翻译: 一个协程的执行可以在任何地方用yield语句来暂停，yield return的值决定了什么时候协程恢复执行。协程在协调在几帧中执行的操作时有极大的用处.协程几乎没有任何性能开销。StartCoroutine一般都会立即返回，然而你也可以获得返回结果的值。但是这一步会等到协程结束执行才能生效。 根据这个意思，我们来举个🌰 运行结果： start1 test1 start2 test2 当StartCoroutine刚调用的时候，可以理解为正常的函数调用，然后接着看调用的函数里面。 当被调用函数执行到yield return null；（暂停协程，等待下一帧继续执行）时，根据解释，协同程序会被暂停，先返回开始协程的地方，然后再暂停协程。也就是先通知调用处，“你先走吧，不用管我”，然后再暂停协程。 再来个🌰验证一下。 运行结果： start1 test1 start2 test2（三秒后显示） 验证了 “yield return的值决定了什么时候协程恢复执行” 这个特点。 食用指南启动协同程序协同程序有不同的启动方式： StartCoroutine(IEnumerator routine); 优点：灵活，性能开销小。 缺点：无法单独的停止这个协程，如果需要停止这个协程只能等待协同程序运行完毕或则使用StopAllCoroutine();方法。 StartCoroutine (methodName:string, value : object = null); 优点：可以直接通过传入协同程序的方法名来停止这个协程：StopCoroutine(&quot;string methodName&quot;);(注意双引号) 缺点：性能的开销较大，只能传递一个参数。 停止协同程序1、StopCoroutine(string methodName); 2、StopAllCoroutine(); 3、设置gameObject的active为false时可以终止协同程序，但是再次设置为true后协程不会再启动。 协同程序的执行顺序开始协同程序 -&gt; 执行协同程序 -&gt; 中断协同程序（中断指令）-&gt; 返回上层继续执行 -&gt; 中断指令结束后，继续执行协同程序剩下的内容 协同程序的注意事项 不能在Update()或者FixUpdate()方法中使用协同程序，否则会报错。 关于中断指令：YieldInstruction，一个协程收到中断指令后暂停执行，返回上层执行同时等待这个指令达成后继续执行。 协程中断指令 指令 描述 实现 WaitForSeconds 等待指定秒数 yield return new WaitForSeconds(2); WaitForFixedUpdate 等待一个固定帧 yield return new WaitForFixedUpdate(); WaitForEndOfFrame 等待帧结束 yield return new WaitForEndOfFrame(); StartCoroutine 等待一个新协程结束 yield return StartCoroutine(other coroutine); "},{"title":"Node.JS 创建本地服务器并显示html页面","date":"2020-10-16T16:00:00.000Z","url":"/blogs/2020/10/17/NodeJS%20Server/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"],["前端","/blogs/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["JavaScript","/blogs/categories/JavaScript/"],["Node","/blogs/categories/Node/"]],"content":" 前瞻阅读：Node.JS大峡谷 准备工作html页面得先有吧？不解释了吼~ 准备一个index.js，跟index.html放在同一目录下。 导入需要用到的node自带模块 这里index.html和index.js都放在一个目录(项目名/html)下的，属于同级。 创建服务器 先来个简单版本 不出意外的话，运行脚本就可以访问了 比较常用的版本 createServer方法创建一个sever，每次请求从request拿到url，解析后找到对应文件，获取成功后写入response；失败则发送404. "},{"title":"Unity Animator-让角色躁起来","date":"2020-10-05T16:00:00.000Z","url":"/blogs/2020/10/06/Unity%20Animator/","tags":[["游戏编程","/blogs/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"],["游戏引擎","/blogs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"],["C#","/blogs/tags/C/"]],"categories":[["Unity","/blogs/categories/Unity/"],["游戏","/blogs/categories/%E6%B8%B8%E6%88%8F/"]],"content":"整一个角色​ 准备工作阶段要先明确，自己要什么样的角色，作为建模渣渣的我怎么满足自己的需求。我想我需要一个会唱跳Rap……会走路、奔跑、跳跃的角色，这样至少看起来是个活的东西，当然更希望长得好看一点。 ​ 走路、奔跑、跳跃这些功能并不是难事，这些甚至不用自己实现，只需要导入Character Controller（角色控制器），里面就已经具备了角色所需的所有控制脚本了，关键是这个控制器原本的样子，要么是机器人果体，要么是个胶囊体。丑八怪咿呀咿呀能否别把灯打开？ ​ 好吧，我决定功能和外观我全都要。既然功能完善，换个皮不就好了？找一个控制器，再来个萌萌哒的Q版模型，先导入进来再说。 左边的是控制器，拥有完整的移动等控制脚本，也有走路，奔跑，跳跃等基本的模型动画。 右边的是可爱的Unity娘，有走路，奔跑，跳跃、拿不同武器时的模型动画，但没有控制脚本。 材料就绪，可以开始拼凑了，从这一步开始势必要破坏原来的模型结构，但有什么关系呢，反正还能再导入嘛。 在开始之前切记，要先重置模型的位置信息，让它们位置重合，这样替换后能省去调整位置的麻烦。 仔细看一下角色模型的结构，其实模型作者还是分得挺清楚的，看不明白的话也有个保险方法，点击物体列表左边的眼睛隐藏当前组件，看看外观是否变化。 把机器人模型显示的部分全部删掉就好了，再把Q版人物底下的零件拖到机器人底下，替换完成。 但要注意，替换完模型要记得修改碰撞箱的大小，毕竟机器人要高出整整半个身子。最后养成好习惯，把修改后的结果保存为新的Prefab（预制体）。 试着运行一下看看，不出意外的话我们就得到了一个没有动作但是可以操作的萌萌哒角色。我们实现了基本的控制效果，接下来要将它与动作产生关联。 角色状态的建立大部分情况下，当游戏内玩家没有任何操作时，肯定都是站立不动的状态，但事实上，玩家不可能和木头人一样完全静止，这样显得非常不真实，给玩家带来的体验当然也会很差。所以基本上所有有角色的游戏（纯2D游戏除外），角色的站立状态也都是有专门的动画的。 角色模型的绑定首先角色在没有操作的状态下，应该有自己的站立姿势，把站立状态作为角色的默认动画也很合理。还记得我们的角色是建立在合格的控制器与合格的外观上的，控制器早已具备角色动画的属性，只不过原先的对象被我们删除了，只需要替换掉丢失的原件，找到模型原先的的预制体赋予Animator/Avatar 每个模型都有量身定制的骨骼、体态等，这一步只是告诉动画组件，我要调教的是这个模型。 或许你已经看到了，这个属性上面的Controller组件是空白或者丢失的状态，接下来的才是重点。 状态机的建立在自己的工程内新建一个文件夹，我的叫Animator Controllers，用来存放我需要的动画状态机。 在文件夹内右键新建Animator Controller组件，双击打开后是这个样子。 我们在这里面来实现角色的状态以及动画混合 Entry表示角色刚启动时触发的状态 Exit表示状态机的结束状态，与Entry形成闭环，即结束状态后会立即进入Entry状态 Any State表示任意状态下，即表示模型任意时刻下的状态。说白了，**AnyState相当于是动画池，不管你当前的状态，我要你现在干什么，你就立刻去干什么** 先来个最简单的，为角色建立一个站立的状态。右键点击Create State/Empty，然后会发现Entry默认自动连接上了这个状态，这是因为Unity默认把第一个状态视为主要状态。我把它取个名字叫Stand，选中这个状态以后查看它的属性面板。 其中第一个Motion属性就是用来绑定我们的模型动画的，我选择一个站姿的动画。 创建状态这一步也可以先找到想要的动画文件直接拖进状态面板（推荐）。 记得回到之前的面板，把编辑好的Animation Controller组件赋予角色空缺的部分。 啊♂可爱，先开瓶养乐多庆祝一下，然后我们再继续加入其他状态。 动画过渡我们继续制作行走和奔跑两个角色动画，流程也大同小异了。 新建两个状态，并设置好对应动画 将这三个状态相互连接起来，右键状态点击Make Transition创建出连线，可以看出这条线是有向的 这张图的含义就是：如果当前玩家在站立状态，当条件满足XXX时，就可以过渡到前进状态，只不过当前的Conditions（条件）是无，也就是站立动画会自动播放到行走。 我们在左侧面板来创建动画的切换条件 Float：浮点类型参数，很少用 Int：整型参数，例如设置Speed参数，当其为0时切换到站立动画，为1时触发走路动画，为2时触发跑步动画 Bool：bool类型参数 Trigger：触发器，相当于某一瞬间的条件，如物体碰撞、按钮按下等，受到触发后动画转换，很常用（特别是后面提到的AnyState） 设置触发条件，比如当玩家按下方向键进行移动时，动画由站立转为行走 连线绑定条件 Has Exit Time：当动画播放完毕时，才播放下一个动画。勾选之后动画会强制播放完毕才转到下一个状态，哪怕是下面的条件触发。这里需要按下按键后立刻改变状态，所以每个状态都去掉勾选。 Settings：动画过渡设置，例如玩家从攻击状态转为防御状态，这个过程既可以是平滑缓慢的，也可以是瞬间的，很难讲清楚具体设置方法，建议自己调调看，一般来讲中间的蓝色范围越短动画转化的越迅速。 Conditions：触发状态切换条件（或运算） Solo/Mute：一般用于调试，Solo为当父状态有多条连线满足条件时，优先走这条，Mute是禁用。 按照我的想法，按下方向键时角色进入行走状态（Speed=1），切无论角色是站立（Speed=0）还是行走（Speed=1），只要按下Shift键，角色直接进入奔跑状态（Speed=2），因此只需要设置一个Speed判断条件。最后用代码进行衔接。 代码控制Animator Animator.SetInteger(&quot;参数名&quot;, 值)：修改整型参数 Animator.SetFloat(&quot;参数名&quot;, 值)：修改浮点参数 Animator.SetBool(&quot;参数名&quot;, true/false)：修改Bool参数 Animator.SetTrigger(&quot;参数名&quot;, true/false)：触发器触发 大功告成，Enjoy！"},{"title":"修心体验","date":"2020-10-04T16:00:00.000Z","url":"/blogs/2020/10/05/20201005/","tags":[["生活","/blogs/tags/%E7%94%9F%E6%B4%BB/"]],"categories":[["碎碎念","/blogs/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"]],"content":"​ 前段时间意识到自己脾气越来越“不耐受”，一些朋友不太恰当的玩笑话容易惹到我。说实话，像给人贴标签，若扭曲解读对方的话这类的行为也算是玩笑的话，那么这或许确实能惹到大部分人。秉着尊重他人的原则（虽然自己没有被尊重到，只是不想计较罢了），我决定找些方法来控制自己的情绪。 ​ 最近在看的一本书叫《修心三不》。这本书或许带点洗脑的性质在里面，能引导我从心态上去克服情绪积压的毛病。有一些观点还是挺有用的： 痛苦的人不过是养成了愤怒的习惯，他们总是对生活中的事务报以消极的态度，他们不相信他人，对社会环境和自然环境不满，觉得公司的同事难以相处。 当你的粗鲁与你所处地位不符时，人们就会对你进行反击。 “大事清楚，小事糊涂”，对一些原则性的问题要清楚，处理要有原则，而对生活中的无原则性的、不中听、看不惯的错事、小事，不能认真计较，更不要往心里去，甚至对吃了亏该生气的事，也一笑了之。 制怒，是克制在人与人正常交往中所不应发之怒，以及在大是大非面前保持冷静的头脑，做出理智判断的处理方法。 ​ 虽然还没有看完，但是已经给了我一定的启发，“大事清楚，小事糊涂”这种态度，在我自己身上也有了新的定义：温柔且坚定。"},{"title":"Unity中的\"常规操作\"","date":"2020-10-02T16:00:00.000Z","url":"/blogs/2020/10/03/Unity/","tags":[["游戏编程","/blogs/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"],["游戏引擎","/blogs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"],["C#","/blogs/tags/C/"]],"categories":[["Unity","/blogs/categories/Unity/"],["游戏","/blogs/categories/%E6%B8%B8%E6%88%8F/"]],"content":"总觉得要屯点什么🌰才开心逆透视变换 将鼠标的屏幕二维坐标转换成三维投射坐标 学以致用UI控制摇杆 UI的层级结构（对象名 - [类型]描述）： Canvas - [Canvas]UI根对象 Joystick - [Image]摇杆的可触控范围 Background - [Image]摇杆背景 Handle - [Image]摇杆对象 DirectionArrow - [Image]背景外围的方向箭头 EnumFlagsAttribute.cs Joystick.cs DirectionArrow.cs 简单跳跃模块 Player.cs 鼠标控制以物体为中心的自由视角 freeView.cs QE键控制以物体为中心的环绕视角 QERotation.cs 查找最近的敌人 查找hp最小的敌人 Enemy.cs FindEnemyDemo.cs "},{"title":"Node.JS大峡谷","date":"2020-09-23T16:00:00.000Z","url":"/blogs/2020/09/24/NodeJS/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"],["前端","/blogs/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["JavaScript","/blogs/categories/JavaScript/"],["Node","/blogs/categories/Node/"]],"content":"NodeJS与JavaScript的一些区别 顶层对象 JavaScript：window NodeJS：global 模块(modules) 在node中，文件和模块是一一对应的，一个文件即一个模块，我们通常会把实现同一类功能的代码写在同一个文件里面。 每个模块都有自己的作用域，比如变量、exports属性等，因此访问其他模块的内容就得先调用模块。 可以将数据结构大致整理为: $$\\begin{split} 项目\\begin{cases} 模块1\\begin{cases} module.exports\\\\ 变量\\\\ 函数\\\\ … \\end{cases}\\\\ 模块2\\begin{cases} module.exports\\\\ 变量\\\\ 函数\\\\ … \\end{cases}\\\\ … \\end{cases}\\end{split}$$ 我们通过var申明的变量并非全局，而是该模块作用域下的，更建议使用let 模块调用(require) 路径的写法： 模块路径可以是一个以/开头，表示一个绝对路径 模块路径以./开头，表示当前目录下的相对路径 模块路径如果没有以/或者./开头，那么这个模块要么是核心模块要么是node_ modules文件夹下的 注意是./和没有./或/开头的路径，和我们常理上的使用结果是不一样的 模块加载机制：如果按照文件名顺序依次查找，若没有找到，则报错filename &gt; filename.js &gt; filename.json &gt; filename.node &gt; Error 模块数据(exports) module 在Node中，每一个模块都有自己的作用域，同时还有一个module的变量，代表了对当前模块的引用，但module并不是全局对象，并且每个模块都有白己的独立的module对象 module.id module.fileName module.diyName 这些并不是固定关键字，类似模块本身的属性定义，属性名是自定义的 module.exports exports === module.exports 外部模块通过require()方法加载模块，该函数返回的就是被加载模块的module.exports对象 我们可以通过module.exports或者exports对外提供模块内部变量的访问 需要注意的是，最好不要直接覆盖exports或者module.exports，比如exports=1 ,module.exports=1，这样做会破坏exports和module .exports的引用关系。 举个🌰通常我们会在项目里配置一些信息，这些都写在config.js中，配置后的信息可以赋予exports供其他模块调用 config.js： 在其他模块中调用（这里假设模块文件都在同一路径目录下） global对象 _filename属性 返回当前执行的文件的文件路径，该路径是经过解析后的绝对路径，在模块中，该路径是模块文件的路径，此属性并非全局属性，而是模块的 _dirname属性 返回当前执行脚本文件所在目录的路径，该属性也是模块的，而非全局 setTimeout(cb, ms) clearTimeout(t) setInterval(cb, ms) clearlnterval(t) process对象 process对象是一个全局对象，可以在任何地方都能访问到他，通过这个对象提供的属性和方法，使我们可以对当前运行的程序的进程进行访问和控制 属性 描述 argv Array，一组包含命令行参数的数组 execPath 开启当前进程的绝对路径 env 返回用户环境信息 version 返回node版本信息 versions 返回node以及node依赖包版本信息 pid 当前进程的pid title 当前进程的显示名称(Getter/Setter) arch 返回当前CPU处理器架构(arm/ia32/x64) platform 返回当前操作系统平台 cwd() 返回当前进程的工作目录 chdir(directory) 改变当前进程的工作目录 memoryUsage() 返回node进程的内存使用情况，单位是byte exit(code) 退出 kil(pid) 向进程发送信息 stdin 标准输入流 stdout 标准输出流 Buffer类 一个用于更好的操作二进制数据的类 我们在操作文件或者网络数据的时候，其实操作的就是二进制数据流，Node为我们提供了一个更加方便的去操作这种数据流的类Buffer，是一个全局的类 属性 描述 buf.length buffer的bytes大小 buf[index] 获取或者设置在指定index索引位置的8位字节内容 buf.write(string, [offset]; [length], [encoding]) 根据参数offset偏移量和指定的encoding编码方式，将参数string数据写入buffer buf.toString([encoding], [start], [end]) 根据encoding参数(默认是’utf8’)返回一个解码的string类型 buf.toJSON() 返回一个JSON表示的Buffer实例。JSON.stringify将会默认调用来字符串序列化这个Buffer实例 buf.slice([start], [end]) 返回一个新的buffer,这个buffer将会和老的buffer引用相同的内存地址，注意:修改这个新的buffer实例slice切片，也会改变原来的buffer buf.copy(targetBuffer, [targetStart], [sourceStart],[sourceEnd]) 进行buffer的拷贝 Buffer.isEncoding(encoding) 如果给定的编码encoding是有效的，返回true，否则返回false Buffer.isBuffer(obj) 测试这个obj是否是一个Buffer Buffer.byteLength(string, [encoding]) 将会返回这个字符串真实byte长度。encoding编码默认是: ‘utf8’ Buffer.concat(list, [totalLength]) 返回一个保存着将传入buffer数组中所有buffer对象拼接在一起的buffer对象 arguments对象 非箭头函数： 箭头函数： arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 例如，如果一个函数传递了三个参数，你可以以如下方式引用他们： 参数也可以被设置： 举几个🌰遍历参数求和 定义连接字符串的函数这个例子定义了一个函数来连接字符串。 这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。 该函数定义如下： 你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。 定义创建HTML列表的方法这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 “u“ 时，创建一个无序列表 (项目列表)；当该参数为 “o“ 时，则创建一个有序列表 (编号列表)。 该函数定义如下： 你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。 例如： 文件系统(File System)该模块是核心模块，需要使用require导入后使用 该模块提供了操作文件的一些API 方法 描述 fs.open(path, flags, [mode], callback) 异步地打开一个文件 fs.openSync(path, flags, [mode]) fs.open()的同步版 fs.read(fd, buffer, offset, length, position, callback) 从指定的文档标识符fd读取文件数据 fs.readSync(fd, buffer, offset, length, position) fs.read函数的同步版本，返回bytesRead的个数 fs.write(fd, buffer, offset, length[, position], callback) 通过文件标识fd，向指定的文件中写入buffer fs.write(fd, data[, position[, encoding]], callback) 把data写 入到文档中通过指定的fd,如果data不是buffer对象的实例，则会把值强制转化成一个字符串。 fs.writeSync(fd, buffer, offset, length[, position]) fs.write()的同步版本 fs.writeSync(fd, data[, position[, encoding]) fs.write()的同步版 fs.close(fd, callback) 关闭一个打开的文件 fs.closeSync(fd) fs.close()的同步版本 fs.writeFlie(ilename, data, [options], callback) 异步的将数据写入一个文件,如果文件不存在则新建,如果文件原先存在，会被替换。data可以是一个string，也可以是一个原生buffer。 fs.writeFileSync(filename, data, [options]) fs.writeFile的同步版本。注意：没有callback，也不需要 fs.appendFile(filename, data, [options], callback) 异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新的文件。data可以是一个string，也可以是原生buffer。 fs.appendFileSync(filename, data, [options]) fs.appendFile的同步版本 fs.readFile(filename, [options], callback) 异步读取一个文件的全部内容 fs.readFileSync(filename, [options]) fs.readFile的同步版本 fs.exists(path, calback) 检查指定路径的文件或者目录是否存在 fs.existsSync(path) fs.exists的同步版本 fs.unlink(path, callback) 删除一个文件 fs.unlinkSync(path) fs.unlink的同步版本 fs.rename(oldPath, newPath, callback) 重命名 fs.renameSync(oldPath, newPath) fs.rename()的同步版本 fs.stat(path, callback) 读取文件信息 fs.statSync(path, callback) fs.stat的同步版本 fs.watch(filename, [options], [listener]) 观察指定路径的改变，filename 路径可以是文件或者目录 fs.mkdir(path, [mode], callback) 创建文件夹 fs.mkdirSync(path, [mode]) fs.mkdir的同步版本 fs.readdir(path, callback) 读取文件夹 fs.readdirSync(path) fs.readdir同步版本 fs.rmdir(path, callback) 删除文件夹 fs.rmdirSync(path) fs.rmdir的同步版本. http模块这个环节一般是建立在已经做好了一个网页，准备发布或者将要调试的前提下进行，那么在开始之前我们就要先了解网页的运作有哪些规则。 举个🌰： “网页”顾名思义，是基于网络进行运作的页面，那么计算机是如何与网页产生互动的？ 计算机访问网页，可以想象成查询字典的过程。 回想一下查询字典的流程：我们将某个字的部首或者偏旁信息提供给目录，通过目录找到对应的页数，最后在某页找到自己想要的字。 建立网页的原理正好相反：对于网络这本“字典”，我们要将自己创造的”某一页“塞入这本字典。 因此需要提供任何计算机都能够找到这一页的数据，比如是哪本字典“字典” — 主机名(hostname)、在哪一“页” — 端口号(port) 等等。 先来看一个简单案例： 计算机通过以上代码完成了这些事情： 发送一个http请求到指定主机（ip）。 服务器（server）接收请求（request）【即符合http协议的报文】，将报文进行拆解（提取信息）、处理。 服务器处理完之后，返回给客户端想要的数据（响应response）。 客户端（浏览器）接收到数据后，分析并处理 优先级：http.Server &lt; net.Server &lt; EventEmitter server.on事件 事件 描述 参数 listening 当server调用listen方法并成功开始监听以后触发的事件 error 当服务开启失败时触发的事件 err：具体的错误对象 request 当有客户端发送请求到该主机和端口的请求时触发 req：request对象，http.IncomingMessage的一个实例， 通过它我们可以获取到这次请求的一些信息：httpVersion：使用的http协议的版本headers：请求头信息中的数据url：请求的地址method：请求方式res：response对象，http.ServerResponse的一个实例，通过它我们可以向该次请求的客户端输出返回响应：write(chunk, [encoding])：发送一个数据块到响应正文中end([chunk], [encoding])：当所有的正文和头信息发送完成以后调用该方法告诉服务器数据已经全部发送完成了，这个方法在每次完成信息发送以后必须调用，并且是最后调用statusCode：该属性用来设置返回的状态码setHeader(name, value)：设置返回头信息writeHead(statusCode, [reasonPhrase], [headers])：这个方法只能在当前请求中使用一次，并且必须在response.end()之前调用 url模块使用fs模块实现nodejs代码和html的分离 根据不同的url进行处理，返回不一样的数据： url.parse(request.url) ：对url格式的字符串进行解析，返回一个对象 get请求的数据处理 post请求的数据处理 post发送的数据会被写入缓冲区中，需要通过resquest的data事件和end事件来进行数据拼接处理 querystring模块 parse()：将一个query string反序列化为一个对象 当一个网站准备发布时 需要考虑什么？ 源码的安全性 性能 如何进行优化？ 给代码瘦身：删除换行、制表符、注释…… 将代码“脏化” — 让读代码的人骂脏话：变量抽象化、语法重构（升级）、语句合并…… 代码合并方式有哪些？ 实时自动合并（fs.watch） 手动一次性合并 "},{"title":"JavaScript从入门到入土","date":"2020-09-08T16:00:00.000Z","url":"/blogs/2020/09/09/JavaScript/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["JavaScript","/blogs/categories/JavaScript/"]],"content":"数组二维数组定义方法： 事件主要事件表： 事件 说明 onclick 鼠标单击事件 onmouseover 鼠标经过事件 onmouseout 鼠标移开事件 onchange 文本框内容改变事件 onselect 文本框内容被选中事件 onfocus 光标聚焦 onblur 光标离开 onload 网页导入 onunload 关闭网页 内置对象日期对象定义一个时间对象 : 注意：使用关键字new，Date()的首字母必须大写。 使 Udate 成为日期对象，并且已有初始值：**当前时间(当前电脑系统时间)**。 如果要自定义初始值，可以用以下方法： 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;” 常用方法： 方法名 功能描述 get/setDate() 返回/设置日期 get/setFullYear() 返回/设置年份，用四位数表示 get/setYear() 返回/设置年份 get/setMonth() 返回/设置年份0:一月……11:十二月，所以+1 get/setHours() 返回/设置小时，24小时制 get/setMinutes() 返回/设置分钟数 get/setSeconds() 返回/设置秒钟数 get/setTime() 返回/设置时间（毫秒为单位） 字符串对象 方法名/语法 参数 功能描述 stringObject.length; 返回该字符串的长度 toUpperCase() 将字符串小写字母转换为大写 toLowerCase() 将字符串所有大写字母都变成小写的字符串 stringObject.charAt(index) Index：必需。表示宇符串中某个位置的数字，即字符在字符串中的下标 返回指定位置的字符。返回的字符是长度为 1 的字符串 stringObject.indexOf(substring, startpos) substring：必需。规定需检索的字符串值startpos：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是0到 stringobject length-1●如省暗该参数，则将从字符串的首字符开始检索。 返回某个指定的字符串值在字符串中首次出现的位置 stringObject.split(separator,limit) separator：必需。从该参数指定的地方分割 stringObjectlimit：可选参数，分割的次数，如设置该参数，返回的子串不会多于这个参数指定的数组，如果无此参数为不限制次数 将字符串分割为字符串数组，并返回此数组 stringObject.substring(startPos,stopPos) startPos：必需。一个非负的整数，开始位置。stopPos：可选。一个非负的整数，结束位置，如果省略该参数，那么返回的子串会一直到字符串对象的结尾。 用于提取字符串中介于两个指定下标之间的字符 stringObject.substr(startPos,length) startPos：必需。要提取的子串的起始位置。必须是数值。length：可选。提取字符串的长度。如果省略，返回从stringObject的开始位置startPos到 stringObject的结尾的字符 从字符串中提取从 startPos位置开始的指定数目的字符串。 Math对象Math 对象属性： 属性 说明 E 返回算术常里e，即自然对数的底数（约等于2.718） LN2 返回2的自然对数（约等于0.693） Ln10 返回10的自然对数（约等于2.302） LOG2E 返回以2为底的e的对数（约等于1.442） LOH10E 返回以10为底的e的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回2的平方根的倒数（约等于0.707） SQRT2 返回2的平方根（约等于1.414） Math 对象方法： 方法 描述 abs(x) 返回数的绝对值 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 返回数字的反正切值 atan2(y,x) 返回由x轴到点（x,y）的角度（以弧度为单位） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回e的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回x和y中的最高值 min(x,y) 返回x和y中的最低值 pow(x,y) 返回x的y次幂 random() 返回0~1之间的随机数 round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 toSource() 返回该对象的源代码 valueOf() 返回Math对象的原始值 数组对象 方法 描述 示例 示例结果 concat() 连接两个或更多的数组，并返回结果 var myarr1 = new Array(“1”);var myarr2 = new Array(“2”,”3”);document.write(myarr1.concat(myarr2)) 1,2,3 join() 把数组的所有元素放入一个字符串元素通过指定的分隔符进行分隔 var myarr1 = new Array(“1”);var myarr2 = new Array(“2”,”3”);var myarr3 = myarr1.concat(myarr2);document.write(myarr3.join(“-”)); 1-2-3 pop() 刪除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reserve() 颠倒数组中元素的顺序 var myarr1 = new Array(“我”,”爱”,”你”);document.write(myarr1.reverse()); 你,爱,我 shift() 删除并返回组的第一个元素 slice() 从某个已有的数组返回选定的元素 var myarr1 = new Array(“我”,”爱”,”你”);document.write(myarr1.slice(2)); 爱,你 sort() 对数组的元素进行排序 function sortNum(a,b) { return a - b; }//升序，如降序，把“a - b”该成“b - a” var myarr = new Array(“80”,”16”,”50”,”6”,”100”,”1”);document.write(myarr.sort()+“\\&lt;br\\&gt;”); document.write(myarr.sort(sortNum)); 1,100,16,50,6,801,6,16,50,80,100 splice() 删除元素，并向数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串，并返回结果 toLocalString() 把数组转换为本地数组，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值 window对象 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 close() 关闭浏览器窗口 print() 打印当前窗口的内容 focus() 把键盘焦点给予一个窗口 blur() 把键盘焦点从顶层窗口移开 moveBy() 可相对窗口的当前坐标把它移动指定的像素 moveTo() 把窗口的左上角移动到一个指定的坐标 resizeBy() 按照指定的像素调整窗口的大小 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素值来滚动内容 sciolTo() 把内容滚动到指定的坐标 setInterval() 每隔指定的时间执行代码 setTimeout() 在指定的延迟时间之后来执行代码 clearInterval() 取消setInterval()的设置 clearTimeout() 取消setTimeout()的设置 计时器 方法 说明 setTimeout() 指定的延迟时间之后来执行代码 clearTimeout() 取消setTimeout()设置 setInterval() 每隔指定的时间执行代码 clearInterval() 取消setInterval()设置 history 对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 属性 描述 length 返回浏览器历史列表中的URL数量 方法 描述 back() 加载history列表中的前-一个URL forward() 加载history列表中的下一个URL go(number) 加载history列表中的某个具体的页面 location对象 属性 描述 hash 设置或返回从井号(#)开始的URL (锚) host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完整的URL pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或返回从问号(?)开始的URL (查询部分) 方法 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 navigator对象 属性 描述 appCodeName 浏览器代码名的字符串表示 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent头部的值 几种浏览器的user_agent 浏览器 userAgent chrome Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/34.0.1847.116 Safari/537.36p firefox Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0 IE 8 Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0;SLCC2; .NETCLR2.0.50727;.NET CLR3.5.30729;.NET CLR3.0.30729; .NET4.0C) screen对象screen对象用于获取用户的屏幕信息。 语法： 属性 描述 availHeight 窗口可以使用的屏幕高度，单位像素 availWidthe 窗口可以使用的屏幕宽度，单位像素 colorDepth 用户浏览器表示的颜色位数，通常为32位(每像素的位数) pixelDepth 用户浏览器表示的颜色位数，通常为32位(每像素的位数)(IE不支持此属性) height 屏幕的高度，单位像素 width 屏幕的宽度，单位像素 DOM对象基础元素获取 方法 说明 获得 getElementByld 通过指定id获得元素 一个 getElementsByName 通过元素名称name属性获得元素 一组 getElementsByTagName 通过标签名称获得元素 一组 DOM节点 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点：向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点：元素属性，如&lt;a&gt;标签的链接属性href=&quot;;。 节点属性： 方法 说明 innerHTML 返回节点内容 nodeName 返回一个字符串，其内容是给定节点的名字 nodeType 返回一个整数，这个数值代表给定节点的类型 nodeValue 返回给定节点的当前值 遍历节点树: 方法 说明 childNodes 返回一个数组,这个数组由给定元素节点的子节点构成 firstChild 返回第一个子节点 lastChild 返回最后一个子节点 parentNode 返回一个给定节点的父节点 nextSibling 返回给定节点的下一个子节点 previousSibling 返回给定节点的上一个子节点 DOM操作: 方法 说明 createElement(element) 创建一个新的元素节点 createTextNode() 创建-一个包含着给定文本的新文本节点 appendChild() 指定节点的最后一个子节点列表之后添加一个新的子节点 insertBefore() 将一个给定节点插入到一个给定元素节点的给定子节点的前面 removeChild() 从一个给定元素中删除一个子节点 replaceChild() 把一个给定父元素里的一个子节点替换为另外一个节点 网页卷曲距离与偏移量"},{"title":"与数学的中门对（被）狙","date":"2020-08-28T16:00:00.000Z","url":"/blogs/2020/08/29/Math/","tags":[["算法","/blogs/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["数学","/blogs/categories/%E6%95%B0%E5%AD%A6/"]],"content":"辗转相除法 辗转相除法，是找到两个数字的最大公约数的算法。 它在公元前300年由欧几里得发现，被称为世界上最古老的算法。 实例引入 举一个例子，我们来考虑一下，1112和695的最大公约数。 用通常的方法，我们会把2个数字分解成素数，找出共同素数的最大公约数（GCD），即是我们要的答案。$$\\begin{cases}1112=139×2×2×2\\\\695=139×5\\end{cases}\\space\\space ,139···GCD$$但是这种方法，两个数字如果越大，素数分解就越困难。因此用辗转相除法，可以更有效地找到最大公约数。 在解释辗转相除法之前，先解释一下mod操作。此操作是获得除法余数的操作，$A\\space mod\\space B=C$，C就是A除以B后的余数 例如：$$\\begin{split}6\\space mod\\space 3=0\\\\7\\space mod\\space 3=1\\\\8\\space mod\\space 3=2\\\\9\\space mod\\space 3=0\\end{split}$$ 算法实现在上面的例子中，用辗转相除法找到1112和695的最大公约数的步骤为： 找到较大的数字，除以较小的数字并得到余数417 $$1112\\space mod\\space 695=417$$ 下一轮，我们用之前较小的数除以得到的余数，得到新的余数$$\\begin{split}1112\\space mod\\space 695=417\\\\695\\space mod\\space 417=278\\end{split}$$ 重复同样的操作，直到余数取得为0 $$\\begin{split}1112\\space mod\\space 695&amp;=417\\\\695\\space mod\\space 417&amp;=278\\\\417\\space mod\\space 278&amp;=139\\\\278\\space mod\\space 139&amp;=0\\end{split}$$ 当余数为0时，最后一个操作的除数139就是1112和695的最大公约数。 此算法的优点在于，即便目标是2个庞大的数字，也可以通过固定的顺序找到最大公约数。 "},{"title":"RPG游戏/特效制作-硬核笔记","date":"2020-08-28T16:00:00.000Z","url":"/blogs/2020/08/29/UE4-RPG_effect/","tags":[["游戏编程","/blogs/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"],["游戏引擎","/blogs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"]],"categories":[["Unreal Engine","/blogs/categories/Unreal-Engine/"]],"content":"准备工作$准备工作\\begin{cases}角色导入\\begin{cases}模型\\\\动画\\\\贴图\\end{cases}\\\\UI\\begin{cases}血量\\\\法力值\\\\界面\\\\…\\end{cases}\\\\AI(Bot)\\begin{cases}扣血\\\\对象\\\\移动\\end{cases}\\end{cases}$ 处理素材文件 从Maya导出素材 修改世界坐标为Z轴朝上(UE4可忽略) window-Preferences-settings-Word Coordinate System 显示骨骼朝向，确保x轴为骨骼方向 增加武器插槽节点(fire position)在根骨骼下 该节点与根骨骼不能用来k动画 导出FBX文件 默认模型 模型动画（勾选Animation-Bake动画） 使用Marmoset Toolbag测试渲染模型 导入材质 导入动画 素材导入UE4 Character导入默认角色模型 Import Mesh/Skeletal 创建材质 导入贴图 新建材质球 贴图拖入材质球 颜色贴图-&gt;Base Color 法线贴图-&gt;Normal 高光贴图-&gt;Specular 材质球拖入模型 创建质感 金属质感：数字键1+左键单击-&gt;Metallic 反光质感：数字键1+左键单击-&gt;Roughness 导入动画 去勾选Mesh Skeleton选择骨骼 替换角色模型 资源管理面板-&gt;Blueprints-&gt;TopDownCharacter 选中Mesh-&gt;返回选择要使用的模型-&gt;回到面板，右侧Mesh导入 覆盖其他动作模型（同命名），骨骼同理 修改动画蓝图 修改TopDownIdleRun骨骼绑定 根据模型状态，拖拽动画文件至动画混合的速度轴 修改TopDownAnimBlueprint骨骼绑定 血量材质 文件结构 UI MAT（材质） blood Texture（贴图） 血量黑白纹理 球形显示黑白形状 导入血量材质 Mat文件夹中新建材质Blood 选中贴图，切换到材质编辑器 按住T，左键单击导入 定义颜色 按住3，创建RGB属性 M键+单击创建混合属性，连接颜色和材质 Blend Mode设置为Masked，Shading Mode设为Unlit，以将黑色部分设置为透明 -&gt;Emissive Color（高光层） 设置缩放：TextureCoordinate属性 动态化：按住P键单击放置Panner，设置贴图速度 复制多层参数不同的贴图，按住A点击放置叠加属性，将效果叠加 创建底色，叠加效果 圆形贴图 -&gt;Opacity Mask（透明通道） 实现血量反馈 按住0单击放置数值变量 创建LinearGradient（线性渐变） 创建if判断 创建血量边界 创建Add节点 血量数值 -&gt; Add 创建血量边界数值 -&gt;Add 创建if判断 Add-&gt;if-A LinearGradient-&gt;if-B 将if的结果做反向处理，与原先的血量混合-&gt;Multiply 设置单独的Panner和TextureCoordinate，和血量模块相加 提高亮度 UI制作 文件结构 UI Mesh MAT Texture UI框架贴图 Mesh导入贴图，MAT创建材质 创建显示组件（Cube），导入材质，移动到摄像机前合适位置 同理创建血量球材质 绑定UI和摄像机 在事件蓝图下创建Event Begin Play 选中UI框架，创建Attach To(UI框架) 将摄像机拖拽到蓝图内 绑定位置 Event Begin Play-&gt;Attach To(UI框架)根节点 Attach To(UI框架)-&gt;Attach To(血量球)根节点 Camera -&gt;In Parent Attach Type=Keep World Position 动态材质获取 编辑角色蓝图，新建Health变量(float) 新建血量变量(MaterialInstanceDynamic) 将血槽材质与血量绑定 选中血槽组件 Construction Script-&gt;Create Dynamic Material Instance(血槽) -Return Value-&gt;SET（血量变量） 编辑事件蓝图，新建Event Tick-&gt; 新建Set Scalar Parameter Value 血量变量-&gt;Target Health-&gt;Value 回到血量材质编辑蓝图，命名血量数值组件 回到事件蓝图，设置Parameter Name 动态改变血量 各种碰撞事件起点-&gt;Cast To （角色名）-&gt;SET As (角色名)-&gt;Target As (角色名)-&gt;Target Health-&gt;数值组件(+-*/)-&gt;Health "},{"title":"WPF样式(Style)","date":"2020-08-28T16:00:00.000Z","url":"/blogs/2020/08/29/WPF%20Style/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["C#","/blogs/categories/C/"]],"content":"基础样式简单例子 为窗口添加三个资源 FontFamily对象，包含希望使用的字体名称； 存储数字16的double对象（需要引用命名空间xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;）； 枚举值FontWeightBold（使用资源最常见的原因之一便是保存样式） 在元素中直接使用这些资源，因为在应用程序的整个生命周期中，这些资源都不会发生变化，所以使用静态资源是合理的。 最后就得到一个应用样式后的按钮。 注：样式设置元素的初始外观，但可以随意覆盖它们设置的这些特性。若再在Button元素中明确设置Fontsize=&quot;20&quot;，按钮标签中的FontSize设置会被覆盖为20。 改进结构 xaml设置方法： 或后台设置方法： 上面的标记创建了一个独立资源：即System.Windows.Style对象。并包含三个Setter对象，每个Setter对象用于设置一个属性。并为该样式设置一个键名来引用样式。 Setter对象中的Property设置针对Control类型，不只针对Button类型。 当它们都对控件的样式进行设置时，上个例子中只对Button控件有效果，而该例中对其他包含FontFamily、FontSize、FontWeight的控件都能有效果。 除此以外我们还可以使用TargetType属性，限定该样式可以引用的对象，语法如下： 此例就实现了，只允许Button控件进行引用该样式。 关联事件处理可以通过样式和后台事件的关联，实现动态样式的效果。 如：鼠标悬浮在文本标签上时，改变按钮的背景色。 对应的后台代码： MouseEnter和MouseLeave事件完成了背景颜色改变。 在TextBlock标签中，我们可以看到只需要应用一行Style=&quot;&#123;StaticResource MouseOverHighlightStyle&#125;&quot;便可以实现功能，这非常适用于 当我们需要为大量元素应用鼠标悬停效果的情况下，基于样式的事件处理程序简化了这项任务。 但WPF中极少使用事件设置器这种技术，更方便使用的是事件触发器，它以声明的方式定义了所希望的行为，并且不需要任何代码。 多层样式（样式继承）有时我们希望在另一个样式的基础上创建样式，这时可为样式设置BasedOn来使用此类样式继承。 第二个TextBlock继承了第一个TextBlock的样式，并在其基础上将文字颜色（Foreground）修改为了Red（红色）。 通过类型自动应用样式当我们需要为界面的所有Button设置统一样式的时候，如果Button比较少，我们可以用上面的方法逐个设置样式，但是当Button非常多的时候，这样的方法就显得麻烦了。 这个时候我们就可以使用TargetType来自动为对应的控件应用样式。 因为Style可以被覆盖，TextBlock1和TextBlock2为自己提供了一个新样式；而TextBlock3自动的应用了该样式；TextBlock4将Style属性设置为null值，这样就清除了样式。 触发器$$WPF触发器\\begin{cases} 简单触发器-Triggers\\ 多条件触发器-MultiTriggers\\ 事件触发器-EventTrigger\\ 数据触发器-DataTrigger\\end{cases}$$ 简单触发器-Triggers 满足简单的条件后触发 将一个Button赋予触发条件，当控件的IsFocused（成为焦点）属性值为True时触发，将这个Button的Foreground（前景色）赋值为DarkRed（深红色） 多条件触发器-MultiTriggers 满足多个条件时触发 上述代码赋予多个触发条件，其含义是： 当对象同时满足条件 IsFocused（成为焦点）属性值为True时 Content(内容)属性值为null(空值)时 即将ToolTip（悬浮提示）属性值设置为content is null! 事件触发器-EventTrigger 在特定的路由事件发生时被触发，主要用于动画 数据触发器-DataTrigger 根据绑定的数据不同，显示不同的内容 DataTrigger对象的Binding属性会把数据不断更新，一旦数据的值与Value属性一致，DataTrigger即被触发 后台代码： 经Converter转换后，长度值会转换为bool类型值。DataTrigger的Value被设置为false，也就是当TextBox的文本长度小于7时，DataTrigger会使用自己的一组Setter把TextBox的边框设为红色"},{"title":"游戏编程模式","date":"2020-08-28T16:00:00.000Z","url":"/blogs/2020/08/29/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"],["设计","/blogs/tags/%E8%AE%BE%E8%AE%A1/"]],"categories":[["程序设计","/blogs/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"],["数据结构","/blogs/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"常用程序设计模式命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销操作。其本质是将命令的生产者和命令的消费者分开；命令模式属于一种行为模式。 ——摘自《游戏编程模式》 举个🌰角色移动 最普通的命令响应类，比如角色类，响应命令实现特定的动作 引入抽象命令接口，调用者使用抽象命令接口编程 具体命令类 需要实现上面的抽象接口，在实现中执行接收者对应的操作 调用者 依据抽象命令接口编程，通过命令对象来执行请求 通过实现方式可以看出，命令的生产者和命令消费者之间已经没了直接调用关系，他们之间多了一层 Command。这样当你需要消费者执行不同的操作时，添加一个新的命令类并实现消费者的操作即可；甚至你的命令调用者能产生许多命令，将其push到一个命令队列中，角色只要从队列中读取命令响应，因为命令的响应已经与生产者无关了。 加以改进再回到之前的抽象命令接口。通过使用命令模式对 ExecuteCommand 方法加以改造，从而让代码更加优雅易懂。 现在，ExecuteCommand 接收的是一个 Command 和一个 Actor，这样看起来是不是更加符合我们的设计需求了?服务器模拟的 AI 的每一个操作通过一个个 Command 发送给客户端，客户端只需要执行命令命令就能够被消费。 ExecuteCommand 方法需要两个参数，在多数情况下这样是不错的选择。因为对于某个命令对象，你可以替换其中的操作执行者从而达到不同的执行者共享同一个命令对象的目的。但是如果碰到需要实现类似命令队列的问题，可能将每个操作执行者作为命令类的成员变量是更好的选择，但因此也就牺牲了共享命令类实例的优势。 撤销和重做以上个实例的情景为基础，产生一系列命令的同时，将命令 push 到一个队列中，这样实现命令的撤销和恢复，尝试如下改动: 首先，将操作执行类作为命令类的成员变量 具体命令类做一下修改 实现命令队列以及撤销、恢复操作 以上就是命令队列简单的实现，虽然牺牲了共享命令类实例的优势，但是换回了更多的设计需求。 所以在有些情况下，当操作非常多的时候，就需要写更多的具体命令类(虽然本来的目的就如此)，当不能共享命令类(如同上面的命令队列实现)就可能会产生大量的命令实例。所以，最终的权衡还是要根据更多的需求实际情况来确定。 享元模式 迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。 阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。 这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。 ——摘自《游戏编程模式》 用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。 当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到GPU六十次的百万多边形。 我们讨论的是成千上万的树，每棵都由上千的多边形组成。 就算有足够的内存描述森林，渲染的过程中，CPU到GPU的部分也太过繁忙了。 每棵树都有一系列与之相关的位： 定义树干，树枝和树叶形状的多边形网格。 树皮和树叶的纹理。 在森林中树的位置和朝向。 大小和色彩之类的调节参数，让每棵树都看起来与众不同。 关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。 它们使用了相同的网格和纹理。 这意味着这些树的实例的大部分字段是一样的。 我们可以通过显式地将对象切为两部分来更加明确地模拟。 首先，将树共有的数据拿出来分离到另一个类中。游戏只需要一个这种类， 因为没有必要在内存中把相同的网格和纹理重复一千遍。 游戏世界中每个树的实例只需有一个对这个共享Model的引用。 留在Tree中的是那些实例相关的数据 享元模式一般涉及的几种角色： 抽象享元角色（Flyweight）：此角色是所有的具体享元类的基类，为这些类规定出需要实现的公共接口。那些需要外部状态的操作可以通过调用方法以参数形式传入。 具体享元角色（ConcreteFlyweight）：实现抽象享元角色所规定的接口。如果有内部状态的话，可以在类内部定义。 享元工厂角色（FlyweightFactory）：本角色复杂创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享，当一个客户端对象调用一个享元对象的时候，享元工厂角色检查系统中是否已经有一个符合要求的享元对象，如果已经存在，享元工厂角色就提供已存在的享元对象，如果系统中没有一个符合的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。 客户端角色（Client）：本角色需要存储所有享元对象的外部状态。 举个🌰这个例子是：一个文本编辑器中会出现很多承载文本内容的字面，使用享元模式去实现这个文本编辑器的话，会把每个字面做成一个享元对象。 享元对象的内部状态就是这个字面，而字母在文本中的位置和字体风格等其他信息就是它的外部状态。 首先，创建抽象享元类，定义具体享元类的实现方法 创建具体享元类，这样我们就不用把每个字母设计成一个单独的类了，而是作为把共享的字母作为享元对象的内部状态 建立享元工厂，负责创建和管理享元对象 哈希表（Hash table） 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 客户端调用 运行结果： 观察者模式原型模式单例模式状态模式"},{"title":"Python爬虫","date":"2020-08-28T16:00:00.000Z","url":"/blogs/2020/08/29/PythonBot/","tags":[["编程","/blogs/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["Python","/blogs/categories/Python/"],["爬虫","/blogs/categories/%E7%88%AC%E8%99%AB/"]],"content":"Python基础知识数据类型 整数 Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串 字符串是以&#39;&#39;或&quot;&quot;括起来的任意文本，比如**’abc’，“xyz”等等。请注意，‘’或“”**本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。 布尔值 在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 print语句print语句可以向屏幕上输出指定的文字。 比如输出’hello, world’，用代码实现如下： 注意： 1.Python交互式环境下编写代码时，&gt;&gt;&gt;是Python解释器的提示符，不是代码的一部分。 2.print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出： print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： 注释Python的注释以#开头，后面的文字直到行尾都算注释 注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉： 字符串字符串可以用&#39;&#39;或者&quot;&quot;括起来表示。 如果字符串本身包含&#39;怎么办？比如我们要表示字符串I&#39;m OK，这时，可以用&quot; &quot;括起来表示： 类似的，如果字符串包含&quot;，我们就可以用&#39; &#39;括起来表示： 如果字符串既包含&#39;又包含&quot;怎么办？ 这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\\进行转义。 要表示字符串 Bob said &quot;I&#39;m OK&quot;.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 注意：转义字符 \\ 不计入字符串的内容中。 常用的转义字符还有： raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀r，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 但是r&#39;...&#39;表示法不能表示多行字符串，也不能表示包含&#39;和 &quot;的字符串（为什么？） 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 上面这个字符串的表示方法和下面的是完全一样的： ‘Line 1\\nLine 2\\nLine 3’ 还可以在多行字符串前面添加r，把这个多行字符串也变成一个raw字符串： 整数和浮点数Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。 基本的运算： 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层： 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数： 但是整数和浮点数混合运算的结果就变成浮点数了： 为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如0.1换成二进制表示就是无限循环小数。 那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下： 令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数： 如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了： 布尔类型与运算：只有两个布尔值都为 True 时，计算结果才为 True。 或运算：只要有一个布尔值为 True，计算结果就是 True。 非运算：把True变为False，或者把False变为True： 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串&#39;&#39;和None看成 False，其他数值和非空字符串都看成 True，所以： 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算a or b时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 list创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用[ ]把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 一个元素也没有的list，就是空list： 按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 要打印第二名同学的名字，用 L[1]: 要打印第三名同学的名字，用 L[2]: 要打印第四名同学的名字，用 L[3]: 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 这时，老师说，请分数最低的同学站出来。 要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2： 有没有更简单的方法？有！ Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素： Bart同学表示躺枪。 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 给list添加新元素现在，班里有3名同学： 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的append()方法，把新同学追加到 list 的末尾： **append()**总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 从list删除元素Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： **pop()**方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉： 替换元素假设现在班里仍然是3名同学： 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： 创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。 同样是表示班里同学的名称，用tuple表示如下： 创建tuple和创建list唯一不同之处是用( )替代了[ ]。 现在，这个t就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试： 单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。 包含多个元素的 tuple，前面我们已经创建过了。 包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示： 创建包含1个元素的 tuple 呢？来试试： 好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？ 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。 正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 多元素 tuple 加不加这个额外的“,”效果是一样的： “可变”的tuple前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple： 注意到 t 有 3 个元素：**’a’，’b’和一个list：[‘A’, ‘B’]**。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到： 然后，我们把list的两个元素改一改： 再看看tuple的内容： 表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。 tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即**指向’a’，就不能改成指向’b’**，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 爬虫简介爬虫是什么 通过编写这个程序，使其模拟进行浏览器上网，进而在互联网上抓取数据的过程 爬虫的价值 抓取互联网上的数据，为人所用，有了大量的数据，就如同有了一个数据银行一样 下一步做的就是如何将这些爬取的数据产品化、商业化 爬虫可能带来的风险 爬虫干扰了被访问网站的正常运营 爬虫抓取了收到法律保护的特定类型的数据或信息 如何在使用/编写爬虫的过程中，避免进入”局子”的厄运 时常的优化自己的程序，避免干扰被访问网站的正常运行 在使用，传播爬取到的数据时，审查抓取到的内容 如果发现了涉及到用户商业机密等敏感内容,需要及时停止爬取或传播 爬虫在使用场景中的分类 通用爬虫：抓取系统重要组成部分。抓取的是一整张页面数据 聚焦爬虫：是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容 增量式爬虫：检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据 爬虫的矛与盾 反爬机制：门户网站可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取 反反爬策略：爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据 robots.txt协议：”君子协议”，规定了网站中哪些数据可以被爬取，哪些数据不可以被爬取 如何查看robots.txt协议：网站域名 + ‘/robots.txt’ 例如：淘宝的域名为www.taobao.com，则协议地址为www.taobao.com/robots.txt http&amp;https协议http协议概念：服务器和客户端进行数据交互的一种形式。 常用请求头信息 User-Agent：请求载体的身份标识 Connection：请求完毕后，是断开连接还是保持连接 常用响应头信息 Content-Type：服务器响应回客户端的数据类型 https协议概念：安全的超文本传输协议 加密方式 对称秘钥加密 非对称秘钥加密 证书秘钥加密 requests 模块概念 python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 作用：模拟浏览器发送请求。 爬取页面中指定的页面内容，属于聚焦爬虫。 开始使用 环境安装（需要先安装python编译环境） 使用流程/编码流程 指定URL 基于requests模块发起请求 获取响应对象中的数据值 持久化存储 第一个爬虫程序需求：爬取搜狗首页的页面数据 实战案例1. 爬取搜狗指定词条对应的搜索结果页面（简易网页采集器） [!warning|style:callout|label:案例引入|labelVisibility:visible|iconVisibility:visible]UA:User-Agent（请求载体的身份标识） UA检测：门户网站的服务器会监测对应请求的载体身份标识。 如果检测到 请求的载体身份标识 为某一款浏览器，则说明该请求为正常请求； 如果检测到 请求的载体身份标识 不是浏览器，则表示为不正常请求（爬虫）， 则服务端有可能拒绝该请求，导致爬取失败。 代码实现 2. 破解百度翻译 [!tip|style:callout|label:思路|labelVisibility:visible|iconVisibility:visible] 若此操作引起页面局部刷新，网页地址不变，则可以判断此操作发出的是阿贾克斯（XHR）请求。 通过抓包工具，获取阿贾克斯（XHR）请求，找到带有被翻译字段参数的Post请求链接。 获取的响应数据（Content-Type）是一组json数据。 代码实现 3. 爬取豆瓣电影分类排行榜中的电影详情数据 [!tip|style:callout|label:思路|labelVisibility:visible|iconVisibility:visible]在豆瓣电影官网点击”排行榜”，进入”喜剧”分类 所需要获取的，就是这个局部页面内的电影名称等基本信息 当页面到达最底部时，发现页面获取了新的请求反馈，加载出更多电影信息，且页面地址未变化，因此判断页面发出了阿贾克斯（XHR）请求 在抓包工具中的Network - XHR下捕获对应的请求信息，确认Content-Type属性为application/json后，获取其url，请求类型（GET），以及所有来自表单信息（Form Data）的键值对 最后分析键值对内的几个关键参数，并自定义使用 代码实现 4. 爬取肯德基餐厅查询中指定地点的餐厅数 根据Content-Type: text/plain; charset=utf-8这一属性，返回的结果为text，因此无需调用json 同样指定url为请求包内的链接，获取Form Data内的参数作为请求的参数 5. 【进阶】爬取国家药品监督管理总局中 基于中华人民共和国化妆品生产许可证相关数据案例分析 [!note|style:callout|label:思路|labelVisibility:visible|iconVisibility:visible]此链接的可见内容里并不包含许可证的详细信息，无法确定这个链接是否包含详细信息 但是可以确定的是，每一个企业名称都对应一个超链接，此链接内包含对应企业的详细数据。 因此可以尝试，从请求链接中获取页面的标签数据，通过查找&lt;a&gt;标签中的herf属性获取详细数据的链接 第一步：初步代码，确认对网址请求是否能获取对应页面 验证发现，这种请求方式并不能获取页面内的详细信息，因此不能通过对url请求达成预期结果。 则可以判断，对原url请求的内容可能没有企业信息。很有可能时动态加载的信息，需要通过Ajax（XHR）请求来获取信息 第二步：刷新页面，确认是否产生XHR请求数据 验证发现，XHR得到了一组json数据，包含了页面内列表内的数据 但我们想的到的是列表内url对应的详细数据，于是进一步分析数据内部，发现并没有与url关联的数据，但是存在一个ID属性 通过对详情页url的观察发现 url的域名都是一样的，只有携带的参数(ID)不一样 ID值可以从首页对应的Ajax请求到的json串中获取 域名和ID值能够拼接出一个完整的企业对应的详情页的url 但是这里还有一个坑，还需要确定新得到的详情页数据是否是来自动态加载的请求，若是来自动态加载的请求，获取页面数据也就没有意义。 因此我们可以选择用第一步的方法尝试获取，但这样的方法效率极低，可以改成改用抓包工具来查看页面的内容。抓包查看All下的数据包，发现没有企业的数据。 所以得出结论，详情页的页面数据也是动态加载出来的！ 第三步：刷新详情页面，确认是否产生XHR请求数据 验证发现，页面的确产生了数据类型为json的HRX请求，且请求内携带的参数为id 至此就可以得到完整解决方案： 通过对原链接发起Ajax请求，获取json列表内的ID属性 将请求内的url与获取到的ID拼接，将其作为新的url 对新的url发起Ajax请求，获取最终的详细数据 优化思路后的解决方案：批量获取页面内的ID参数，分别与请求的url结合，获取对应的企业详细数据 代码实现 代码优化上述代码只能获取到其中一页的详细信息，若想要一次性多页（或所有）信息，只需要在页码的绑定数据外添加一个循环，将循环数字转为字符串后动态赋值给绑定数据，最后把只需执行一次的定义类代码移动到前面即可 数据解析 聚焦爬虫：爬取页面中指定的页面内容 编码流程 指定URL 发起请求 获取相应数据 $\\color{red}数据解析$ 持久化存储 数据解析的方法/分类 正则 bs4 xpath(语言通用性强) 数据解析的原理概述解析的局部文本内容都会在标签之间或标签对应的属性中进行存储 因此可以这么做： 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取（解析） 正则表达式方法常用的正则表达式 符号 含义 举例 单字符： . 除了换行以外的所有字符 [] 匹配集合中的任意一个字符 [aoe];[a-w] \\d 数字 [0-9] \\D 非数字 \\w 数字、字母、下划线、中文 \\W 非\\w \\s 所有的空白字符包，包括空格、制表符、换页符等等价于【\\f\\n\\r\\t\\v】 \\S 非空白 数量修饰： * 任意多次 &gt;=0 + 至少一次 &gt;=1 ? 可有可无 0次或1次 {m} 固定m次 {m,n} m-n次 边界： ^ 以某符号开头 ^begin $ 以某符号结尾 end$ 分组： (ab) a和b字符成组 贪婪模式： .* 非贪婪(惰性)模式： .*? re.I 忽略大小写 re.M 多行匹配 re.S 单行匹配 re.sub 在指定内容替换指定字符 re.sub(正则, 替换内容, 字符串) 正则练习 实例项目需求：爬取糗事百科指定页面的糗图，并将其保存到指定文件夹中 "},{"title":"经典排序算法","date":"2020-07-28T16:00:00.000Z","url":"/blogs/2020/07/29/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":[["算法","/blogs/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["排序","/blogs/categories/%E6%8E%92%E5%BA%8F/"]],"content":"$$排序算法\\begin{cases} 比较类排序\\begin{cases} 交换排序\\begin{cases} 冒泡排序\\\\ 快速排序 \\end{cases}\\\\ 插入排序\\begin{cases} 简单插入排序\\\\ 希尔排序 \\end{cases}\\\\ 选择排序\\begin{cases} 简单选择排序\\\\ 堆排序 \\end{cases}\\\\ 归并排序\\begin{cases} 二路归并排序\\\\ 多路归并排序 \\end{cases}\\\\ \\end{cases}\\\\ 非比较排序\\begin{cases} 计数排序\\\\ 桶排序\\\\ 基数排序 \\end{cases}\\\\\\end{cases}$$ 概述算法分类十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(n·logn)$，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 排序方法 时间复杂度（平均） 时间复杂度（最坏） 时间复杂度（最好） 空间复杂度 稳定性 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 希尔排序 $O(n^{1.3})$ $O(n^2)$ $O(n)$ $O(1)$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n·log_2n)$ $O(n·log_2n)$ $O(n·log_2n)$ $O(1)$ 不稳定 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 快速排序 $O(n·log_2n)$ $O(n^2)$ $O(n·log_2n)$ $O(n·log_2n)$ 不稳定 归并排序 $O(n·log_2n)$ $O(n·log_2n)$ $O(n·log_2n)$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ 稳定 桶排序 $O(n+k)$ $O(n^2)$ $O(n)$ $O(n+k)$ 稳定 基数排序 $O(n·k)$ $O(n·k)$ $O(n·k)$ $O(n+k)$ 稳定 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。 经典算法1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现 2、选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现 2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是$O(n^2)$的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现 3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到$O(1)$的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列$t_1，t_2，…，t_k，其中t_i&gt;t_j，t_k=1$； 按增量序列个数k，对序列进行k趟排序； 每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现 4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现 5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是$O(n·logn)$的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现 7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现 8、计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现 8.4 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.3 代码实现 9.4 算法分析桶排序最好情况下使用线性时间$O(n)$，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为$O(n)$。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现 10.4 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要$O(n)$的时间复杂度，而且分配之后得到新的关键字序列又需要$O(n)$的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是$O(d·2n)$ ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为$O(n+k)$，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。"},{"title":"交互设计基础","date":"2020-07-28T16:00:00.000Z","url":"/blogs/2020/07/29/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","tags":[["设计","/blogs/tags/%E8%AE%BE%E8%AE%A1/"]],"categories":[["人机交互","/blogs/categories/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"]],"content":"平台设计规范移动端1.界面设计规范IOS 导航栏： 用于实现在应用不同信息层级结构间的导航，有时候也可用于管理当前屏幕内容 工具栏： 用于放置操作当前屏幕中各对象的控件 标签栏： 标签栏让用户在不同的任务、界面和模式中进行切换 Android 应用栏（APP Bar） 应用栏在以前的安卓版本中被叫做操作栏 是用来显示应用的标识，应用导航，内容搜索以及其他操作 2.导航设计模式标签式导航 特点 适用于多个重要功能的罗列 入口扁平化 导航控件占据面积大，能够轻松进行点击操作，进行功能间快速切换 分段式导航 特点 由分段式控件所控制的一种导航模式 尺寸较小，能轻松地融入界面，不占用空间 设计师还能在其两侧放置其他的UI组件 它只是iOS的标准控件，一般不在Android端使用 不适合作为一级导航，往往作为二级导航与标签导航嵌套使用 舵式导航 特点 标签式导航的变体 适用于多个重要功能中存在一个特别重要的功能 抽屉式导航 特点 隐藏不重要功能，让用户更专注核心功能 能够大大减少主界面中的导航控件数量 被折叠的功能使用率较低 下拉菜单式导航 特点 盛行于Android4.0，现在使用的不多，但可以和滚动式菜单相结合 收起时：体积小巧，节省空间 展开时：能显示丰富的导航条目 往往没有关闭按钮 3.列表设计模式垂直列表 简单清晰、易于理解、冷静高效、快速定位 适合二级导航，或功能层级比较浅，且功能间切换不频繁的主导航 注意 大都为左对齐 需要调整条目详细程度与页面展示条目数量之间的平衡 轮播面板 隐藏内容、充分利用空间。 体验感强，适合一些功能选项较少，且不频繁跳转的产品，或者是浏览体验式的产品。 这类样式通常需要指示器，来提示用户屏幕外面还有内容 网格列表 能同时显示大量图片、提升界面魅力 功能扁平化，能充分利用界面 适合作为二级导航，在有限空间内罗列大量功能 注重于显示图片，和较少的文字显示 Web端1.网页布局 2.页面设计 页面中的设计元素 LOGO 导航栏 用户登录或信息 网站推广内容 广告 其他信息 3.自适应设计需求设计分析与方案选择 设计师没有细致地沟通业务需求，一直改方案，但没有观点； 没有仔细地分析用户需求，只是简单地进行页面排版； 没有对用户体验路径进行仔细分析，缺乏一个好的方式引导用户使用。 这些都是设计方案不能让人满意的原因 设计产品需要思考的问题 为什么要做这个功能？（业务目的） 品期望得到怎样的成果？（业务目标） 谁来使用这个功能？（目标用户） 他们为什么要使用这个功能？（用户需求） 如何让他们都来使用这个功能？（将业务目标转化为用户行为） 完整的交互设计循环过程 Plan：分析业务需求和用户需求，明确设计策略。 分析业务需求（业务目的、业务目标） 分析用户需求（目标用户、用户体验目标） 分解关键因素（用户的动机、担忧、障碍） 归纳设计需求，明确设计策略 Do：根据设计策略，设计完整的解决方案细节。 Check：走查、验证并修复问题，跟踪用户反馈。 Action：总结经验修订目标，开始下一个Plan 分析业务需求了解目的&amp;目标简而言之，目的是达到了某个目标之后想要做的事情，也就是实现目标的真正动机。 业务需求=业务目的+业务目标 提供用户注册功能是一个业务需求，提高注册转化率是它的业务目标。 当我们提高了注册转化率，就能获得更多的注册用户数，从而实现有效进行用户管理的目的。 互联网常见的目标（提升/降低）： 产品类 市场类 品牌类 营收类 PV、UV、用户数、转化率、留存率、活跃度等 传播量、市场份额、各种排名等 服务认知、品牌认知、品牌忠诚度等 销售量、销售额、利润率、ROI等 目标应该符合SMART原则 Specific - 具体 Measurable - 可衡量 Attainable - 可实现 Relevant - 有关联 Time-based - 有时限 分析用户需求明确目标用户，目标用户是群体，而不是个体 用户需求=目标用户（特征、经验）+用户场景+用户行为+体验目标 最终得到衡量指标 举例： 用户需求 目标用户（特征、经验） 用户场景 用户行为 体验目标 衡量指标 申请在云课堂开课 某PPT讲师熟练使用电脑 通过电脑申请 点击申请按钮 快速完成在线表单填写 表单的填写效率（提高） 分解关键因素将业务视角转换为用户视角 业务视角 用户视角 用户视角 有更多的专业人士和机构到云课堂开课（业务目标） 用户基于何种动机来开课，在申请开课前有哪些担忧？（用户意愿分析） 用户在使用过程中，会遇到哪些障碍？ 举例： 业务需求 业务目标 衡量指标 关键因素分解 对应的解决方案 动机：- 能赚到钱- 教会别人，扩大自己的专业影响力； - 提供成功案例 做一个课程提供方入驻申请介绍页面 有更多的专业人士、机构到云课堂开课 通过电脑申请(提高) 担忧：- 申请免费吗？- 赚不到钱- 平台没有足够大的用户群体- 需要提供太多的信息- 平台没有知名度- 平台技术不稳定- 审核时间太长- 是否适合我- 平台功能不强大- 是否支持我的运营类目- 将来如问收款 - 告诉用户免费申请- 提供成功案例- 增加平台用户数量显示- 告诉用户只需要1分钟就能完成表单提交- 告诉用户云课堂是在线教育NO1- 提供7x24技术支持- 告诉用户24小时内会快速审核- 说明什么样的人可以来申请- 告诉用户有牛逼的欤学管理功能- 告诉用户接受不同领域的课程- 告诉用户使用“网易支付”收款安全又放心 用户需求 用户体验目标 衡量指标 关键因素分解 对应的解决方案 申请在云课堂开课 快速完成在线表单填写 表单的填写效率(提高) 障碍：- 需要提供太多信息- 网络不稳定- 没有相关的证件 - 减少非必要的信息输入- 现在申请还送XXX- 提高网络稳定性- 支持多种证明文件 明确设计策略归纳好设计需求，去掉重复的解决方案，得到下表。 关键因素分析 对应的解决方案 动机：- 能赚到钱；- 教会别人，扩大自己的专业影响力； - 提供成功案例 担忧：- 申请免费吗？- 赚不到钱；- 平台没有足够大的用户群体；- 需要提供太多的信息- 平台没有知名度；- 平台技术不稳定；- 审核时间太长；- ·是否适合我；- 平台功能不强大- 是否支持我的运营类目；- 将来如何收款； - 告诉用户免费申请；- 提供成功案例；- 增加平台用户数量显示；- 告诉用户只需要1分钟就能完成表单提交；- 告诉用户云课堂是在线教育NO1；- 提供7×24技术支持；- 告诉用户24小时内会快速审核；- 说明什么样的人可以来申请；- 告诉用户有牛的教学管理功能；- 告诉用户接受不同领域的课程；- 告诉用户使用“网易支付收款安全又放心； 障碍：- 需要提供太多的信息；- 网络不稳定；- 没有相关的证件； - 减少非必要的信息输入；- 现在申请还送XXX提高网络稳定性；- 支持多种证明文件； 根据结果可以得出设计师能需要提供的交互方式 用户体验路径分析 画出用户体验路径和情感坐标 整理各个接触点的问题和惊喜 判断各个接触点的情感高低 连接情感曲线 选择合适的解决方案1. 互联网产品团队的分工 初创型：同一角色担当产品管理+项目管理+交互设计 中大型：交互设计角色开始独立 细分型：项目管理角色开始独立 不同的需求，提供不同程度的专业支持 产品经理的主要工作 评估产品机会 制定产品目标和策略 规划产品的发展路线图 定义产品需求和业务目标 监督需求的实现 关注市场反馈并作出及时调整 维护不同团队的沟通 ——目的是让产品实现长期的用户满意，保持市场竟争优势，把产品的商业价值发挥到最大。 交互设计师的主要工作 分析业务目标和用户体验目标 分解阻碍用户达成体验目标的关键因素 制定设计目标和策略 设计信息架构、用户操作流程、导航和UI细节 输岀相关设计规格文档，建立并维护设计规范 跟踪视觉设计、技术开发的实现情况 优化产品可用性，持续改善用户体验 ——目的是让产品和用户之间建立有机关系，有效实现用户目标和产品目标。 2. 交互设计方案的评价维度 有用性：能同时满足业务目标和用户体验目标 可用性：用户易于理解、学习，使用无障碍 吸引力：打动人的细节，或者超越期望的设计 尼尔森十大可用性原则 可视性原则：系统状态有反馈，等待时间要合适。 环境贴切原则：使用用户语言而不是开发者语言，贴近生活实际而不是学术概念 撤销重做原则：操作失误可回退。 一致性原则：同一事物和同类操作的表示用语要各处保持一致。 防错原则：关键操作有确认提示，及早消除误操作。 易取原则：识别胜于回忆，提供必要的信息提示（可视&amp;易取），减少记忆负担 灵活高效原则：为新手和专家设计定制化的操作方式，快捷操作可调整 易读性原则：减少无关信息，体现简洁美感 容错原则：给用户明确的错误信息，并协助用户方便的从错误中恢复工作。 人性化帮助原则：无需文档就能流畅应用当然更好，一般地文档很必要，而且也提供便利的检索功能，面向用户任务描述，列出具体实现步骤，并且不要太冗长 3. 交互设计方案的决策方式与过程 决策方式 使团队保持清晰的、一致的目标，并坚持不妥协 允许妥协无伤大雅的细节，避免钻牛角尖，或过度设计 保持开放心态，倾听各方意见但是你要自己做决定 决策过程 内部Review：指设计师的作品先在设讲团队进行审核，吸收专业方面的建议 外部评审：通常作为一个会议的形式存在，交互设计师在完成了设计且和产品经理确认需求满足情况之后，输出相关的设计文档，召集大家进行讲解 4. 如何推销你的设计方案 将思考过程可视化：将需求分析的结果可视化（如做成表格）展示出来。 自己人效应：变交互设计师要和产品经理起去梳理需求，而不是一味地抱怨需求不完整。如果因为需求不完整而拒绝了产品经理，这绝对是个错误的合作方式。交互设计师应该主动参与产品构思，井且和产品经理一起分析需求归纳目标。 准备一份PPT。 讲一个动听的故事：可以以用户的某一种场景作为开端，讲述它是如何接御这个产品，以及是如何一步一步使用这个功能的，这个比起照着交互稿一页一页地念会更加有用。 掌握必要的演讲技巧与表达能力。 信息架构设计认识信息架构设计什么是产品的信息架构？ 信息架构设计是对信息进行结构、组织方式以及归类的设计好让使用者与用户容易使用与理解的一项艺术与科学。 为何产品需要合理的信息架构？ 让用户一眼就明白你的产品能做什么，大概怎么用。 用户都能在需要的时候容易地找到某个功能。 以至于带给用户更好的体验，使产品获得更高的留存率 信息架构为何需要设计？ 信息架构不是功能的简单堆叠，所以，需要更有逻辑性的方法 前期准备工作了解用户，场景，习惯通过对Persona(用户角色模型)、用户场景的了解与分析，得出用户的使用习惯。 尊重用户习惯： 用户通常用你的产品做什么？ 用户用这类产品最关心什么？ 用户有哪些思维定式？ 用户用什么类似的产品？ 创新：从自己本身的用户习惯出发 了解业务需求从产品经理那了解业务需求：不突出业务无关内容 从运营&amp;市场了解业务需求：让信息架构有更大的兼容性，能让产品产生更多可能性 调研竞品的信息架构 知己知彼，百战不殆 找3-5个同品类竞品，分析他们的信息架构，构造思维导图 自己的产品过去的版本同样也是竞品 分析共性与差异 共性（要遵循的用户习惯） 差异（设计机会点） 消息&amp;联系人 音乐产品里看的内容 发现音乐 购物网站的首页 购物车 打车应用的侧边栏 卡片分类法了解竞品后，还要进一步了解用户的心智模型 心智模型：基于用户的经历或学习，认为事情应该如何发展 卡片分类法：让用户对功能卡片进行分类，组织，并给相关功能的集合重新定义名称的一种自下而上的整理方法 卡片分类法的大致步骤： 介绍卡片 用户归类卡片 让用户取名 继续归类 简单访谈 拍照存档 需要以下这些东西 目标用户功能/信息卡片（便利贴） 2支笔（一定要写的出字） 空白的卡片（便利贴） 笔记本（记录用户发言） 功能/信息卡片怎么提取？ 它是功能或界面的名字，比如：联系人名片，对话窗口，拨号呼叫。 根据你的调研诉求，来决定卡片的颗粒度。 功能/信息卡片不能出现包含关系。 卡片总数不要超过30张，那会让用户无从下手。 如何更好地引导用户 介绍卡片：是否理解每一张卡片的含义，如果不理解可以询问 用户归类卡片：为什么把这些卡片放在一类？ 让用户取名字：这类卡片取个名字，可以叫什么？/根据你刚刚的归类原因，是不是可以叫XXX？ 继续归类：这一类的卡片数量较多，是否可以进一步细分？/现在已经分了N类，是否还有哪几类能再放在一起？ 简单访谈：在分类过程中是否有什么纠结的地方？ 拍照存档：是否确定这是最后的结果？ 最后通过此方法产出一份思维导图 如何产出产品信息架构设计利用思维导图和Axure整合信息 为自己的产品做一张信息架构树状图 对每一层进行分级 重要性分级≠排序 使用Axure，利用站点地图体现信息架构 寻找层和度的平衡 层=信息架构树的深度 度=某一节点子节点的广度 层过深=进入某一叶功能时需要非常多层级，操作困难。一般情况不超过5 度过多=在某一层级（页面）有太多的内容，用户认知成本增加，容易找不到想找的内容。 验证核心使用流程在信息架构层面确保核心使用流程的通畅 尽量保证根据树结构进行层级自上而下前进 不连通层级间的跳跃，尽量发生在最后一层级 考虑信息架构和交互构图的关系 不要在信息架构构图层面，为了”不一样”而不一样 移动端 利用重要性分级 Tabs导航：第一重要级中多项 抽屉式导航：第一重要级中只有一项 复合式导航 web端 利用不同结构，体现重要级 利用布局，体现逻辑关系 为讨论做好准备 你的过程就是你的底气 通过足够的过程来支撑你设计理念，讲清楚为什么要这么设计，增加讨论资本。 如何评判产品信息架构设计用户测试 用户是否在你不介绍具体产品的情况下，通过短时间的使用，说出产品可以用来做什么。 让用户进行核心流程任务，检查完成任务是否顺利。 给用户一个找寻一个相对层级较深的功能的任务，检测用户是否能通过信息架构名称找到功能。 撰写产品说明书通过撰写一份使用说明书，让用户阅读，过一段时间考察用户的记忆程度 信息架构推广：用信息架构思路设计页面为何在单一页面设计时需要考虑信息架构问题 确定页面所需要呈现的信息 绘制信息架构树状图 重要性分级 绘制页面 明确一个页面中的元素逻辑性与重要级 绘制单一页面逻辑相关的内容使用统一的形式，位置，并让区块联通 利用大小，位置，色彩体现重要级 流程设计概述用户和产品的交互 用户如何打电话？ 拨号→确认号码→呼叫号码【拨号键盘】 寻找联系人→选中目标→找到号码→呼叫号码【通讯录】 找到未接电话→呼叫号码【最近通话】 企业中的流程设计还需要考虑什么？ 以不干扰用户使用流程的方式完成业务需求 优秀的流程设计有什么好处？ 增加任务的完成率 让用户更方便地完成任务 对错误的充分思考 夸张的业务完成度 如何进行流程设计充分理解业务需求 业务需要达成的商业目标 for example：易信免费电话 利用免费电话这样的刚需功能点，吸引更多用户，从而帮助用户形成社交关系 业务受到哪些技术和商务限制 免费电话需要耗费公司本身资源，实际技术原理为公司支付了用户通话费用，因此无法大量送给所有用户 了解业务所需要的合作方 某某合作方支持了活动，所以希望得到曝光 找到用户完成任务的所有接触点 **接触点(Touchpoint)**：和产品或某一渠道发生交互的关键点 用户点击一个Button、用户看到某个信息… 接触点来自于用户场景 用户场景：基于用户模型，经验，用户调研的体验故事 小明和平时一样，给在老家的妈妈打电话报平安，聊了15分钟，小明挂断了电话。 小明看到了剩余电话时长不多的提示，想想还有半个月才到下月时长更新，因此想了解下如何获取更多时长 小明通过如何获取更多时长的入口，了解到只要邀请好友加入App，就能在本月获取额外时长赠送。 小明想了想，觉得可以邀请公司中关系比较好的同事，于是通过微信把邀请链接发给了同事。 为了能确保同事下载注册App帮助自己获取额外时长，小明在微信中简单介绍了一下App，并告诉同事如何通过自己分享的链接帮助自己获取时长。 Tips: 为了完成流程设计，需要构思的用户场景有多个，学会合并同类项 要顾及头尾，它们是最容易被遗漏的接触点 梳理接触点用户做了某件事→改变了用户所处的状态，产生接受新信息的机会 用户看到某个信息→获得了新的知识从而产生新的想法 例子： 挂断电话→可以接受电话的其他信息→看到时常不足信息→产生了解怎么办的欲望→点击了解如何获取更多→准备接受获取方法的信息→查看获取更多时长的信息→产生尝试的想法→… 最好的模式：做事—看信息—做事 做事—做事模式：用户的经验足矣支撑行为。例如：输入账号——输入密码 看信息—看信息模式：信息量较多，需要依次理解。例如：看到活动大致流程——看到具体规则 接下来就是做流程图，同时加入业务需求所需的流程节点 不需要用户操作地加在中间流程。 加在使用流程的最后 根据流程设计交互稿 在交互稿上体现用户操作流程 如果出现流程有很多分支时，不要制作在一个页面中，这样会让交互稿可读性变差。更好的做法是在站点地图上体现这些分支 不要随意地跳过某一页面，流程设计需要考虑到流程中出现的每个页面 注意前后页面的关联性和一致性。 在完成交互稿后，请对照接触点流程检査一遍交互，确认毎个接触点的过度是自然的。你提供了完成一个接触点所需要的全部信息 处理异常流程 必须要考虑的异常 用户网络故障 服务器资源不足 不要造成不可挽回的损失=&gt;自动保存机制 了解错误返回码可以让错误考虑更全面 预测用户可能出现的错误 错误的点击 注意处理的力度 Toast：提示文字少，且可以马上重试 Alert：提示文字较多，且需要用户确认 正常流程设计&gt;核心异常流程设计&gt;可以简单解决的小异常 流程设计与交互工作流程设计与信息架构设计 从0到1的交互设计稿 信息架构设计 核心流程设计 信息架构调整 完成所有流程设计 流程设计与用户场景$$\\begin{cases}用户目标\\业务目标\\用户体验目标\\end{cases}\\implies用户场景\\implies相应流程设计\\implies{一个结合页面\\的用户场景故事}$$ 让页面布局更优雅设计心理学 为什么要懂视觉心理学？ 运用用户观察和思考的规律来设计界面 构建的用户体验和使用场景需要通过视觉界面来实现 更好地向视觉设计师传递设计方案 接近性 依据间距来判断彼此间的关系，空间上的亲近暗示关系上的亲近 相似性 如果其他因素相同，那么相似的物体看起来归属于一组 相似 VS 对比 相似，表明是同类，快速做出判断 对比，表明彼此差异，适当引导 封闭性 人们倾向于将缺损的轮廓加以补充使成为一个完整的封闭图形 本质性上是对完整状态的认知倾向，比如“操作的闭环” 连续性 凡具有连续性或者共同运动方向的物理容易被看做一个整体 对称性 根据视觉元素重量的不同，来营造实现视觉平衡 情感化 色彩帮助营造网站的整体氛围 明确情感需求，并准确转递给视觉设计师 页面排版布局 页面排版布局，就像整理房间，都是在有限的空间内，对特定的信息进行整理/归类/摆放的过程。 Step 1：确定页面的任务目的 “页面”是用户体验的重要载体 衡量页面的标准 满足用户需求，减少用户的理解和操作成本，还能深深地吸引用户，让这个产品捕获用户的芳心。 有用：最重要的衡量基准—用户和产品需求的满足 易用：架构清晰/流程清晰/不需思考 好用：友好和充满情感化 用户到达每个产品页面的目的：$获取信息+操作流程=完成“任务”$ 阅读类 为了营造沉浸式的阅读体验在阅读时，隐藏操作按钮。 但需要操作时，仅需轻触屏幕，即可唤起操作栏。 音乐类 为了沉浸式的体验，享受音乐的乐趣，通过黑胶唱片的形式，展示音乐播放的主体 按照设计规范和手指活动范围，将必要操作展示在唱片下侧 列表类 为了突出“建群”操作，广场以悬浮入口”的形式 建群页面，合理地处理了建群和加群的需求 支付类 半遮罩的设计，减少页面跳转 营造一种都是当前页面的体验，提供用户付款率 Step 2：信息元素的组织分类 卡片分类：“可能是”信息组织分类最好的方法 卡片分类的应用场景 信息架构 导航设计 页面设计 卡片分类的逻辑：现实生活的映射 Step 3：对组块进行排版布局 常用设计原则 设计策略 整体原则：清晰的视觉引导 用户固有的阅读习惯 对角线法则 显示：严谨的页面逻辑关系，突出主要任务流程 弱化：弱化次要流程 除了视觉上的区分外，也可以通过增加操作步骤，来有意增加某些任务难度 删除：删除不必要的功能 隐藏：不能删除的非必要信息 除了可以隐藏一些“鸡肋”功能外，一些高阶的功能，普通用户比较很少会用到，只有高级用户才会用到 影响因素 操作频率 拇指操作区域 操作频率 距离与面积 费次定律：用户使用指点设备到达一个目标的时间同以下两个因素有关：距离(D)和目标大小(S)。 设备当前位置和目标位置的距离（D）距离越长，所用时间越长； 目标的大小（S），目标越大，所用时间越短。 悖论1：当面积增加不会带来可用性的持续增长 悖论2：距离太近可能引发分组不清、界面混论、容错低等问题 情感化设计 动效 至于交互不在于酷炫，而是体验的一部分 Step 4：权衡平台规范和用户的使用习惯 在实际设计中，针对不同平台，我们需要设计几套方案？ 是否区分设计，需要看当前项目的阶段和项目重点 如果我们人力有限，能否只设计一套方案？这一套方案该怎么提供？ 如果不区分设计，在大框架一致的前提下，尊重平台控件使用规范 如何以最低成本来设计两套（Android &amp; iOS）方案？ 如果采取分别的设计，发挥各自平台最大的潜力，做到极致 混合设计也许能够从另外一个层面解决跨平台兼容问题 Native App Native APP指的是原生程序，一般依托于操作系统，有很强的交互，是一个完整的App，可拓展性强。需要用户下载安装使用。 语言：Object C（iOS）、Java（Android） 页面：存放在本地 Web App Web App指采用Html5语言写出的App，不需要下载安装。类似于现在所说的轻应用。生存在浏览器中的应用，基本上可以说是触屏版的网页应用。 语言：html 页面：存放于服务器 Hybrid App 结合Native App与Web App 混合设计： 页面框架由本地native构成，确保稳定性。 页面内容由H5构成，保证迭代的灵活性。 Hybrid App设计的注意事项 简化不重要的动画/动效，简化复杂的图形文字样式 少用手势，少用弹窗 减少页面内容，减少控件数量，减少页面跳转次数，尽量在当前页面显示 增强Loading时的趣味性，增强页面主次关系，增强控件复用性 Step 5：页面排版的设计验证 实践是检验真理的的唯一标准。 只有在真实任务场景中，帮助用户快速完成目标的页面才是最好的设计 关于借鉴与设计的三个阶段 阶段1：为了借鉴而借鉴 阶段2：为了避免借鉴，而差异化设计 阶段3：为了用户习惯而设计 交互设计师工作最常用到快速验证方法 交互“专家评估” 邀请交互专家 &gt; 系统评估 &gt; 需求交互&amp;可用性问题 &gt; 整理结果 &gt; 修改及排期 专家评估是一种专家评审法，由几个评价者根据通用的可用性原则和经验来发现系统潜在的可用性问题。 邀请可用性评估专家 每一个评估人员进行1-2小时使用系统； 以可用性启发为基础，让评估人员对用户界面进行系统的检查，找出存在的可用性问题； 之后提供一份独立的报告，在报告中应包括可用性问题的描述，问题的严重性以及改进的建议； 构建一个对系统的评价并尝试找出解决方案。 “粗暴”的用户测试 不拘泥于形势的原型 有针对性抓取同事进行测试 可以任务走查，也可是AB测试 获取测试结果后快速优化 交互设计文档什么是交互设计文档 交互设计文档不是一个简单的Axure文档，而是一套体系，一个完整的产品。 $需求确定&gt;交互设计&gt;视觉设计&gt;产品开发&gt;测试优化&gt;上线迭代$ 需求确定阶段：具象产品需求，以可视化（草图）的页面形式，谈论需求的满足情况 交互设计：作为交互设计方案的载体，详细阐述设计方案的细节，用来与上下游谈论方案的可行性，确定最终方案。 视觉设计：根据交互稿设计出视觉效果图，关注页面的布局结构，顺序位置，主次及交互方式等 开发阶段：通过交互文档，交互设计师与各端开发确定方案的可实现性。开发人员依据交互文档的实现方式进行开发。 测试阶段：严格测试设计方案最终的实现效果，确保产品的质量。 交互文档的重要性 让相关者明白设计方案及分工。 可以作为界面验收时的checklist. 确保用户体验一致性和统一性，达到传承传递的作用。 交互文档没做好会带来 造成信息不对称，误解方案。 给交互设计师自己带来很多不必要的麻烦。 产品开发变的混乱。 导致整个产品达不到预期、产品失败问题。 撰写高质量的交互设计文档 选择什么工具来制作交互设计文档？ Axure Sketch Keynote/PPT 团队内软件版本保持一致 交互文档展示 封面 项目简介（某产品/功能—版本号） 产品策划人 交互设计师 视觉设计师 开发人员 测试人员 目录 结构清晰 命名准确 修订记录 意义 方便各方快速了解更新内容，而无需一页一页的查找，浪费不必要的时间和精力。 对交互设计师自己也是一个记录笔记的地方，避免遗忘。 当各方意见相左时，修订记录是最好的约定。 如何做 以天为单位清楚记录从文档建立时到开发完成甚至到跟进阶段所有修改的内容。 便于其他人的查找，可附上页面链接，直接跳转相应页面。 需求分析及业务流程图 信息架构图 交互流程图 交互方案 流程 一个页面一个任务：每一页能展示的内容是有限的，如果同一页中堆积太多线框图会造成问题 每个任务都要有起点 同一个页面的不同状态，最好在一个页面展示（不要忽视极端情况） 页面内容 页面布局规范，准确传递设计方案 尽量黑白灰，避免视觉干扰 交互说明 交互规则及逻辑关系（点击后产生XX提示） 交互迭代要有标示（XX时间补充） 点击后的交互反馈 控件何时激活，何时不激活 点击后跳转情况，时间纬度上的变化，比如跳转，加载，按钮状态 动效如何说明 通缩局部小图展示动效的每个分镜头 通过文案描述，讲解动效需求 视觉设计师提供动态效果图 需要视觉设计师注意的特别标明 哪些页面需要视觉稿 哪些需要视觉特殊处理 在视觉上有情感需求 控件库 布局规范说明 交互设计文档的实际应用 产品经理（需求方）：需求的提出方。有可能是产品经理、产品运营、利益相关者甚至是老板。 明确需求——与产品经理一起明确需求 制定规则——展示规则 变更需求——方案变更周知 视觉设计师：交互设计师的下游，他们根据交互稿设计出最终的视觉效果 单个页面设计——每块元素的合理布局 不能轻易调整交互文档——少用视觉元素 可以设计调整的地方——局部细节排版可以合作完成 开发工程师：产品的最终实现者，根据产品需求形成可实现的技术设计并完成相应的开发工作。 功能的实现方式——交互细节/交互逻辑的详细描述 实现方式的变更——变更前的确定，以及变更后的通知 测试工程师：产品的把关者，产品开发完成后，需要由他们负责验收成果。 撰写测试用例——详细表述细节 极端情况——极端情况说明 交互文档的严格实行者——交互设计师的好朋友 项目实例 美团App—基于社区的拼单功能 产品策划人：王俊 交互设计师：黄聪 测试人员：曾佳仪、何雨欣、刘雅静、刘福安、谢锐敏 需求分析 用户需求：点的外卖不满足起送费，但自己又不需要点那么多 用户需求 目标用户 （特征、经验） 用户场景 用户行为 体验目标 衡量指标 通过美团点花更少钱点外卖 某普通用户，熟练使用美团App 使用手机 发起/搜索附近的拼单 在一定时间内完成拼单订餐 用户的外卖订餐率提高 业务需求 关键因素分解 对应解决方案 动机：- 能省钱- 拼单更方便 - 优化流程 担忧：- 不能省钱- 使用不方便- 配送速度不够快- 隐私泄露- 不能使用优惠券 - 告诉用户对比原先省下多少钱- 提供快捷的拼单入口- 告诉用户预计配送时间- 告诉用户个人信息仅商家可见- 提供优惠券选择入口 障碍：- 需要提供较多信息- 网络不稳定 - 减少非必要的信息输入- 现在使用享受减免优惠- 提高网络稳定性 用户场景 小李同学突然想喝一杯奶茶了，她点了一杯奶茶发现达不到配送费。于是她进入拼单页面，去搜索附近拼单，然后发现小王同学也想一起拼单。最后两个人拼单成功，并且先后在自己家中收到了配送员的外卖。 小王同学在拼单过程中，由于在5分钟内没有等到其他用户，小王选择让系统向他推荐其他有用户正在拼单或可领取优惠券的附近店铺。 小丽同学匹配到了其他拼单人，但在拼单过程中，对方拼单者由于临时有事放下手机，在5分钟内没有完成订餐，系统自动取消了这次拼单。 社区拼单：根据用自身的位置信息，向周围人发起，有时间设定 好友拼单：周围人不可见，无时间设定。用户发起拼单，产生拼单的分享链接，然后发给自己认识的朋友，这样做法目的是只允许自己的朋友去加入这次拼单。 "},{"title":"操作系统","date":"2020-07-28T16:00:00.000Z","url":"/blogs/2020/07/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","tags":[["算法","/blogs/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["OS","/blogs/categories/OS/"]],"content":"作业调度的时间计算批处理作业调度算法 先来先服务（FCFS - First Come First Served）调度算法 选择最先进入后备队列的作业装入内存。 优点：比较容易实现。 缺点：不区分作业长短，对短小作业十分不利；不顾及轻重缓急；对时间要求紧迫的作业不能做到急事急办。 最短作业优先（SJF - Shortest Job First）调度算法 从后备作业中选择运行时间最短的作业装入内存。 优点：照顾短作业用户的利益，提高系统吞吐量，降低此作业的平均周转时间。 缺点：推迟长作业运行，可能出现饥饿现象。估计运行时间本身有可能不太准确。 最高响应比优先（HRF - Highest Response First）调度算法 定义：作业的响应比 $ R={t_w+t_s \\over t_s}={t_w \\over t_s}+1\\approx{t_w \\over t_s} $ $ t_w $ - 作业的等待时间， $ t_s $ - 作业的估计运行时间 优点：折衷考虑到作业进入系统的先后次序，又顾及到作业的运行长度。 缺点：每次调度都要计算每个作业的响应比，开销大。 最高优先级优先（HPF - Highest Priority First）调度算法 该算法每次总是选择后备作业中优先级最高的作业装入内存。 当一个作业进入系统，系统根据用户级别、用户租金、作业类别、作业运行时间要求等为作业赋予一个优先级。 HPF是一种比较灵活的调度算法，优先级可以根据需要灵活确定。 HPF经常作为基于作业运行紧迫性的一种调度方案。 均衡调度算法（理想型算法） 根据内存容量的限制，选择一组资源互补型的作业装入。 目的：在作业运行期间，尽可能提高CPU和各种设备之间的并行度。 作业调度性能的衡量标准 系统吞吐量高 单位时间内系统完成的工作量称吞吐量。这是作业调度追求的第一目标。 吞吐量Q 与 作业的平均周转时间T 的关系：平均周转时间T越小，系统吞吐量Q就越大 对短作业优惠 这一准则主要为了吸引中小用户使用计算机。 为了描述系统对短小作业的优惠程度，可使用作业的平均带权周转时间W作为评价参数。 其他指标 处理机利用率高 响应时间有保证 优先权有保证 截止时间有保证 资源均衡利用 作业调度时间算法 $n$ - 单位时间内的作业数量 $t_{bi}$ - 第i个作业提交的时间 $t_{fi}$ - 第i个作业的完成时间 $t_{si}$ - 第i个作业的运行（占用CPU）时间 作业周转时间 $T_i＝t_{fi}-t_{bi}$ 作业的平均周转时间 $T={1 \\over n}\\displaystyle\\sum_{i=1}^n(t_{fi}-t_{bi})$ 作业的平均带权周转时间 $W={1 \\over n}\\displaystyle\\sum_{i=1}^n(t_{fi}-t_{bi})/t_{si}$ $响应比＝{等待时间＋运行时间\\over运行时间}$ 算法案例 两个程序，其中A请求系统服务时间5s，B请求系统服务时间为100s，设第0到第5秒前，CPU运行C进程。在第1秒时B进入系统内存，第2秒时A进入内存。当CPU空闲，需要调度进程时根据不同的算法选择A或B。 问：分别计算FCFS算法下和SJF算法下，A和B的周转时间、带权周转时间。 FCFS：先进先运行 Job 进入时间 运行时间 开始时刻 完成时刻 周转时间 带权周转时间 A 2 5 105 110 100-2=108 108/5=21.6 B 1 100 5 105 105-1=104 104/100=1.04 根据上表信息 $\\begin{split}周转时间&amp;=(104+108)/2\\\\&amp;=106\\end{split}$​ $\\begin{split}带权周转时间&amp;=(21.6+1.04)/2\\\\&amp;=11.32\\end{split}$​ SJF：最短作业优先 Job 进入时间 运行时间 开始时刻 完成时刻 周转时间 带权周转时间 A 2 5 5 10 10-2=8 8/5=1.6 B 1 100 10 110 110-1=109 109/100=1.09 根据上表信息 $\\begin{split}周转时间&amp;=(8+109)/2\\\\&amp;=58.5\\end{split}$ $\\begin{split}带权周转时间&amp;=(1.6+1.09)/2\\\\=1.345\\end{split}$ 进程管理与调度分清作业、进程与程序的区别 作业：用户提交给系统的一个计算任务。 批作业=程序+数据+作业控制说明书 交互作业=程序+数据+交互命令 作业是用于人机之间交互的一个概念。 程序：完成一件事情的代码序列。 进程：是一个程序的一次动态执行过程。 程序是静态的；进程是动态的。 程序只包含代码：进程包括要运行的代码、代码要处理的数据、运行过程中的状态参数等。 进程与进程管理模块进程的特征 动态特征：生命周期 并发特征：在一个时间段内都处在宏观的运行状态 独立特征：独立占有资源、独立参与CPU调度 异步特征：运行推进速度不可预知 结构特征：PCB（进程控制块）+进程体 进程控制块PCB 进程控制块PCB的数据内容包括： 进程标识：系统识别进程的标志 外部标识（也称作进程的外部名）：是进程的创建者提供的进程名字，通常由字符串组成 内部标识（也称作进程的内部名，简记为Pid）：是系统为进程命名的一个代码，通常是一个整型数 进程调度信息：系统调度选择进程的依据 进程优先数，描述进程紧迫性的信息 进程状态信息，描述进程当前处于何种状态 其它调度信息。 如：进程在系统中等待的时间、已在CPU上运行的时间、剩余的运行时间有等。 处理机信息（进程上下文） 通用寄存器的内容：包括数据寄存器、段寄存器等 程序状态字PSW（ Program Status Word）的值 程序计数器PC（ Program Count）的值 进程的堆栈指针等 进程被中断时，该进程的CPU现场信息可以保存在它自己的PCB内，以便该进程重新获得CPU时可以从此处恢复现场信息，继续运行。 进程控制信息：系统对进程实施控制的依据 程序代码和数据集所在的内存地址 资源清单，记载进程请求资源和已经占有资源的情况 同步与通信信息 外存地址 家族信息 链接指针 进程的状态转换两状态进程模型 进程的三种基本状态 运行状态(Running)：进程获得CPU并投入运行的一种状态 在单CPU系统中，每个瞬间最多只能有一个进程在运行。 就绪状态(Ready)：进程尚未获得CPU使用权的一种状态 进程已经拥有除CPU外其它全部所需资源 “万事俱备、只欠东风” 阻塞状态(Blocked)：进程因某种要求得不到满足，只好等待，称之为运行“受阻” 处于阻塞状态的进程是无权获得CPU的。 三状态进程模型 两种扩展的挂起状态 挂起阻塞(S-Blocked)状态 挂起就绪(S-Ready)状态 挂起某些暂时不能运行的进程，目的是腾出内存装入更多进程，使CPU忙碌起来。 进程的创建与撤销 原语：机器指令构成的一种实现特定功能的小程序，它的运行具有不可分割性。 特点： 贴近底层 运行过程具有原子性（不可中断） 系统小程序 最重要的 进程控制用的原语：实现进程管理和状态切换 如：进程创建原语、进程撤销原语、阻塞原语、唤醒原语、进程挂起原语、进程激活原语、进程调度原语等。 进程创建原语何时调用创建原语： 批作业调度。 交互作业提交。 系统提供服务。 用户程序创建子进程。 进程撤销原语何时调用撤销原语： 进程自行终止。 用户或父进程的原因使进程终止。 运行超时而终止。 运行出错而终止。 进程阻塞原语Block()何时调用阻塞原语： 当正在运行的进程需要等待某一事件而发生运行受阻时，它通过中断请求系统服务。 系统按照进程的需求进行适当处理后，启动“进程阻塞原语”将该进程阻塞起来。 引起进程阻塞（运行受阻）的原因： 等待I/O请求 资源得不到满足 进程同步约束 服务进程无事可做 唤醒原语Wake_up()何时调用唤醒原语：当系统发生某一个事件时，正在等待该事件的进程需要立即被唤醒，由“阻塞”状态转为“就绪”状态。 流程： 将当前进程的上下文保存到系统栈中。 从阻塞队列上查找等待该事件的进程PCB将PCB从阻塞队列上摘下来。 将其状态置为“就绪”，将PCB挂入就绪队列。 弹出系统栈中的进程上下文，置入CPU，让被中断的进程恢复运行。 结束。 挂起原语 Suspend()何时调用挂起原语： 当前内存空间紧缺， 部分进程优先运行应用户的要求，将用户进程挂起 应父进程要求，将其子进程挂起 流程： 找到被挂起进程的PCB，获得其内存地址将内存空间归还给存储管理模块。 进程状态阻塞转为“挂起阻塞”，或者就绪转为为“挂起就绪”，将PCB从原队列转入相应队列。 申请外存交换区空间，换出进程，地址写入PCB。 结束。 激活原语Active()何时调用激活原语： 有进程运行完毕，当前内存空间并不紧张 应用户要求，将其进程激活 应父进程的要求，将其子进程激活 或者进程自身设定的挂起周期已完成 流程： 扫描“挂起就绪队列”找到被激活进程的PCB。 将PCB从所在队列上摘下来。 按PCB登记的空间需求，申请内存，加载到内存中。 归还外存交换区空间将进程状态置为“就绪”，插入就绪队列。 结束。 进程调度方式 从处于就绪状态的进程中，按照某种调度策略，选择个进程切换给CPU，使其状态从就绪转为运行，即为进程调度。 非抢占式调度当前进程主动放弃处理机控制权，可能的情况有： 进程运行完毕退出； 运行受阻 运行出错，非正常终止 遇到不可挽回的故障 抢占式调度也称作剥夺式调度，一般用于有实时需求的系统 主要指在系统正常运转期间，如果某种事件出现，系统将迫使正在运行的进程停下来，将CPU控制权交给其它进程。 其思想源自对高紧迫度作业的响应。 进程调度算法 批处理作业调度算法回顾： FCFS（ First come first serve）算法，先进入就绪队列的进程先调度 SPF（ Shortest process first）算法，最短进程优先调度。 HPF（ Highest Priority First）算法，最高优先级调度。 HRF（ Highest Response First）算法，最高响应比优先调度。 时间片轮转RR（ Round robin）算法 应用于分时系统，目标是提高响应及时性 基本思想：将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。 进程失去CPU不是自愿的，而是被系统剥夺的 轮转算法的启动时机 一个时间片运行结束； 当前进程运行结束； 或者正在运行的进程因运行受阻主动放弃了CPU控制权。 时间片的选取/确定通常有下面几个原则： 进程的道数较多时，q就选得小一些；反之可选得大些。 系统要求的响应时间比较苛刻的时候，q就选得小一些；反之，可选得大些 多队列调度算法 设置多个就绪队； 就绪队优先级不同，优先级高的队列优先调度； 优先级高的队列为空时，再调度低优先级队列。 多级队列反馈调度算法 多就绪队列组织形式 设置n个队列$Q_1，Q_2，……，Q_n$ 记$Q_i$的优先级为P，有$P1&gt;P2……&gt;P$ 记$Q_i$的时间片为$q_i$，有$q_1&gt;q_2&lt;……&lt;q_n$ 新建进程进入$Q_1$队。 只有$Q_i$为空时，才调度$Q_{i+1}$中的进程。 进程p在$Q_i$中被调度执行，若时间片q；已到但尚未结束，则进程p转为就绪状态进入$Q_{i+1}$队；进程p在$Q_n$中被调度执行，若时间片已到但尚未结束，则进程转为就绪状态仍入$Q_n$队。 这样的管理方式带来的结果： 终端型用户满意：终端型作业都是交互型的，比较短，进入第1队列后优先调度，一般只要一个小时间片就可完成。 短的批处理作业用户满意：短的批处理作业开始时首先进入第1个队列，能及时被响应。若轮转一周不能完成的话，通常只需在第2乃至第3队列上各执行一个时间片就可能完成，作业的周转时间仍比较短。 长的批处理作业用户满意：个长的批处理作业进入系统后，将依此在第1，2，…，n-1队列中各运行一个时间片，最后进入第n队列进行轮转运行，一般不必担心“受冷落”现象发生。一旦进入后面的就绪队，获得的时间片比较长，系统调度开销比较少 实时任务调度 实时任务是一类对时间要求较为严格的进程支持这类任务运行的系统称为实时处理系统。 硬实时系统：有严格的时间控制 软实时系统：有时间需求，但没有严格的deadline，尽快完成即可 非周期实时任务的分类及其调度方法 紧迫型实时任务调度 紧迫性强的任务多见于一些专用的、响应时间要求特别苛刻的数据采集和控制系统中，所要求的响应时间很短，一般是微秒量级的。 解决的方法是采用立即抢占的最高优先级(HPF)调度算法。 进程调度每次将处理机分配给具有最高优先级的就绪进程。 最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法 普通型的实时任务调度 目前，大多数自动控制系统对响应时间的要求都不是太高，一般是毫秒量级的。由于它允许的响应时间长度与时钟中断的周期基本吻合。 采用“基于时钟中断抢占的高优先级调度”算法。 宽松型的实时任务调度 非抢占的HPF调度算法 RR算法 特殊的—周期性实时任务 信号检测和过程控制系统中呈现周期性运行规律的任务。 周期任务A第次运行前的剩余时间$F_A(i)$是 $$F_A(i)=i·T_A-T_{sA}-t$$ $T_A$为任务A的周期长度；$T_{sA}$为任务A的每次执行时间长度； $t$为系统的当前时间。 周期性任务可采用SRT（最小剩余时间）调度算法 线程的引入 线程是现代操作系统引入的一种执行实体 线程称“轻型进程”，是进程的组成部分 进程是资源占有单位，线程只是CPU调度单位 一个进程运行过程中可创建多个线程，线程共享所属进程的资源，自己只有TCB和很少的栈区 线程分内核级线程KLT和应用级线程ULT 进程与线程的区别 进程是个独立的实体单位： 独立占有资源：进程拥有对资源的控制权或所有权。 独立参与调度/执行：进程是一个可被操作系统调度和分派的单位。 线程仅是分派（调度运行）的单位： 线程不是单独占有资源的单位。 线程共享其所属进程的资源。 处理机的调度层次调度的主要目标—一选择哪个实体进入内存、选择哪个实体占用CPU。 调度的主要层次 作业调度 中级调度 进程调度 线程调度 典型的三级调度作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度。 高级调度：又称作业调度、长程调度。从处于后备状态的作业中选择一道或者几道，装入内存。 中级调度：又称中程调度。优先从处于挂起就绪状态的进程中选择一个或者几个，将之激活。 低级调度：又称进程调度、短程调度。从处于就绪状态的进程中选择一个，切换给CPU执行。 根据不同系统的情况： 有的系统三级调度都有 有的系统有高级调度和低级调度 有的系统有中级调度和低级调度 有的系统只有低级调度 有的系统加了一级线程调度 线程调度 线程称“轻型进程”，是进程的组成部分 进程是资源占有单位，线程是CPU调度单位 线程共享所属进程的资源 线程分为用户级线程和内核级线程，调度方式不同 用户级线程的调度 操作系统进行进程调度 用户进程自己进行线程调度 内核级线程：操作系统直接进行线程调度 线程调度与子进程调度的区别图示以用户级线程调度为例 采用线程调度：CPU切换时开销较少 进程的并发控制互斥、同步与并发的区别互斥 只要不同时使用即可，谁先用谁后用没有约束——此之谓“互斥” 互斥体现进程间竞争关系 同步 不但不能同时用，谁先用谁后用也有严格约束——此之谓“同步” 同步—体现进程间协作关系 并发(Concurrency)并发的基本概念 单处理器多道程序设计系统中，多个进程交替执行 多个并发进程在一个时间段内都处于运行状态 共享系统资源 每个进程都“走走停停” 并发带来异步性 并发带来的问题 并发进程的相对执行速度是不可预测的，取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。 有可能发生各种与时间有关的错误。 与并发相关的关键术语 临界资源(Critical resources) 也叫互斥资源 一种一次只能为一个进程服务的共享资源 如“存款额”、 Buffer块 临界区(Critical Section) 进程体中使用临界资源的代码段 使用同一临界资源的不同的代码段叫做相关临界区 当一个进程已经在临界区中运行时，也就是已经在使用临界资源了，其它进程不能进入相关临界区 互斥(Mutual Exclusion) 当一个进程在临界区访问临界资源时，其他进程不能进入相关临界区访问该资源 临界资源一个时刻只允许一个进程使用 进程使用该临界资源的顺序没有约束 体现竞争关系 同步(Synchronization) 不但不能同时使用临界资源，还得有严格的使用的先后顺序 体现协作关系 死锁(Dead lock) 两个或两个以上的进程，因其中的每个进程都在等待其他进程做完某些事情而不能继续执行，所有进程都阻塞等待，而且永远阻塞等待 活锁(Live lock) 两个或两个以上进程为了响应其他进程中的变化而持续改变自己的状态，但不做有用的工作 饥饿(Starvation) 一个可运行的进程被调度程序无限期地忽略，不能被调度执行的情形。 原子操作(Primitive) 保证指令序列要么作为一个组来执行，要么都不执行 操作系统在管理和控制资源分配与使用方面，应当保证进程对临界资源的访问满足以下3点： 互斥访问要求。 不致于产生“死锁” 不能有“饥饿”进程 解决进程同步和互斥的方法 互斥管理准则： 空闲让进、忙则等待、有限等待、让权等待 软件方法软件方法解决互斥问题失败的原因： 临界区前后所加代码越多，执行过程随时被打断的情况越多 所加代码中的turn、Fag[1]、Flag[2]本身也是临界资源 没有考虑让权等待 硬件方法信号量机制 基本原理： 两个或多个进程通过简单的信号进行合作。 任何复杂的合作需求都可以通过适当的信号结构得到满足。 实现要素： 信号量（Semaphore类型，内含一个阻塞队列） P操作原语（wait） V操作原语（signal） 一个记录型信号量包含两个分量： 信号量的值、信号量的等待队列指针 P(s) V(s) s.value = s.value -1;if s.value &lt; 0then block(s.L); s.value = s.value +1;if s.value &lt;= 0then wakeup(s.L); 用于进临界区之前检查资源 当临界资源被其他进程占用时，就将自己阻塞 具有“阻塞”功能 解决互斥问题 解决同步问题 一种CR设一个信号量信号量的初值设置为系统初始状态CR的可用量P操作用于临界区前，相当于进入CS之前申请CRV操作用于临界区后，相当于出临界区后释放CRP、V操作必须成对匹配 一种同步信号设一个信号量信号量的初值设置为系统初始状态下信号的有无P操作用于临界区前，相当于检査同步信号V操作用于临界区后，相当于发出同步信号P、V操作不成对匹配 互斥、同步解决方法的异同分析： 信号量的设置 信号量的初值 P操作的含义 V操作的含义 P、V操作是否匹配 记录型信号量机制解决问题的步骤： 分析问题中的进程、资源；分析进程间关系； 分别设置互斥、同步信号量； 写出并发进程体，找出相关CS(临界区)； 分别加PV操作并分析结果。 管程机制(暂无) 生产者-消费者问题 经典生产者消费者问题： 系统里有若干个合作的进程互斥使用由$r（r&gt;0）$个缓冲块组成的缓冲块环，其中n（n&gt;0）个生产者进程，$m（m&gt;0）$个消费者进程。任何一个生产者进程都可以将自己的产品存入环内的一个缓冲块中；任何一个消费者可以将环内的一个产品取出。生产者源源不断生产并存入产品：消费者周而复始地从环内取出产品并消费掉。 假定使用的约束条件是： 当环中有空闲缓冲块时，允许任一生产者进程把它的产品存入。当环中无空闲缓冲块时，则试图将产品存入缓冲区环的任何生产者进程必须阻塞等待。当环中尚有未取出的产品时，允许任一个消费者进程把其中的一个产品取出。当环中没有未取出的产品时，试图从该环内取出产品的任何消费者进程必须阻塞等待。 环上设有存入指针和读取指针，都按顺时针方向移动。 *当同步问题的临界区和互斥问题的临界区重合时，应该做到同步在外、互斥在内：消费者先判断buffer环是否可取，在可取的情况下再竞争buffer环的使用权；消费完后先释放buffer环，再向生产者发出可放入信号。 例1 三个进程：输入、计算、输出 进程关系分析：P1与P2同步，P2与P3同步 $B_1$可放入——Sin1，初值1 $B_1$可取——Sout1，初值0 $B_2$可放入——Sin2，初值1 $B_2$可取——Sout2，初值0 进程体$P_1$： 准备初始数据——发出同步信号P(Sin1)——将初始数据放入$B_1$——发出同步信号V(Sout1) 进程体$P_2$： 发出同步信号P(Sout1)——从$B_1$中取出初始数据——发出同步信号V(Sin)——计算——发出同步信号P(Sin2)——将结果放入$B_2$——发出同步信号V(Sout2) 进程体$P_3$： 发出同步信号P(Sout2)——从$B_2$中取出结果——发出同步信号V(Sin2)——输出 例2 三组进程Producer、ConsumerOdd、ConsumerEven互斥使用一个包含N个单元的缓冲区。生产组每次用produce()生成一个正整数，并用put()送入缓冲区某一空单元中；奇数消费组每次用geode()从该缓冲区中取出一个奇数，并用counted()统计奇数个数；偶数消费组每次用geteven()从该缓冲区中取出一个偶数，并用counteven()统计偶数个数。 请用信号量机制实现这三组进程的同步与互斥活动，要求用伪代码描述，并说明所定义信号量的含义。 （研究生入学统考真题） 分析： 题目中显然有三组进程，这三组进程互斥使用一个buffer环，关键在于实现互斥；根据互斥原则，有几种互斥资源，就设几个互斥信号。这里的互斥资源就是包含N个单元的缓冲区，因此互斥信号量设置一个即可。 初值按照该缓冲区里边缓冲块的个数N来设置 题目中存在1组生产者，2组消费者，因此存在同步关系 总结 记录型信号量机制解决问题之步骤总结 分析问题中的进程、资源 分析进程间关系 分别设置互斥、同步信号量 写出并发进程体，找出相关CS 分别加PV操作并分析 读者-写者问题 问题描述：有一个数据块被多个用户共享，其中一部分用户是读者，另一部分是写者。 规定：读者对数据块是只读的，而且允许多个读者同时读；写者对数据块是只写的，当一个写者正在向数据块写信息的时候，不允许其他用户使用，无论读还是写。 分析 谁是进程：读者、写者——两组进程 谁是资源：数据块——临界资源 进程之间的关系： 写者 写者跟任何一个其它的进程都互斥 为数据块设互斥信号量mutex 读者 读者与读者不互斥 读者组跟写者互斥 第一个来的读者申请资源 最后一个走的读者释放资源 加一个读者计数的变量counter，成为读者们互斥的资源，为counter设置一个互斥信号量Rmutex 总结 mutex是为数据块设置的互斥信号量，用于： 写者跟任何一个其它的进程都互斥 读者组与写者互斥 Rmutex是为counter设置的互斥信号量，用于： 读者间互斥使用counter 理发师问题 问题描述： 有一位理发师，一把理发椅和n把供等候理发的顾客坐的等候椅。如果没有顾客，理发师便在理发椅子上睡觉；当一个顾客到来时，唤醒理发师进行理发。如果理发师正在理发时又有新顾客到来，有空椅子可坐，他就坐下来等，如果没有空椅子，就立即离开。 规定：要求为理发师和顾客各编一段并发程序描述他们的行为，解决其中的同步互斥问题。 分析 进程——理发师、顾客 资源——理发椅、等候椅 围绕理发椅——理发师与顾客：同步 围绕等候椅——顾客与顾客：互斥 设置同步信号量 设置同步信号量 考虑设一变量chairs，记录等候椅剩余数量。顾客来了检查chairs，若为0，则离开（结束进程）；若 $chairs&gt;0，chairs=chairs-1$，坐下等 变量chairs是临界资源，顾客进程之间互斥使用chair 为chairs设一互斥信号量mutex初值为1 总结 需要设计两个进程体：顾客进程Customer()、理发师进程Barber() 定义四个同步信号量coming、calling、cutting和finished实现理发师与顾客之间的同步 定义信号量mutex实现顾客间对chairs的互斥 哲学家就餐问题 问题描述： 5位哲学家围桌而坐，每人面前盘面，两人中间各放一根筷子哲学家生活方式单调：思考一饥饿一用餐-再思考 已知每个人必须左右手各拿到根筷子才可以开始进餐。 分析 进程——5个哲学家 资源 桌子——可同时共享 面条——独占，不需共享 椅子——独占，不需共享 筷子——互斥共享（临界资源） 围绕理发椅——理发师与顾客：同步 围绕等候椅——顾客与顾客：互斥 算法存在的问题 若5位哲学家恰好都饿了，一起去拿筷子，恰好都先拿起了自己左边的那根筷子。 每位哲学家都拿不到右边的筷子，而阻塞等待，而且永远等待下去，这就叫“死锁”。 让哲学家互斥使用筷子，但不发生死锁 解决方法1：限制最多4个人同时吃面。 实现方法：加一个临界资源——吃面名额 解决方法2：将椅子统一编号，让奇数号椅子上的哲学家饥饿时先拿左筷子，偶数号椅子上的先拿右筷子。 解决方法3：哲学家饥饿要吃面时，要么两根筷子起拿，要么一根也不拿。 需要设计一种新的信号量机制——信号量集机制 用一个P操作，可以同时申请到两个或多个临界资源 用一个V操作，可以释放两个或多个临界资源 管程机制解决生产者-消费者问题管程(Monitor) 管程是由局部数据结构、多个处理过程和一套初始化代码组成的模块 这是一种具有面向对象程序设计思想的同步机制。 它提供了与信号量机制相同的功能。 管程特征 管程内的数据结构只能被管程内的过程访问，任何外部访问都是不允许的 进程可通过调用管程的一个过程进入管程 任何时间只允许一个进程进入管程，其他要求进入管程的进程统统被阻塞到等待管程的队列上 管程机制的要素 条件变量c(Condition类型)：关联一个阻塞队列 P(c)：当遇到同步约束，将执行P(c)操作的进程阻塞在条件变量c关联的阻塞队列上。 V(c)：从条件变量c关联的阻塞队列上唤醒一个进程，让它恢复运行。若队列上没有进程在等待，就什么也不做。 管程设计与应用示例 设计一个管程：解决生产者-消费者问题 定义为一个数组buffer：表示用于传递产品的缓冲区环。 定义局部变量in,out：表示在缓冲区环中生产者放的位置、消费者取的位置。 定义变量counter：记录缓冲区环中产品的数量。 设计条件变量 定义full：生产者的条件变量。 当一个试图存放产品的生产者发现缓冲区环已满时，执行P(full)将之阻塞到full关联队列上。 定义empty：消费者的条件变量。当一个试图取产品的消费者发现缓冲区环已空时，将执行P(empty)将该消费者阻塞到 empty的关联队列上 设计管程的过程 PUT()：实现产品的存入。 Porcedure PUT(item:char) GET()：实现产品的取出。 Porcedure Get(item:char) 死锁的发生与描述死锁的危害 陷入死锁圈的进程无限期阻塞等待 陷入死锁圈的资源被浪费 更多进程卷入死锁 甚至系统死机 分析 产生死锁的原因 动态资源分配策略 资源可用数量少于需求数量 进程并发过程的偶然因素 因有偶然性，所以无法给出死锁产生的充分条件 死锁产生的4个必要条件 互斥条件：进程请求的资源属于临界资源，每一瞬间只能由一个进程使用，其它申请该资源的进程等待。 不可剥夺条件：进程获得某资源后，便一直占有它，直到用完为止才可以释放，其它进程不可以剥夺。 请求和保持条件：允许一个进程在保持已有资源不放弃的情况下，进一步请求新资源，被阻塞时也不会释放已占有的资源。 环路等待条件：组进程{$P_1,…,P_n$}的占有资源情况与请求资源情况构成了一个环型链，比如$P_1$等待$P_2$的资源，$P_2$等待$P_3$的资源，$P_n$等待P1的资源。 死锁的解决方法 事前处理：针对性采取措施，让死锁没有机会发生 事后处理：及时检测、及时解除 死锁预防与死锁避免的区别 死锁预防 在资源分配策略上做限制，让死锁根本没有机会发生。 死锁避免 在每个进程的每次提出动态资源申请时，加设“银行家算法”以决定是否满足该请求 死锁的预防目的：采取预防措施，让死锁没有机会发生 从死锁产生的原因入手： 因为死锁产生有偶然性因素——方案不可行 从死锁产生的4个必要条件入手，破坏其中的一个或几个必要条件——方案可行 能否破坏 死锁产生的4个必要条件 互斥条件：互斥共享资源不能改成同时共享，破坏该条件行不通 不可剥夺条件：互斥共享资源被剥夺以后，进程需要重新执行，破坏该条件行不通 请求和保持条件：进程运行整个过程中所需资源要申请就一次性全部申请，要不就不申请 静态资源分配策略 动态资源分配策略： 需要时动态申请 使用完动态释放 优点：进程一定不会发生死锁缺点：资源有效利用率会降低进程并发推进的速度会降低 环路等待条件：给资源排一个序号，按照从小到大或从大到小的顺序申请资源 按序资源分配策略 采用按序资源分配策略，资源使用效率会高于静态资源分配策略。 但是不适用于开放性系统 静态资源分配策略 与 按序资源分配策略 的共同点： 在资源分配策略上做限制，让死锁根本没有机会发生 在资源利用率上都有所牺牲 死锁的避免前提：采用动态资源分配策略 措施：对每个进程的每次动态资源请求，加设“银行家算法”以决定是否满足该请求 银行家的基本思路 银行家拥有一笔周转资金，客户申请贷款 检查客户信用，了解客户投资前景，判断有无出现呆账坏账的危险 确无危险，才贷出 银行家与操作系统类比 操作系统（银行家） 操作系统管理的资源（周转资金） 进程（要求贷款的客户） 操作系统的思路 前提 采用动态资源分配策略 银行家算法每个进程提出资源申请时，加上一道检查 主要思想：动态检测资源分配，以确保系统一直处于安全状态 结论： 安全状态不是死锁状态 安全状态是没有死锁危险的状态 死锁状态是不安全状态 不是所有不安全状态都是死锁状态 存储管理概述 存储管理的管理目标 内存的合理分配使用 提高内存利用率 程序、数据在内存中顺利读写 小内存运行大程序 内存管理主要功能 内存的分配和回收 合理分配 及时回收 实现技术：数据结构 主存分配算法 主存分配算法 地址重定位（地址转换） 实现目标：将逻辑地址转换成物理地址 物理地址 存储单元的实际物理单元地址。 逻辑地址 用户空间中使用的相对地址。 静态重定位 地址转换工作在进程执行前一次完成。 无须硬件支持，易于实现，但不允许程序在执行过程中移动。 动态重定位 地址转换推迟到最后的可能时刻，即进程执行时才成 允许程序在主存中移动，便于主存共存，主存利用率高。 地址共享和保护：多道程序环境中，多个用户作业均使用内存空间，为提高内存利用率，应该对内存空间实现共享。 共享： 共享内存储器资源，让多个进程同时进入内存区域，共享同一个存储器； 共享内存储器的某些区域，即允许两个或多个进程访问内存中的同一段程序或数据。 地址保护： 用户进程不能访问或修改系统区 用户进程不能访间或修改其他进程的用户区 地址扩充 内存容量是有限的，当内存资源不能满足用户作业需求时，就需要对内存进行扩充 内存扩充不是硬件上的扩充，而是用存储管理软件来实现 覆盖技术 对换技术 虚拟存储技术 存储管理方法连续存储管理 单一连续区方式 内存用户区的全部空间只存放一个进程。 多分区方式 内存被分为多个分区，每个分区存放一个进程。 固定多分区 动态多分区 非连续存储管理 分页方式 内存被划分为多个等长的存储块，每个进程占用其中的若干块，整个内存允许有多个进程同时驻留。 多段方式 对分段结构的应用程序，按照段长度分别为之分配内存空间。 段页方式 在分段式管理的基础上加上分页式管理可形成段页式管理。 地址重定位（地址转换）实现目标：将逻辑地址转换成物理地址 物理地址：存储单元的实际物理单元地址 逻辑地址：用户空间中使用的一种地址 程序的编译、链接、装载和执行 数据结构与主存分配算法常用的数据结构主存分配表MAT(Memory Allocation Table) 分区号：每个分区都有一个编号，用以区别不同分区。 起始地址：分区的起始地址，即首地址。 长度：分区的总长，一般以KB为单位。 占用标志：记录分区的使用状态。若占用标志为0，表明该分区为空闲，可以进行分配。 例表： 分区号 起始地址 长度 占用标志 0 4KB 6KB 未分 1 10KB 2KB 已分 2 12KB 15KB 已分 3 27KB 34KB 未分 … … … … 此表若很长，则需要很大的时间开销 空闲区表/链 是MAT表的一类子表 记录内存空闲区状况的数据结构 有空闲区链中各空闲区可按地址顺序来排列，也可按尺寸大小来组织。 当系统进行内存时，进行的处理是： 通过空闲区链，快速搜索内存的空闲区 从中找出最合适的分区分配出去 将该结点从链上删除 当需要某块被释放的区域时，系统处理过程为 按其地址或者大小在链中找到合适的位置 插入一个新结点 若存在相邻的空闲区，则需要的话可将相邻空闲区合并 主存分配算法首次适应算法(First_Fit) 首次适应算法也称为最早适应算法。系统将内存分区按地址递增顺序登记到内存分配表（或其它数据结构）中。每次进行内存分配时，系统根据进程申请空间的大小，从头到尾顺序扫描内存分配表（或空闲分区表），从中找到的第1块能够满足要求的空闲区，就立即分配出去 循环首次适应算法(Circle_First_Fit) 该算法的思想是，每次存储分配总是从上次分配的位置开始，向尾部查找。查到的第1块可满足用户需求的空闲空间，分配给用户。当查到MAT（或空闲链表）的尾部仍然没有合适的，转到头部继续。 最佳适应算法(Best_Fit) 在内存分配时，从空闲区表中找到一块满足进程需求白最小空闲区分配给它。这种做法减少了将大空闲区进行多次分割造成的空间浪费。但容易形成一些很小的碎片无法使用，同样不能提高内存利用率。另外，每次分配时，都要对整个内存区进行从头到尾的搜索，系统开销较大。 最坏适应算法(Worst_Fit) 在进行内存分配时，从空闲区表中找到一个满足长度求的最大空闲区进行分配。这种算法部分地缓解了由外碎片引起的浪费，适合于中小作业的运行，但对大作业的运行是不利的。与最佳适应算法一样，每次分配需要搜索一遍内存，效率会受到定影响。 连续分区存储管理 单分区存储管理、固定多分区存储管理、动态多分区存储管理（可变分区），都属于连续分区存储管理。 单分区存储管理基本原理：把内存的用户区视为一个独立的连续存储区，任何时刻只将它分配给一个作业使用。 这种存储管理非常简单，适用于单用户单任务系统（如，MS-DOS操作系统的早期版本）。 缺点： CPU的利用率不高、外设利用率较低：因为任何时刻最多只有一个程序独占内存，无论在该程序执行过程中，还是CPU等待IO时都不能让其他用户使用。 内存空间浪费严重：进入系统运行的作业所要求的存储空间较小时，剩余较大的空白区未被利用，只能白白浪费。 固定多分区存储管理 基本原理：将内存用户区划分成多个大小相等或不等的固定分区，每一个分区可以装入一个进程。这样，内存中可同时容纳若干个进程。 MAT表可以用静态数组实现 固定分区方案可能出现的问题： 分区大小可以相等，也可以不等 每个分区的越始地址和长度是固定的 大的进程无法装入 小进程装入大分区出现内碎片 内碎片：指的是进程获得的空间大于需求的空间时，多出来的空闲区。 内碎片的产生降低了内存的有效利用率 如何减少内碎片现象： 采用Best_Fit算法 采用静态重定位 地址保护：采用合适的寄存器 固定分区方案的缺陷： 分区的数目在系统生成阶段已经确定，限制了系统中活动进程的数目 分区大小在系统生成阶段事先设置，大作业有可能无法装入，小作业不能有效地利用分区空间。 “内碎片”现象降低了内存有效利用率。 动态多分区存储管理 基本原理：系统不预先划分固定分区，而是在装入进程时，根据进程的实际需求量划分出一个分区给它使用。 MAT表需要用动态数组实现 动态分区分配算法的描述 从头到尾扫描内存分配表，找到一个能满足需求的空闲分区$MAT_i$ 若$MAT_i$（长度）=L，则：$MAT_i$（占用标志）“已分”，转（4） 若$MAT_i$（长度）&gt;L，则： $L_0$=$MAT_i$（长度）-L $MAT_i$（长度）=L；$MAT_i$（占用标志）=“已分” 在内存分配表的下一个位置插入新行$MAT_{i+1}$ $MAT_{i+1}$（起始地址）=$MAT_i$（起始地址）+L $MAT_i$（长度）=$L_0$ $MAT_{i+1}$（占用标志）=“未分” 结束。 动态分区分配示例 外碎片：指的是在使用动态多分区管理方法时，形成的的、因为太小不容易被分配利用的小的空闲区 如何消除外碎片： 除了Best_Fit算法，另外三种算法都有使用价值 主存分配过程中，通过程序浮动将不相邻的空闲区移为相邻的进行合并。 回收过程中，相邻空闲区进行合并。 基本分页存储管理 基本原理 内存被划分成大小固定相等的块（ Frame帧、页框、主存块），且块相对比较小。 每个进程装入时被分成同样大小的页（Page），一页装入一帧 整个进程被离散装入到多个不连续的帧 页面长度页面的尺寸（页面长度）由计算机系统的硬件决定。 对于某台具体的机器来说，只能规定一种尺 目前流行的页面尺寸是1KB到4KB之间，但也有一些机器不在此范围内 比如，小型机 IBM AS400的页面尺寸为512个字节 记录内存使用情况的数据结构 位示图：整个系统一张，记录内存使用情况 0表示空闲，1表示被占用 $_i\\backslash ^j$ 第0位 第1位 第2位 第3位 第4位 第5位 第6位 第7位 第0个字 0 0 0 1 1 1 1 0 第1个字 0 1 1 0 0 0 1 0 第2个字 1 0 0 1 1 0 1 1 …… … … … … … … … … 第n个字 0 0 0 0 0 0 0 0 设字号$i$、位号$j$、帧号$k$取值均从0开始，字长记为L 分配时，查位示图，找空闲帧：$k=i*L+j$ 回收时，$i=(k/L) $//整除 $j= k\\space MOD\\space L$ //取余 由帧号可知位示图中字号和位号 页面分配算法 计算请求者需要的总帧数N 查位图，若找不到足够的空闲帧，编制“分配失败”报告返回 索取一个空闲页表PT 从位图中找出N个为0位，计算出对应的帧号，填入PT 位示图中将这些位改为1 将PT起始地址填入进程的PCB中 结束 地址划分进程装入之前，逻辑地址是一维的 进程装入之后，逻辑地址分为二维 高端地址部分：作为页号 低端地址部分：作为页内的偏移量（即页内地址） 例：若机器的地址码是16位，页面长度是1KB 则地址划分结果：低10位是页内地址，高6位是页号 6位 10位 页号 页内地址 这样的地址结构，允许一个进程的页面总数达$2^6=64$页 地址重定位 地址保护 总结 离散存储，利于大进程装入 只有很少的页内碎片，提高内存利用率 Ds：位示图、页表；动态地址重定位 页面共享不易实现定位页面共享不易实现 基本分段存储管理 基本原理 进程的程序和其相关的数据按逻辑分段 段有一个最大长度限制，但不要求所有程序的所有段的长度都相等 一段占用一块连续存储区 各段占用不连续分区 “段”是一个逻辑单位，是进程的一个组成部分如主程序段、子程序段、数据段等 在结构程序设计中，进程自然分段。 用户源程序使用的符号地址是二维的：&lt;段名，变量名&gt; 编译之后的逻辑地址是二维的：&lt;段号，段内偏移&gt; 进程按逻辑分段 在分段机制中，一个进程的地址空间可以包含以下不同的段： 代码段（ Code segment） 数据段（ Data segment） 堆栈段（ Stack Segment） 内存共享段（ Share Memory Segment）等 包含3个段的进程 例如，一个进程P包括3个程序段：Main（主段）、Sub1（子段1）和Sub2（子段2）。 甚至有专门的“共享段” 图给出各个段之间的调用关系 记录内存使用情况的数据结构 MAT 空闲分区表/链 !&gt; 这里用的MAT表与动态多分区中MAT表的有何异同？ 相同点 不同点 MAT的一个表项，对应内存一个分区 - 动态多分区中，一个分区存放一整个进程- 分段存储中，一个分区存放进程的一个段。一个进程离散成多个段装入多个不连续的分区 记录各个进程分段情况的数据结构段表ST（ Segment Table）为每个进程设置一张段表，用来记录各个段地址映射的关系 进程分了几段，段表就有几个表项。个表项记录一个分段在内存空间中的存储地址和长度。 段表示例： 地址重定位程序运行中的地址变换过程如下： 提取逻辑地址中的“段号” 比较段号与段表控制寄存器中的段长度。如果超出段表长度，则返回“内存定位错误”，终止进程的运行 从段表控制寄存器中给出的段表首址开始，以段号为索引査找该进程对应的段表，得到欲访问段的首地址。 取出欲访问段的首地址，加上逻辑地址中的偏移量得到物理地址。 分段保护 第一级保护是防止进程发生超出存储空间的访问； 第二级保护是阻止进程超出访问权限的读写。 分段保护的具体保护分为以下三个步骤 分段共享 段面共享 如果多个用户进程需要共享内存中的某些代码段或数据段时可将内存中共享段的起始地址及长度，填入这些进程的段表当中，就可共享一个逻辑上完整的段信息了。 共享段表SST 为了实现段的共享，系统设一个“共享段表”（SST, Sharing Segment Table） 记载各个共享段的使用情况任何一个进程调用共享段时，系统都将访问该表 总结 离散存储，一段连续装，各段不连续 内存仍然按分区管理，会产生外碎片 DS：MAT、段表；动态地址重定位 分段共享非常方便 基本段页式存储管理 把分页和分段两者结合起来就是段页式存储管理。 内存划分成大小相等的页框。 用户的地址空间被程序员划分成许多段，每个段一次划分成许多固定大小的页，页的长度等于内存中的页框大小。 分页与分段 分页： 分页存储利于大进程裝入，内存利用率高； 但是，页是物理页，页面共享不易实现。 分段： 段是逻辑段，方便实现分段共享； 但是，外碎片的存在降低内存使用效率 且整理消除外碎片加大系统开销 数据结构 系统设一张位示图，记录内存各帧占用与否 系统为一个含有多分段的进程建立段表，记录各个分段对应段内页表的地址和长度 一个分段有一个段内页表，记录该段划分为多少页每页分配的帧号是多少 $$段表和段内页表$$ 地址形式系统的硬件支持是，在处理机内部设有段表控制寄存器及地址生成逻辑 程序中的逻辑地址仍然是二维地址：&lt;段号，偏移量&gt; 每段装入时分页，地址部分被当作三维地址来处理：&lt;段号，页号，页内偏移&gt; 段页式地址重定位 段页式地址保护 段页式地址字结构的计算比如一个32位地址字，已知系统设定页面长度为4KB，段的长度为64KB 则地址划分如下： 段号 页号 页内地址 31-16 15-12 11-0 页面长度为4KB($2^{12}$)，因此页内地址需要12个二进制位。 段的长度为64KB，页面长度为4KB，因此一个段包含了$64÷4=16(2^4)$个页，因此页号需要4个二进制位。 于是，页内需12位，每段分16页，段内页号需4位，剩余16位为段号。 多级页表及相关计算一级页表结构若页面长度为4KB，每个页表项占用4B，则意味着: 帧里最多能存放4KB÷4B=1K个页表项 二级页表结构二级页表地址形式 外层页号 内层页号 页内偏移 如果二级的页表也必须用多个帧来存放，那就需要建立更高一级的页表：多级页表 多级页表结构计算：一个由32位二进制组成的地址空间，页面长度为4KB，每个页表项占用4B，则： 进程的页面总数可达$2^{20}=1M$个 整个页表最大占用4MB 页号：31-16 页内地址：11-0 一个帧只有4KB，所以4MB的页表需要离散存放需要占用4MB/4KB=1K个帧。 这就需要如果建立更高一级的页表，记录页表所占帧号，叫做“页表的页表”：两级页表 相关计算一个由32位二进制组成的地址空间，页面长度为4KB，每个页表项占用4B，则： 采用一级页表机制，所允许的进程的最大长度是（$2^{20}×4KB$） 页号 页内地址 31-16 11-0 采用两级级页表机制，所允许的进程的最大长度是（$2^a×2^b×2^c B$） 外层页号 内层页号 页内偏移 c b c 一个由32位二进制组成的地址空间，页面长度为4KB，每个页表项占用4B，请问地址字结构 因页面长度为4KB，所以页内偏移占12位； 余下20位对应页号，所以进程的页面总数可达1M个； 整个页表占用4MB，这4MB又划分为18个页面 一个页面正好可存放1K个页表项； 所以，为了查找这1K个页面，两级页表结构就够了。即：外层页号和内层页号各占10位，偏移量占12位 多级页表机制的地址重定位过程处理机中要设有外部页表寄存器，存放当前进程的外部页表首地址。 系统根据指令给出的逻辑地址： 用逻辑地址中的外层页号a查外层页表，得到内层页表首地址。 用逻辑地址中的内层页号b查内层页表，得到数据帧号 将数据帧的首地址加上偏移地址c得到物理地址。 与快表有关的计算 在一般的分页管理系统中，处理机每次读出/写入一个数据，需要访问（2）次内存；而在分区存储管理系统中，需要访问（1）次内存。 在一般的分页管理系统中，执行一条一地址指令，需要访问（2）次内存；执行一条三地址指令，需要访问（6）次内存。 解析： $$分页存储管理系统$$ $$分区存储管理系统$$ 提高地址转换速度一快表 存储在高速缓存 内容为页表中最近使用的页表项 引入快表之后的地址变换过程对于CPU给出的一个逻辑地址&lt;页号P，偏移量W&gt; 硬件逻辑中，将逻辑地址中的页号P送入高速缓存，与快表中的所有页号进行比较。若找到相匹配的页号，读出该页面对应的帧号，与偏移量W合成一个物理地址。 若在快表中没有找到，系统需要再访问内存中的页表。在页表中找到该页的帧号，与偏移量w共同合成访问内存的物理地址 同时，系统自动更新快表。快表中总是存放那些刚刚访问过的页表项。 有效访存时间的计算$有效访存时间=地址转换时间+读写一个页面的时间$ 地址转换时间：访问一次快表或者页表的时间 读写一个页面的时间：访问一次内存的时间 访问一次快表的时间，即访问一次快存的时间 访问一次页表的时间，即访问一次内存的时间 设一次快存访问时间为t1，一次内存访问时间为t2 如果査询快表能找到所用的页，我们称作命中。此时的有效访存时间t为$t=t_1+t_2$ 如果查询快表没有找到所用的页，称作没有命中此时的有效访存时间t将是：$t=t_1+2t_2$ 一般地，当查询快表的命中率为p，则平均内存有效访问时间T大约为： $T=p×(t_1+t_2)+(1-p)×(t_1+2t_2)$ 例题：假设一个分页存储系统具有快表，已知内存访问时间是1us，快表的访问时间为01us。若快表命中率是85%，则有效存取时间为多少？ $$\\begin{split}T&amp;=p×(t_1+t_2)+(1-p)×(t_1+2t_2)\\\\&amp;=85%×(0.1+1)+(1-85%)×(0.1+2×1)\\end{split}$$ 实际系统引入快表之后的地址变换示意图 虚拟存储管理概述 主存扩充技术实质目的：将小的实存储器（实存）扩充为大的虚存储器（虚存） 实质：将磁盘空间虚拟成内存使用 结果：将进程的一部分装入内存，即可运行 局部性原理时间局部性：最近访问过的程序代码和数据很快又被访问。 空间局部性：某存储单元被使用之后，其相邻的存储单元也很快被使用。 程序在执行过程中的一个较短时间内，所执行的指令地址或操作数地址分别局限于一定的存储区域中。 覆盖技术程序运行过程中，在不同时刻把同一存储区分配给不同程序段或数据段，实现存储区共享的一种内存分配技术。 覆盖技术通常与单一连续区分配、固定多分区分配和动态分区分配等存储管理技术配合使用。 每一个用户程序被分为若干段： 非覆盖段—一部分是经常要用的基本部分，作为常驻段 可覆盖段一另一部分不经常使用，可以让它们在需要时临时装入。不同时使用的段可组为一组可覆盖段。 交换(Swap)技术将内存中某进程暂时不用的程序和数据全部或部分）写入外存交换区中，腾出来的内存空间供其它进程使用。待需要时或内存有空闲空间时，再将它从外存交换区装入内存 交换技术实现要点磁盘上设置“磁盘交换区” 磁盘交换区是一个数据的暂存处。系统可根据内存的“拥挤”程度将信息调往交换区或者从交换区调入 文件区和交换区的区别操作系统管理下磁盘空间被划分为：文件区和交换区。 !&gt;存储方式不同：文件区信息以文件形式存放，为了提高空间利用率，一般采取离散存储方式；而交换区信息按字符流方式存放，多采用连续存储方式 !&gt;访问速度不同：文件区存储空间特别大，为了提高检索效率一般通过建立目录对文件实现访问，也就是间接地址访问；而交换区空间较小，可按外存地址直接访问，因此访问速度快。 !&gt;存储时间不同：文件区适合于较长久的数据存储；而交换区作为临时数据的存放处，只存放短期的数据。 交换技术的应用交换整个作业——用于单道系统（单道模拟多道） 交换整个进程——用于连续分区存储管理（进程挂起、激活，中级调度） 交换页面/段面——用于分页、分段存储管理（此即为虚拟存储技术） 虚拟存储技术一个进程运行时，可不必将其全部装载到内存中只须把当前运行的部分程序和可能访问的数据块装入内存即可。 随着进程运行的不断推进，其余部分程序和数据可随时装入。 这样做可实现小内存运行大程序的设想 采用虚拟存储技术以后，从逻辑上说，系统拥有一个容量很大的存储器，这就是人们常说的虚拟存储器。 虚拟存储器的特性： 离散性 多次性 对换性 虚拟性 虚拟存储实现技术基于分页的虚拟存储令$\\iff$页面换入换出 基于分段的虚拟存储$\\iff$段面换入换出 基于段页的虚拟存储$\\iff$页面换入换出 请求分页存储管理基本原理要点 内存分大小相等的帧（Frame） 进程按照帧的大小被分成若干页（Page） 进程仅装入部分页面，即开始执行 在执行过程中访问的页若已在内存，进行动态的地址重定位，执行指令（同基本分页存储管理） 在执行过程中访问的页未装入内存时，产生缺页中断，进程阻塞，等待从磁盘动态装入页面 缺页装入以后，进程转入就绪，可以参与调度继续执行 内存无空闲可用帧时，暂时不用的页面可换出到交换区 通过页面的换入换出，实现小内存运行大进程 数据结构 位示图 系统设置一张位示图，记录内存划分为多少个帧，帧用一个0/1记录该帧占用还是空闲。 页表 为一个进程设置一张页表，记录该进程分了多少页、每一页是否已装入内存、内/外存地址、访问权限等的相关管理信息。 与基本分页存储管理的页表相比：扩充页表的内容，增加驻留标志位和页面辅存的地址等信息。 地址重定位机制当一个进程调度时，系统将其页表首址装入CPU中的页表控制寄存器。运行中用相对地址的高端部分作为页号去检索页表，看该页是否已在内存。 如果访问的页不在内存（发生缺页中断），在缺页中断处理过程中，装入缺页，继续地址重定位 缺页中断与缺页中断处理过程 缺页中断的断点缺页中断是指令执行过程中产生的中断，而（一般的中断）在一条指令执行完成后产生的。 缺页中断的断点压入当CPU执行指令希望访问一个不在内存的页面时，将生缺页中断，系统开始运行中断处理程序。 此时指令计数器（PC）的值尚未来得及增加就被压入堆栈，因此压入的断点必然是本次被中断的指令地址，而非下一条指令的地址。 缺页中断处理过程 保留进程上下文 判断内存是否有空闲可用帧？ 若有，则获取一个帧号No，转(4)启动I/O过程。 若无，继续(3)。 腾出一个空闲帧，即： 调用置换算法，选择一个淘汰页PTj。 PTj(S)=0;//驻留位置0 No=PTj(F);//取该页帧号 若该页曾修改过，则： 请求外存交换区上一个空闲块B PTj(D)=B; //记录外存地址 启动I/O管理程序，将该页写到外存上。 按页表中提供的缺页外存位置，启动I/O，将缺页装入空闲帧No中。 修改页表中该页的驻留位和内存地址。PTi(S)=1; PTi(F)=No。 结束 页面分配算法与分配策略页面分配相关讨论 实践证明，如果一个进程在内存中分配的帧数比较少，尽管有局部性原理，缺页率仍然相对较高——分配帧数太少不合适 给特定进程分配的内存空间超过一定的大小后，由于局部性原理，该进程的缺页率没有明显的变化 分配给一个进程的帧数越多，在任何时候驻留在内存中的进程数就越少，从而降低了操作系统至少找到一个就绪进程的可能性，降低了CPU的利用率——分配帧数太多不合适 给特定进程分配合理的内存帧数目前流行的支持多字节指令的计算机系统中，一条指令需要对源操作数和目的操作数进行处理（通常是二地址指令），那么一个进程的运行空间最好不小于6个页面。 请求分页系统中的页面分配应当以减少缺页率为目标。 需考虑因素：指令格式、寻址方式、程序长度、页面走向程序的工作集尺寸、多道并发度等。 常用页面分配算法 平均分配法：系统的可用空间平均分配给所有进程，让它们都占有相等数量的帧。 这样分配对短作业来说是很有利的。而对于一些较大的进程，缺页率必然居高不下 优先权分配法：考虑进程的优先运行权，给高优先的进程分配较多的帧，使它的缺页率相对少一些。 这里，我们可把优先权理解为高响应比、高优先级、最短剩余时间优先等。 比例分配法：这种分配方法比较公平，小进程分配小空间，大进程分配大空间 当可用空间为M个帧，系统当前的进程数为n，每个进程的页面数量为$s_i$，那么按比例分配法，应当分配给进程$i$的页数$p_i$为：$$p_i={s_i\\over \\displaystyle\\sum_{j=1}^n S_j}×M$$ 页面分配策略 固定分配策略：为一个进程在内存中分配固定数目的页框用于执行时使用。 可变分配策略：允许分配给一个进程的帧及帧的数目在该进程的生命周期中不断地发生变化 缺页率高，可增加分配的帧； 缺页率很低，可适当减少分配的帧。 页面置换算法概述与OPT 页面置换：是指在内存空间没有空闲可用帧而又要装入新页时，必须按某种算法将内存中的某页置换为一个新页 换出的：从内存换到外存（磁盘交换区或文件区） 换入的：从外存（磁盘交换区或文件区）换到内存 页面置换策略 局部置换策略：仅在产生这次缺页的进程的驻留页中选择并置换 全局置换策略：把内存中所有未被锁定的页都作为置换的候选页，不管它们属于哪一个进程。 页面分配策略+页面置换策略 局部置换 全局置换 固定分配 - 分配给一个进程的页框数是固定的- 从分配给该进程的页框中选择被置换的页 无此方案 可变分配 - 分配给一个进程的页框数可以变化- 从分配给该进程页框中选择被置换的页 从内存中所有可用页框中选择被置换的页，这导致进程驻留集大小不断变化 页面置换要点策略前提：固定分配+局部置换 发生背景：发生缺页中断+内存无空闲可用帧 完成功能：从进程自己的驻留页中选择一页作为淘汰对象换岀，然后换入所缺页 选择策略：页面置换算法 常用的页面置换算法OPT-最佳置换!&gt;该算法选择以后不再使用的、或者要隔最长时间才能使用的页面予以淘汰。OPT算法尽量避免刚调出去又要立即调入，是一种理想化了的页面置换算法。 例：可用页框（帧）数量为3，引用串如下：7 0 1 2 0 3 0 4 2 3 0 3 引用串 7 0 1 2 0 3 0 4 2 3 0 3 帧1 7 7 7 $\\color{red}2$ 2 2 2 2 2 2 2 2 帧2 0 0 0 0 0 0 $\\color{red}4$ 4 4 $\\color{red}0$ 0 帧3 1 1 1 $\\color{red}3$ 3 3 3 3 3 3 缺页F/置换R F F F R _ R _ R _ _ R _ $$缺页率=7/12$$ 存在的问题：实际系统无法预知将来页面的访问情况 OPT算法在实际系统中不易实现 OPT算法用于衡量实际页面置换算法的性能 FIFO-先入先出!&gt; 系统选择驻留在内存中时间最长的页面（最早装入的页面）作为被淘汰的对象。这种算法的出发点是局部性原理，但是没考虑“先装入内存者有可能是主程序常驻模块”。 例：可用页框（帧）数量为3，引用串如下：7 0 1 2 0 3 0 4 2 3 0 3 引用串 7 0 1 2 0 3 0 4 2 3 0 3 帧1 7 7 7 $\\color{red}2$ 2 2 2 $\\color{red}4$ 4 4 $\\color{red}0$ 0 帧2 0 0 0 0 $\\color{red}3$ 3 3 $\\color{red}2$ 2 2 2 帧3 1 1 1 1 $\\color{red}0$ 0 0 $\\color{red}3$ 3 3 缺页F/置换R F F F R _ R R R R R R _ $$缺页率=10/12$$ 问题：最先装入的不一定是以后不用的。 例如C程序中的main函数部分，在整个程序的生命周期中使用频率都很高。 FIFO算法容易理解和实现，性能并不总是很好 LRU-最近最久未使用!&gt; 系统选择内存中当前距上次使用最远的页予以淘汰。根据程序局部性原理，在较长时间里未被使用的页面，可能不会马上使用到。 实现时通常使用栈来组织各个驻留页，通过调整、维护栈来记录各驻留页被访问的先后顺序。 引用串 7 0 1 2 0 3 0 4 2 3 0 3 帧1(栈顶-刚刚访问的页) $\\color{red}7$ 0 1 2 $\\color{blue}0$ 3 $\\color{blue}0$ 4 3 3 0 3 帧2 $\\color{red}7$ 0 1 2 $\\color{blue}0$ 3 0 2 2 3 0 帧3(栈底-最近最久未访问的页) $\\color{red}7$ 0 1 2 2 3 4 4 2 2 缺页F/置换R F F F R _ R _ R R R R _ $$缺页率=9/12$$ 分析： 优点：缺页中断率接近OPT 缺点：几乎每一次页面访问都要调整栈，系统开销大 CLOCK!&gt; 这是一个建立在循环检测基础上的LRU近似算法，试图以较小的开销获得接近LRU的性能。该算法中将驻留页组织成一个循环队，并设一个循环移动指针。 实施步骤： 初始时，该指针指向循环队的头部。 指针顺序搜索各页面，若页面访问位为1，则将之改为0； 找到的第一个访问位为0的页面，淘汰；新换入的页面访问位置为1 应用分析： CLOCK是近似的LRU，理论上的缺页中断率肯定高于LRU，但实际系统应用起来系统开销少，效果要好于LRU。 问题：驻留页有被修改过的，也有未被修改过的，这两种页面被换出时的操作开销大为不同 改进的CLOCK 一个提高Clock算法效率的方法是：除了访问位A之外，为每个帧增设一个关联的“修改位”，记作M。 如果M=1表示该帧中的页面被修改了，淘汰它意味着必须将之写到外存。 如果M=0表示该帧中的页面没被修改，淘汰它意味着什么都不用做。 驻留页的四类页面： 0类页面-A=0，M=0：该帧中所存的页面最近没有访问，也没有修改。 1类页面-A=0，M=1：最近没有访问，但修改了。 处理过程： 从指针当前位置开始，循环扫描候选帧，遇到的第1个A=0且M=0的帧，将该帧中的页面置换后返回。 若循环一周没有找到可置换的帧，则继续循环扫描第二周，遇到的第1个A=0且M=1的帧，将该帧中的页面置换后返回在这个过程中，每跳过一个帧就将它的访问位A设置为0。 若第二圈仍没有找到可置换的帧，则循环扫描第三圈，操作同第一圈。 若第三圈仍没有找到可置换的帧，则循环扫描第四圈，操作同第二圈，必将能够找到一个可置换的帧 几种算法的性能比较 置换算法的选择，将直接影响到内存的利用率和系统效率。 对于上述四种算法，计算机学者Baer曾于己于1980年做过一个实验，选取的页面尺寸为256个字，分别实验了6、8、10、12、14帧的情况 当分配的帧数较多时，四种算法的区别不太明显；而当分配的比较少时，它们的区别就相当显著了。 关于页面调入的进一步讨论Q1：页面什么时候调入？ 在页面动态装入过程中有两个页面调入策略 “随用随调”策略 发生缺页中断时，缺哪页便调入哪页。 “预调页”策略 使用第1页，发生缺页中断，在调入第1页时连同第2、3…页一起调入。 “预调页”策略的优点： 一次读多个连续的页面，可以减少磁头移动的时间，对系统效率提高有很大好处。 当发现缺页已在内存时，当前进程不必让出控制权，仅仅将缺页转移到用户区，修改页表后就可继续运行 Q2：缺页从哪儿调入？ 从磁盘交换区中调入缺页 从磁盘文件区中调入缺页 从磁盘缓冲区中调入缺页 Q3：缺页调入需要多长时间？ 从磁盘交换区中调入缺页 调入时间主要是读磁盘扇区的时间，由磁盘寻道时间、盘片旋转延迟时间和数据传送时间3部分组成（设备管理部分详细涉及）。 通常，调入时间约为数百μs至数十ms 从磁盘文件区中调入缺页 对文件区的访问需要检索文件目录，找到文件的外存地址后再读磁盘扇区（文件管理部分详细涉及） 其调入时间将数倍于从磁盘交换区中调入缺页的耗时，几十甚至几百毫秒。 从磁盘缓冲区中调入缺页 系统允许采用“提前读”的访问策略时，用户程序运行中产生的缺页有可能已经驻留在内存的磁盘缓冲区内。 从该缓冲区内调入缺页的时间大体为数百ns。 基本分页存储管理中的有效访存时间在基本分页存储管理中，所有页面已在内存 设$t_1$为访问一次快存的时间，$t_2$为访问一次内存的时间，$p_{命中}$是访问快表命中率 则有效访存时间是：$$t=(1-p_{命中})×(t_1+2t_2)+p_{命中}×(t_1+t_2)$$ 请求分页管理中不缺页时的有效访存时间在请求分页存储管理中，不发生缺页时的这个访存时间t称为一个内存周期为ma $t_1$为访问一次快存的时间，$t_2$为访问一次内存的时间，$p_{命中}$是访问快表命中率 $ma=t\\=(1-p_{命中})×(t_1+2t_2)+p_{命中}×(t_1+t_2)$ 请求分页综合有效访存时间T的估算假定系统的一个内存周期为ma，调入缺页的时间为la，缺页率为$p_{缺页}$ 那么：$T=(1-p_{缺页})×ma+p_{缺页}×(la+ma)\\=ma-p_{缺页}×ma+p_{缺页}×1a+p_{缺页}×ma\\=ma+p_{缺页}×la$ 实例 已知一个采用了LRU置换算法的请求分页存储管理系统中，页面尺寸为4KB，内存访问速度为100(ns)次，快表访问速度为20(ns)/次，缺页中断处理时间为25(ms)次。今有一个长度为30KB的进程P进入系统，分配给P的存储块有3块，进程的所有页面都是在该进程运行中动态装入。若访问快表的命中率为20%，对应于下述页面访问序列：7,0,1,2,0,3,0，4,2,3,0,3,2,1,2,0,1,7,0,1 请估算有效访存时间为多少？ 驻留集、工作集与抖动的预防驻留集 进程已装入内存的页面的集合——与系统采用的页面装入和页面置换算法有关 驻留集尺寸 进程驻留在内存中的页面数量——与系统采用的页面分配策略有关 驻留集尺寸对缺页率的影响 如果将缺页率控制在上界与下界（比如0.1%~1%）之间，那么缺页率达到0.5%时的驻留集尺寸W将是比较适宜的。 工作集 进程工作集指“在某一段时间间隔内，进程运行所需访问的页面的集合”。 一个进程的工作集$W(t,τ)$表示在时间$t-τ$到$t$之间进程引用的一串页面；工作集的尺寸记作$w(t,τ)$，指的是$W(t,τ)$中的页面数。 在进程执行期间可以容易地确定该进程对存储空间的需求，也就是它的工作集尺寸 操作系统可以用这种方法决定给谁分配更多的帧，以及哪个进程应当让出一些帧。 工作集可用于指导驻留集大小 工作集策略 监视每个进程的工作集 周期性地从一个进程的驻留集中移去那些不在它的工作集中的页 只有当一个进程的工作集在内存中时，才可以执行 工作集策略的优点 通过工作集调整驻留集，可降低缺页率 通过工作集尺寸调整驻留集尺寸，可提高内存利用率 优先调度工作集包含于驻留集的进程，提高CPU利用率 工作集策略的缺点 根据过去预测将来的不准确性 为每个进程真实地测量工作集是不实际的 τ的最优值是未知的，并且它在任何情况下都会变化 抖动 抖动(Thrashing)又称颠簸，指刚被调出去的页需要马上被调回，刚调回不久又要被调岀。频繁调入调出，使系统的大部分时间都花费在内存和外存之间的来回折腾上。 抖动主要表现为磁盘I/O极度繁忙，而处理机大量时间空闲， CPU有效利用率降低 抖动产生的原因：归根到底是内存驻留的进程太多 抖动的预防措施 在处理机调度中引入工作集策略 采用局部置换策略防止抖动扩散 挂起部分进程 L=S准则 这里是产生缺页的平均时间，S是系统处理缺页的平均时间。 理论证明，当LS是处理机的利用率最高。在实际系统中很难实现。 请求分段式存储管理基本原理 进程按照逻辑结构分段。每一段装入内存一块连续存储区，各段离散存储 每个进程装入部分段面，就可以开始运行。 运行过程中，发生缺段，进程阻塞，通过缺段中断动态调入所缺段，进程转入就绪可参与调度继续执行。 地址重定位 数据结构 MAT表、空闲分区表——记录内存分区使用情况 段表(ST, Segment Table) 为了实现段的动态管理，为每个进程设置一个段表ST，并在ST中设立一些“控制位”记录该段的控制信息 段表结构： 段号 内存基址 外存地址 长度 访问权限 驻留位 访问位 修改位 增补位 ## B D L R/W/E S A M C 缺段中断机制与缺页中断类似，缺段中断也是指令执行过程中产生的中断，进程执行一条指令产生缺段中断时，压入堆栈的断点是当前指令的地址。当缺段被装入内存后，该段变成了“实段”。进程再次恢复运行时，CPU将重新执行这条指令。 缺段中断处理程序当第$i#$段是一个缺段，则缺段中断处理过程为 阻塞进程。 Length←STi（长度）。 检索“内存分配表”，若存在一个独立的内存块长度≥Length，则： 将该内存块分配给进程 首址记入B0；转（6） 若内存可用空间总和&lt;Length，则： 调用某种置换算法，选择一个内存中的段。 若该段被修改过，则，将它写回外存。 修改“内存分配表”、段表等数据结构。 转（3） 内存各进程浮动，拼接出一个足够大的内存空间；将该内存块分配给进程；首址B0。 从外存读入缺段，存入B0处 $STi(B)←B0；STi(S)←1$。 修改内存分配表。 唤醒进程。 结束 请求段页式存储管理基本原理 请求分段加请求分页。把段划分为若干个页面进行离散存储。 系统将一个段的当前页面调入内存其余的仍驻留在外存上，随时需要随时通过缺页中断装入。 硬件支持 处理机中设有段表控制寄存器参与地址映射，存放的内容是段表起始地址和段表长度。在地址结构方面，页面长度和分段长度由系统对控制寄存器的安排来决定。 软件支持 在请求段页式管理系统中，缺页置换算法是必须的，而且与纯粹请求分页管理机制中采用的算法相同。 地址重定位 优点：请求段页式管理具有虚拟存储器的功能，并保持了页式管理的优点：既体现段的独立性，又纳入了页的离散分配，使系统更加灵活。 缺点：增加了硬件的成本，系统复杂性提高，而且段表和页表的存储与检索问题突出，对处理机的运行速度影响较大 与地址有关的计算专题 逻辑地址（相对地址）——用户地址空间 物理地址（绝对地址）——实际内存单元地址 虚地址——虚拟存储空间的逻辑地址 实地址——实际内存单元地址 逻辑地址$=^{地址重定位}\\implies$物理地址 虚地址$=^{装入并地址重定位}\\implies$实地址 例1.分页地址合成计算 例2.分段地址合成计算 例3.段页式地址合成计算 系统32位地址空间。其中，段地址占11位，段内偏移地址占21位。在段内偏移地址中，页地址占11位，页内偏移部分占10位。 二进制地址：0000000010 | 000000001 | 1101000100 对应十进制地址为：&lt;2,1,836&gt;。 当2#段的1#页的帧地址中存放的是11111001100（十进制的1996），则物理地址将是00000000000111110011001101000100 例4.填空 分页存储管理系统中用户程序的逻辑地址是（一）维地址； 分段存储管理系统中用户程序的逻辑地址是（二）维地址。 例5.逻辑地址到物理地址的转换 说明：页大小为1024B，页表如图所示，将逻辑地址1011、2148、5012转换为相应物理地址。 过程： 1011/1024=0${(页号)}$…1011${(页内偏移)}$，2${(页号对应帧)}$×1024${(页大小)}$+1011$_{(页内偏移等同帧内偏移)}$=3059 2148/1024=2…100，1×1024+100=1124 5012/1024=4…916，页号4不存在 答案：3059、1124、逻辑地址非法 例6.逻辑地址到物理地址转换例 设备管理概述 管理对象–“外部设备” 在计算机系统中，用来担负数据输入输出的部件称作外部设备（Peripheral），简称“外设”，它们是计算机与外部世界进行信息勾通的桥梁 外部设备包括键盘、鼠标、打印机、卡片机磁带机、磁盘机等以及有关的支持设备。 I/O设备 人可读 机器可读 通信 外存储设备 数据速率 应用 控制的复杂性 传送单位 数据表示 错误条件 设备管理模块是操作系统中最庞大最复杂的一个模块 设备管理目标 方便用户使用 提高设备利用率 通过管理调度提高I/O效率 通过软件方法扩充设备功能 设备管理功能 设备分配、回收 设备无关性（设备独立性） 缓冲区的设置和管理 设备的驱动与调度 设备的虚拟扩充 逻辑I/O层的功能 负责设备的分配和回收。通过设置和维护数据结构，对设备数据进行登记和管理。 负责对用户的访问需求（如read或write）进行合法性检查。若此次访问不合法时，将拒绝访问 负责随时接收下层的处理结果，整理后反馈给用户。处理结果中包含成功或失败信息。 物理I/O层的功能 管理内存中的设备缓冲区，负责缓冲区的分配和回收。 实现数据的装入与提取，比如从上层软件送来的一行数据填入缓冲区或者从缓冲区取出一行数据送给用户。同时，要实现诸多用户对缓冲区访问的并发控制。 根据用户请求生成一个具体的I/O任务块IOB，挂到相关设备的任务队列上，并启动下层软件。 lOB（ Input Output Block） IOB是一种动态数据结构，每个IOB用于描述一项输入输出任务。 当系统收到一个I/O请求时就构造一个IOB，并按IOB的信息进行传输控制。 IOB 进程标识 内存地址 传输方向 传送数量 设备（及控制器）号 链接指针 设备调度与驱动层 主要包括的功能有： 设备调度，如磁盘I/O调度。 构造通道程序。 启动I/O设备完成输入输出。 对于设备I/O的情况进行收集并交给上层软件 设备的分配 共享设备是允许多用户穿插访问的设备，此类设备不能分给某个用户独占。 设备分配是用户对独享设备的使用方式。用户分得台独享设备后可以自由地使用，直到使用完毕将设备释放为止。 当用户请求进行I/O操作时，不但要分配设备，还要分配有关的数据传输通路，也就是分配通道和控制器 系统设备表SDT（System Device Table） 系统设置一张SDT，登记系统拥有的所有设备类型，一行登记一类设备的管理信息。 例： 设备类型 访问方式 设备可用量 DCT指针 驱动程序入口 PRN 输出 2 DCT[0052] *** SCA 输入 2 DCT[0062] *** COM 输入输出 1 DCT[0071] *** DSK 输入输出 1 DCT[0100] *** 设备控制表DCT（Device Control Table） 系统设一张DCT，登记所有外部设备，一行登记登记一台设备的管理信息 例： 设备类型 设备标识Did 属性 设备状态 CCT指针 重复次数 任务队列指针 PRN 0051 独享 忙碌 CCT[1000] 3 *** SCA 0051 独享 空闲 CCT[1001] 3 *** COM 0053 独享 空闲 CCT[1001] 5 *** 逻辑设备映射表LUT 分配结果记入每个进程的PCB，称作LUT 设备分配过程 根据用户提出的逻辑设备名称，从SDT中找到相应类型的逻辑设备，并获取该类型设备的可用数量N，据此进行安全检测（银行家算法），如果检验不通过，则将进程阻塞。 从SDT中取出设备控制表指针，查找DCT，找到一台可用的外部设备。将设备分配给进程。在该进程的PCB中建立一个设备映射表LUT，将用户的逻辑设备名称和对应的物理设备标识对应起来。 通过设备分配实现了设备无关性： 又称为设备独立性，指的是应用程序所涉及的逻辑设备与系统中具体使用的物理设备是互相无关的。 设备无关性的优点 设备分配的灵活性提高：进程使用逻辑设备名提出请求，系统可以从当前空闲的物理设备中任选一台分给用户。 易于实现I/O重定向：系统可以在不更改应用程序代码的前提下，让程序中LO命令所涉及的逻辑设备名映射到另外的物理设备上。 缓冲区的设置与管理 缓冲区，是位于内存中的一块临时存储区，作为内存和外部设备之间数据传送的桥梁。 设置缓冲区的目的 改善中央处理器与外围设备之间速度不匹配的矛盾 协调逻辑记录大小与物理记录大小不一致 提高CPU和I/O设备的并行性 引入缓冲技术后的系统，呈现以下特点： 减少设备驱动次数。 可以缓解I/O操作对缺页置换策略的干扰。 缓解CPU与外部设备速度不匹配的矛盾，使数据处理的速度提高。 缓冲技术带来的 进程执行写操作输出数据时，向系统申请个缓冲区，若为顺序写请求，则不断把数据填到缓冲区，直到被装满。 此后，进程继续它的计算，系统将缓冲区内容写到IO设备上。 在输出数据时，只有在系统还来不及腾空缓冲而进程又要写数据时，它才需要等待 大部分时间，进程的计算和输出是可以并行的 真题 某文件占10个磁盘块，现要把该文件磁盘块逐个读入主存缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把个磁盘块读入缓冲区的时间为100μs，将缓冲区的数据传送到用户区的时间是50μs，CPU对一块数据进行分析的时间为50μs。在单缓冲区和双缓冲区结构下，读入并分析完该文件的时间分别是（B） A.1500μs、1000μs B.1550μs、1100μs C.1550μs、1550μs D.2000μs、2000μs … UNIX操作系统采用的缓冲注 缓冲池是系统提供的一种共享结构，不归某个进程所有 任何程序都可以申请缓冲池中的一个存储块，用来存放自己的缓冲数据。 缓冲块组成3个队列： 空闲缓冲队列emq：该队列上挂有全部可用的空闲缓冲区。 输入队列inq：该队列上挂有装满输入数据的缓冲区。 输出队列outq：该队列上挂有装满输出数据的缓冲区。 磁盘读写速度分析 磁盘性能参数 寻道时间$t_s$：将磁头臂移到指定磁道所需要的时间 $T_s=s+m×n$ s-磁盘启动时间，m-平均跨越一道的时间，n-跨越的道数 旋转延迟时间$t_r$：将磁盘的待访问地址区域旋转到读/写磁头可访问的位置所需要的时间 $T_r={1\\over 2r}$ r-旋转速度（转/秒） 传输时间$t_t$：读或写操作的数据传输所需的时间 $T_t={b\\over rN}$ b-要传送的字节数，r-转速，N-一个磁道中的字节数 一次磁盘访问时间T是下述3部分的总和，即：$T=t_s+t_r+t_t$ 磁盘调度算法 $T=t_s+t_r+t_t\\=s+m×n+{1\\over 2r}+{b\\over rN}$ 如何提高磁盘I/O速度？ 研制更高性能的设备，加快其读写速度 设置高速大容量的设备缓冲区。 采用好的I/O调度算法。 磁盘调度程序的目标是制定一种访问策略，使磁头臂移动较少的距离就可完成磁盘访问 对于r次磁盘访问请求q1，q2，…，qr，应用某种磁盘调度算法得到一个依次满足各次请求的顺序，期间磁臂总共跨越的道数为n 定义：$平均寻道长度={n\\over r}$ 磁盘调度算法 先来先服务FCFS：按磁盘访问请求到来的先后顺序进行服务 优点：比较公平，实现简单 缺点：不考虑调度效率 平均寻道长度为640/8=80 ​ 最短寻道优先SSTF：从当前磁头位置选择最短寻道时间的请求，即选择与当前磁头位置最近的待处理请求。 优点： 较FCFS提高了性能 平均寻道长度29.5 VS 80 缺点： 有可能出现“粘着”现象 系统比较繁忙时，可能出现“饥饿”现象 有一个被忽略的问题，磁臂转向也需要时间开销 平均寻道长度为236/8=29.5 扫描算法SCAN：又称电梯调度，沿磁臂当前移动方向由近及远依次满足磁盘访问请求，至当前方向再无请求时磁臂转向，继续由近及远依次满足访问请求。 需要知道磁头的当前位置和磁头当前移动方向。 优点： 较SSTF大大减少了磁臂转向次数 尽管平均寻道长度增大，但在实际系统中效率较好 缺点：系统比较繁忙时，仍可能出现“饥饿”现象 平均寻道长度为299/8=37.375 循环扫描算法C-SCAN：SCAN调度的变种，在个移动方向上，随着移动不断处理请求。反向时空档返回，直到最远请求，然会转向移动时再处理请求处理请求。 优点：较之SCAN减少了“饥饿”现象的出现 缺点：空档返回增加了平均寻道长度 平均寻道长度为322/8=40.25 N-STEP-SCAN算法 FSCAN算法 …… 通道控制下的I/OI/O控制方式：计算机系统中的O控制是与硬件的配置紧密相关的，分为以下4种方式： 程序查询控制方式 中断控制方式 DMA控制方式 通道控制方式 中断类别：引起中断的原因很多，大体分为两大类 自愿性中断 访管中断 人为设置中断 非自愿性中断 I/O中断 程序出错中断 硬件故障置中断 外部事件中断 中断处理程序的处理过程： 关中断 保护进程上下文 注意，被中断的程序，除了PSW和PC中的信息已被硬件机制压栈，其余寄存器中尙有一部分残留数据。 而中断处理程序运行时可能要用到其中一部分寄存器，因此需要将中断处理程序中涉及到的寄存器内容保存起来（通常也压入系统栈中）。 设备中断处理（不同的设备有不同的设备中断处理程序） 在处理期间，处理机要检查相关设备控制器的状态，判断本次传输是否正常完成。 若正常完成，可将设备传送来的数据转交到用户区，并唤醒等待该数据的进程，或者将下一批要传送出去的数据传送到设备控制器中，重新启动设备。若为非正常完成，可根据发生的情况进行异常处理。 恢复被中断的程序 首先将保存在栈中的寄存器内容弹出来，置入处理机的相关寄存器中。然后，从栈中弹出PSW和PC的值，置入处理机中。这就意味着，被中断的程序又恢复了运行 开中断 I/O过程的结束 通道通道：I/O处理机 通道指令： 处理I/O过程的指令 是通道运行的程序，通常被置于内存的约定地址中。作为实通道指令施数据传送控制的依据，通道程序的编制主要依赖于SDT DCT和IOB中的信息。 虚拟设备 操作系统的设备管理模块通过软件方法扩充设备功能，获得“虚拟设备”。 包括 将一台设备虚拟成多台设备 将低速设备虚拟成快速设备 将不能共享的设备虚拟成共享设备 一台设备虚拟成多台设备 打印机是一种独占设备 系统为每一台打印机设置了一个打印队列； 每一个进程的每一次打印请求被组织成一个IOB入队 打印机独占，但打印任务队列可供多个用户或进程使用。 在用户看来，好像有多台打印机在备用一样 Spooling技术 Spooling是“联机外设并行访问”(Simultaneous Peripheral Operations On Line)的缩写，是将磁盘空间虚拟成I/O设备使用的一种技术。 Spooling的指导思想是，利用高速共享设备（通常是磁鼓或者磁盘将低速的独享设备模拟为高速的共享设备。这样，从逻辑上讲，计算机系统为每一个用户都配备了一台高速独享设备。 是操作系统用于管理低速外部设备的一种实用技术。 是将独享设备模拟成共享设备的一种技术。 Spooling的实现要点 外存上设输入井、输出井 内存设输入缓冲区、输出缓冲区 系统设预输入程序和缓输出程序 对于输入输出井的使用，系统设四个系统进程： 收容输入、提取输入 收容输出、提取输出进程 四个系统进程 收容输入 该功能负责启动输入设备，将数据（或作业）从输入设备读进来，在文件管理系统的支持下，把数据存放到外存的输入井上。 提取输入 从输入井上提取数据（或作业），送入内存的用户区中，供进程使用。 收容输出 将用户进程需要输出的数据从其用户区取出来，送到输出井上。 提取输出 到外存上取出输出井上的数据，送输出设备（比如打印机）上。 文件管理概述 用户关注的是逻辑层面的文件 文件内容 方便地使用 OS关注的是物理层面的文件 怎么存储文件 如何实现文件的读写 如何快速存取 如何提高磁盘存储空间利用率 在操作系统看来： 文件是在逻辑上具有完整意义的组相关信息的集合。 它可以是一组相关的字符流集合，也可以是一组相关的记录集合 通常被保存在外存储器上。 内在形式-文件的组成和操作 文件组成 FCB（File Control Block） 文件体 对文件要做的事情 建立、描述 存储、读写 文件管理系统FMS（File Management System） FMS是操作系统的一个组成部分 负责实现文件管理有关功能的管理模块 管理对象是：文件、目录、文件存储空间、用户 文件管理系统的管理目标 方便用户 提高磁盘空间利用率 文件操作便捷且存取效率高 文件管理系统的管理功能 按名存取 文件组织（逻辑文件与物理文件的转换） 存储空间管理 文件共享和保护 文件操作 公认一个好的FMS应具有以下特点 使用的方便性 按名存取的实现，使文件的物理结构和存放的物理位置对于用户都成了透明的。 数据的安全性 好的文件管理系统能提供有效的保护措施，以保证文件信息的安全。 接口的统一性 用户可以使用统一的广义指令或系统调用来存取各种介质上的文件，这样做简单、直观，而且摆脱了对存储介质特性的依赖以及使用I/O指令所做的繁琐处理。 操作员接口：如“文件”菜单各种命令 程序员接口：如fopen()等文件操作系统调用 现代操作系统中比较著名的FMS Hpfs：OS/2上的操作系统 FAT：最早用于MS-DOS，后用于 Windows系列及OS/2等操作系统，经过操作系统的不断改进，FAT又发展为FAT16、FAT32等。 NTFS：Windows及 Windows2000上的文件管理系统，安全性和可靠性比较好。 文件与目录 目录也是文件 目录是一种特殊的文件 目录的内容是另外一些文件的管理信息（FCB） 目录文件与文件目录 目录是文件的一种，叫目录文件 文件目录是目录文件中记录的一条信息 文件目录与FCB有关 它可能是整条FCB———如DOS 也可能是FCB的一部分———如Unix、 Linux UNIX为什么要引入索引结点 在多级目录结构中，目录也是以文件形式存放在磁盘上的； 如果目录项内容较多，则目录文件要占用大量的盘块； 查找文件要先查找它所在的目录； 目录文件太大，查找效率就会比较低； 文件的组织结构 文件有两种组织结构 文件的逻辑结构——是指呈现在用户面前的文件结构，是文件逻辑上的组织形式。 文件的物理结构——是指文件在存储介质上的存储结构，是文件在外存空间上的组织形式 文件的逻辑结构 文件的物理结构 流式结构 顺序结构 记录式结构 链式结构 索引结构 文件的逻辑结构–用户使用角度 流式文件——是指文件内的数据是一个完整的字符流，不可以进一步细分。 例如，源程序文件、可执行文件、文本文件、图片文件、声音文件等。 对流式文件，用户常常以长度来指定所需存取的信息，也可以通过插入特殊符号来标识存取的界限。 记录式文件——在逻辑上可看成是一组记录的集合。每个记录由彼此相关的若干个数据项组成。 例如：统计表文件、数据库文件等记录式文件中的逻辑记录可依次编号，其序号称为逻辑记录号（简称记录号）。 文件的物理结构-操作系统存储角度 连续存储结构——文件体在磁盘上占用连续的存储空间 连续存储结构–文件体在磁盘上占用不连续的存储空间 链接存储 隐式链接存储 显式链接存储 索引存储 文件存取方式（存取≠存储） 文件的顺序存取 按照文件的逻辑地址顺序存取。在记录式文件中，这种操作体现为按照记录的排列顺序来进行存取 文件的随机存取 随机存取是指允许用户按照记录编号或者某一数据项的值随机存取任一记录。存取任一记录时间没有明显不同 文件的顺序存储结构 文件信息占用一组连续的盘块，文件在外存上顺序存放 文件目录中登记起始盘块和所占块数 顺序存储的文件称为连续文件。这种文件不仅在逻辑上是连续的，在外存上存放的空间也是连续的。 顺序存储结构的特点 优点 管理简单 存取速度快 既适合顺序存取，也适合随机存取 缺点 外存空间利用率低 必须预先知道文件的长度 不便于文件的扩展 文件的链式存储和索引存储隐式链接存储结构 每个文件占用不连续的盘块，文件目录中只登记起始盘块和末盘块号，其它盘块号均由链接指针记录。 优点 采用离散分配方式 易于文件增长或收缩 减少了外存空间出现外碎片的现象 缺点 只能顺序存取 指针本身需占用存储空间 链接指针的可靠性是个问题 显式链接存储结构 将用于链接文件各盘块的指针“显式”地存放在外存的一张链接表当中 该表在整个磁盘仅设置一张，登记了分配给文件的所有盘块的链接关系， 故将该表称为——文件分配表FAT (File Allocation Table) 优点 采用离散存储方式 易于文件增长或收缩 减少了外存空间出现外碎片的现象 既可以顺序存取，又可以随机存取 缺点 FAT表占用较大的存储容量 FAT表使用时，占用较大内存空间 FAT表的读取、维护加大了系统开销 索引存储结构 为每个文件分配一个索引块，在索引块中登记其各逻辑块与外存物理块的对应关系，并在文件FCB中登记该文件索引块的地址 优点 离散存储 既适合顺序存取，也方便随机存取 索引结构容易实现记录的增、删 缺点 索引块实际是存储开销 一个索引块能存放的盘块号有限，所以一级索引存储限制了文件的容量，需要建立二级甚至多级索引存储结构。 多级索引存储结构及相关计算 将索引表离散存储，即：将索引表本身分为若干个逻辑块，存储在若干物理盘块中，将索引表所占的各盘块号记入另一个索引表——索引表的索引表。 这种结构就称两级索引结构 索引存储结构有关计算例如：一个盘块号用4个字节表示，盘块尺寸为4KB 那么：一个盘块可存放：$4KB/4B=1K个盘块号$ Q1：一级索引能够支持的存储容量是 $1K*4KB=4MB$ Q2：二级索引能够支持的存储容量是 $1K1K4KB=4GB$ Q3：三级索引能够支持的存储容量是 $1K1K1K*4KB=4TB$ UNIX混合索引存储结构 UNIX操作系统采用了多级混和索引存储结构 它将直接寻址、一级索引、二级索引和三级索引融为一体，规定每个文件的索引结点使用13个地址登记项。 前10个登记项直接指出存放文件信息的盘块号，属直接寻址。 第11个登记项指向一级索引块，内含若干级索引存储块 第12个登记项和第13个登记项分别实现二三级索引。 若一个盘块号用4个字节表示，盘块尺寸为4KB，那么 Q1：UNⅨ允许的文件的最大长度是： 10个直接寻址 $10*4KB=40KB$ Q2：1个一级索引项能够支持的存储容量是： $(4KB/4B)*4KB=4MB$ Q3：1个二级索引项能够支持的存储容量是： $(4KB/4B)*(4KB/4B)*4KB=4GB$ Q4：1个三级索引项能够支持的存储容量是： $1K1K4KB=4TB$ Q5：允许的文件的最大长度是： $4TB+4GB+4MB+40KB$ 不要混淆：索引节点与索引存储结构 文件目录的管理与查询 文件目录是一种数据结构，由若干目录项组成。 每个目录项对应其中一个文件的FCB，包括： 文件的存取控制信息 文件的结构信息 文件的管理信息 文件目录内容 文件存取控制信息 如：用户名、文件名、文件类型、文件访问权限。 文件结构信息 如：文件的逻辑结构、物理结构、文件位置、长度。 文件管理信息 如：文件的建立日期、被修改的日期、保留日期和记帐信息 文件目录管理的主要目的 合理组织目录结构，提高对目录的检索速度 允许文件重名 实现“按名存取” 允许文件共享，以节约外存空间 树形目录结构的优点 层次清楚便于文件分类 解决了重名问题 提高了文件检索的速度 便于进行存取权限的控制 文件存储空间的管理分配和回收 创建文件或者文件动态增长的时候，查找空闲的盘块，分配给文件 删除文件内容或者删除整个文件时，将文件所占盘块回收。 空闲区表/链 磁盘上连续的空闲盘块组成一个“空闲区”，系统为磁盘上所有的空闲区建立张“空闲区表”，每个空闲区对应一个表项。 若各空闲区使用链链接起来，称之为空闲区链”。 空闲块链 建立一个链表，将文件存储空间中所有空闲块顺序链接在一起，链中每一结点记录个空闲块的物理块号，同时记录下一空闲块的指针，称为“空闲块链”。 空闲分区表和空闲块链的缺点： 磁盘空间的管理看上去与内存空间管理类似，但是磁盘空间容量要大得多 所以上述数据结构： 存储开销巨大 查询、维护开销巨大 位示图 系统划出若干字节，为每个文件存储设备建立一张位示图，位示图中的一个位（bit）对应文件存储空间的一个物理块。若该位为“1”，表示对应块被占用，若该位为“0”，表示对应物理块空闲。 与空闲区表链、空闲块链相比，位示图只用用1个b记录一个磁盘块的占用情况，比较节约空间，但是磁盘空间太大了，即使如此，位示图的空间开销依然很大，相应查询和维护的时间开销页很大 例如：磁盘640GB，1KB为个盘块，则磁盘共有$640GB/KB=640M$个盘块 即：位示图需要记录640M个bit, $640M bit/8=80MB$ 文件共享与文件保护、保密 文件的共享：是指允许不同的用户共同使用同一个文件 文件的保护：是指防止文件被有意或无意地破坏。 文件的保密：是指防止文件未经授权而被非法窃取。 文件共享 静态共享：多个用户共享同一个物理文件 通过信息文件指针的链接实现。不同用户、不同的文件名，但其FCB中的物理地址是相同的，都指向文件存储间中相同的物理信息。 动态共享：多个进程并发地访问同一文件 这种共享关系只有当用户进程存在时才可能存在，一旦用户进程消亡，其共享关系也就自动消失。 实现静态共享的方法 绕弯路法 基于索引结点共享法 基于符号链共享法 基于基本目录共享法 实现文件的动态共享 指系统中不同的用户或同一用户的不同进程并发地访问同文件。 多个进程对已打开文件的共享。 这种共享关系只有当用户进程存在时才可能存在，一旦用户进程消亡，其共享关系也就自动消失。 文件保护 防止系统故障造成破坏，常采用的措施 定时转储 建立副本 后备系统 磁盘容错技术 一级容错：写后读校验 二级容错：磁盘镜像 三级容错：磁盘双工 防止人为因素造成的破坏，常采用的措施 设置基于目录的存取权限 建立基于文件的存取权限 存取控制矩阵 文件保密 常用的保密措施 设置口令 隐藏文件目录 加密与解密技术 "},{"title":"计算机图形学","date":"2020-07-27T16:00:00.000Z","url":"/blogs/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","tags":[["算法","/blogs/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["图形学","/blogs/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"content":"概述部分帧缓冲器、分辨率与颜色种类之间的关系 单色图，每个像素1Bit 16色，每个像素4Bit（$2^4=16$） 256色，每个像素1个字节（$2^8=256$） 65,536(64K)色，每个像素2个字节（$2^{16}=65536$） 16,777,216(16.7M)色，每个像素3个字节（$2^{24}=16.7M$）（24位真彩色） 举例2M显存，在$1024*768$分辨率下数值为 $2 * 1024 * 768 =‭ 1,572,864$‬支持64K色，不支持24位真彩色 直线扫描转换算法数值微分法（DDA） 引进图形学中一个很重要的思想——增量思想 $$y_i = kx_i+b$$ $$\\begin{split}y_{i+1}&amp;=kx_{i+1}+b\\\\&amp;=k(x_i+1)+b\\\\&amp;=kx_i+b+k\\\\&amp;=y_i+k\\end{split}$$ $$得到： y_{i+1}=y_i+k$$ 即 $当前步的y值 = 前一步的y值 + 斜率k（增量）$ 举例 要求：DDA扫描转换连接两点$ P_0(0,0)与P_1(5,3) $的直线段。 过程：$ k= {y_1-y_0 \\over x_1-x_0}={3-0 \\over 5-0}=0.6 $ &lt;1 根据$ y_{i+1}=y_i+k $，得到下表的计算结果 X Y int(y+0.5) 0 0 0 1 0.6 1 2 0.6+0.6 1 3 1.2+0.6 2 4 1.8+0.6 2 5 2.4+0.6 3 但是此算法并不适用于$ |k| &gt; 1 $的情况，会导致光栅点太稀疏。 优化后算法 中点画线算法核心思路 基本原理采用直线的一般方程：$ F(x,y) = Ax+By+C=0 $ 其中：$ A=-(\\Delta y); B=(\\Delta x); C=-B(\\Delta x) $ 假定：$ 0 ≤ |k| ≤ 1 $， 因此每次在x方向+1，y方向+1或不变则需要判断。 当 点Q 在 点M 上方 ，则$ P_u $离直线近，应为下一个像素点 反之则$ P_d $离直线近，应取$ P_d $为下一个像素点 为判断Q在M上方还是下方，把M带入理想直线方程： $\\begin{split}d_i = F(x_m,y_m) &amp;= F(x_i+1,y_i+0.5) \\\\&amp;= A(x_i+1)+B(y_i+0.5)+C\\end{split}$ 当$ d&lt;0 $时，Q在M上方，应取$ P_u $; 当$ d&gt;0 $时，Q在M下方，应取$ P_d $; 当$ d=0 $时，M在直线上，取$ P_u $ 或$ P_d $均可。 但此方法运算效率太低，因此需要优化。 算法优化$ \\begin{split}d_0&amp;=F(x_{m0},y_{m0}) \\\\&amp;=F(A(x_i+1)+B(y_i+0.5))+C\\end{split}$ 计算出初值$ d_0=A+0.5B $ $ d&lt;0 $情况下，推导d的增量关系： $\\begin{split} d_1&amp;=F(x_{m1},y_{m1}) \\\\&amp;=F(A(x_i+2)+B(y_i+1.5))+C \\\\&amp;=F(A(x_i+1)+B(y_i+0.5))+C+A+B\\end{split}$ 得到：$ d_1=d_0+A+B $ $ d≥0 $情况下，推导d的增量关系： $\\begin{split}d_1&amp;=F(x_{m1},y_{m1}) \\\\&amp;=F(A(x_i+2)+B(y_i+1.5))+C \\\\&amp;=F(A(x_i+1)+B(y_i+0.5))+C+A\\end{split}$ 得到：$ d_1=d_0+A $ Bresenham算法 Bresenham提供了一个更一般的算法。该算法不仅有好的效率，而且有更广泛的适用范围 核心思路 该算法的思想是通过各行、各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序，计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。 假设每次x+1，y的递增（减）量为0或1，它取决于实际直线与最近光栅网格点的距离d，这个距离的最大误差为0.5。 误差项d的初值$ d_0=0 $，$ d_n=d_{n-1}+k $一旦$ d≥1 $，就把它减去1，保证d的相对性，且区间为$ [0,1) $ $$即：\\begin{cases} x_{i+1}=x_i+1\\\\ y_{i+1}= \\begin{cases} y_i+1 &amp;\\text (d&gt;0.5)\\\\ y_i &amp;\\text (d≤0.5) \\end{cases}\\end{cases}$$ 算法优化将此算法效率提升到整数加法 分步改进思路改进1：令$ e=d-0.5 $ $$即：\\begin{cases} x_{i+1}=x_i+1\\\\ y_{i+1}= \\begin{cases} y_i+1 &amp;\\text (e&gt;0)\\\\ y_i &amp;\\text (e≤0) \\end{cases}\\end{cases}$$ e&gt;0，y方向递增1；e&lt;0，y方向不递增 e=0时，可任取上、下光栅点显示 改进后步骤 $ e_初 =-0.5$ 每走一步有$ e=e+k $ 若$ e&gt;0 $，则$ e=e-1 $ 改进2：$$e_初=-0.5，k={dy \\over dx}$$ 由于算法中只用到误差项的符号，于是可以用$ e·2·Δx $来替换$e$ 改进后步骤 $ e_初 =-Δx $ 每走一步有$ e=e+2Δy $ 若$ e&gt;0 $，则$ e=e-2Δx $ 最终算法思路 1.输入直线的两端点$ P(x_0，y_0)和P_1(x_1，y_1)$ 2.计算初始值$ Δx、Δy、e=-Δx、x=x_0、y=y_0 $ 3.绘制点$ (x,y) $ 4.$ e $更新为$ e+2Δy $，判断$ e $的符号 若$ e&gt;0 $，则$ (x,y) $更新为$ (x+1，y+1) $，同时将$ e $更新为$ e-2Δx $； 否则$ (x,y) $更新为 $ (x+1，y) $ 5.当直线没有画完时，重复步骤3和4，否则结束 此算法不再依赖于直线的方程类型 多边形的扫描转换与区域填充 如何在离散的像素集上表示一个连续的二维图形 多边形的扫描转换 定义 多边形有两种重要的表示方法：顶点表示和点阵表示 凸多边形：任意两顶点间的连线均在多边形内 凹多边形：任意两顶点间的连线有不在在多边形内 含内环的多边形：多边形内包含多边形 光栅图形的一个基本问题是把任意多边形的顶点表示转换为点阵表示，这种转换称为多边形的扫描转换 X-扫描线算法 基本思想 按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作 核心思路 按X递增顺序 排列交点的X坐标序列 确定多边形所占有的最大扫描线数，得到多边形顶点的最小和最大y值（$ y_{min}和y_{max} $） 从$ y=y_{min} $到$ y=y_{max} $，每次用一条扫描线进行填充 求交：计算扫描线与多边形各边的交点 排序：把所有交点按递增顺序进行排序 交点配对：第一个与第二个，第三个与第四个… 区间填色：把这些相交区间内的像素置成不同于背景色的填充色 当扫描线与多边形顶点相交时，交点的取舍问题（交应保证为偶数个）： 解决方案 若共享顶点的两条边 分别落在扫描线的两边，交点只算一个 若共享顶点的两条边 在扫描线的同一边，这时交点作为0个或2个 共享顶点的两条边的 另外两个端点的y值若大于交点y值，则算作2个点 共享顶点的两条边的 另外两个端点的y值若小于交点y值，则算作0个点 此算法效率低，求交计算量非常大。 从三方面考虑加以改进： 在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算 考虑扫描线的连贯性。即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似 最后考虑多边形的连贯性。即当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交 算法改进 改进思路 引入一种数据结构 （1）活性边表（AET）：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中。 （2）结点内容（一个结点在数据结构里可用结构来表示） $$ k={Δy \\over Δx}={y_{i+1}-y_i \\over x_{i+1}-x_i}$$ $$\\implies x_{i+1}=x_i+{1 \\over k}$$ $$即： Δx={1 \\over k}$$ 另外，需要知道一条边何时不再与下一条扫描线相交，以便及时把它从有效边表中删除出去，避免下一步进行无谓的计算X $ x $ $ Δx $ $ y_{max} $ next 当前扫描线与边的交点坐标 从当扫描线到下条扫描线之间的x增量，即斜率的倒数 该边所交的最高扫描线的坐标值 指向下一条边的指针 为了方便活性边表的建立与更新，需构造一个新边表（NET），用来存放多边形的边的信息，分为4个步骤：（1）首先构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个结点，称为一个吊桶，对应多边形覆盖的每一条扫描线（2）NET挂在与该边低端y值相同的扫描线桶中。也就是说，存放在该扫描线第一次出现的边 $ y_{max} $ $ x_{min} $ $ 1 \\over k $ next 该边的$ y_{max} $ 该边较低点的x坐标值 该边的斜率 指向下一条具有相同较低端y坐标的边的指针 每做一次新的扫描线时，要对已有的边进行三个处理 是否被去除掉； 如果不被去除，第二就要对它的数据进行更新。所谓更新数据就是要更新它的x值 $$即： x+{1 \\over k}$$ 看有没有新的边加入，新的边在NET里，可以插入排序插进来 这个算法过程没有求交，这套数据结构避免了求交运算 此算法的缺点是无法实现对未知边界的区域填充 边缘填充算法基本思想是按任意顺序处理多边形的每条边。 在处理每条边时，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补）多边形的所有边处理完毕之后，填充即完成 栅栏填充算法栅栏指的是一条过多边形顶点且与扫描线垂直的直线。 它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补。 边界标志算法帧缓冲器中对多边形的每条边进行直线扫描转换，亦即对多边形边界所经过的像素打上标志，然后再采用和扫描线算法。 类似的方法将位于多边形内的各个区段着上所需颜色，由于边界标志，算法不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。 区域填充 定义 区域-—指已经表示成点阵形式的填充图形，是像素的集合区域填充是指将区域内的一点（常称种子点）赋予给定颜色然后将这种颜色扩展到整个区域内的过程 区域可采用内点表示和边界表示两种表示形式 内点表示：枚举出区域内部的所有像素，内部的所有像素着同一个颜色，边界像素着与内部像素不同的颜色 边界表示：枚举出边界上的所有像素，边界上的所有像素着同一个颜色，内部像素着与边界像素不同的颜色 区域填充算法要求区域是连通的，因为只有在连通区域中，才可能将种子点的颜色扩展到区域内的其它点。 区域可分为4向连通区域和8向连通区域 4向连通区域：指的是从区域上一点出发，可通过四个方向，即上、下、左、右移动的组合，在不越出区域的前提下，到达区域内的任意像素 8向连通区域：指的是从区域内每一像素出发，可通过八个方向，即上、下、左、右、左上、右上、左下、右下这八个方向的移动的组合来到达 简单四连通种子填充算法（区域填充递归算法） 原理：假设在多边形区域内部有一像素已知，由此出发找到区域内的所有像素用一定的颜色或灰度来填充假设区域采用边界定义，即区域边界上所有像素均具有某个特定值，区域内部所有像素均不取这一特定值，而边界外的像素则可具有与边界相同的值 使用栈结构来实现简单的种子填充算法算法原理：种子像素入栈，当栈非空时重复执行如下操作： 栈顶像素出栈 将出栈像素置成要填充色 按左、上、右、下顺序检查与栈像素相邻的四个像素，若其中某个像素不在边界且未置成填充色，则把该像素入栈 种子填充算法的不足之处： 有些像素会入栈多次，降低算法效率；栈结构占空间 递归执行，算法简单，但效率不高。区域内每一像素都引进一次递归，进/出栈，费时费内存 改进算法，减少递归次数，提高效率可以采用区域填充的扫描线算法 反走样概念 对直线、圆及椭圆这些最基本元素的生成速度和显示质量的改进，在图形处理系统中具有重要的应用价值但它们生成的线条具有明显的“锯齿形” 即会发生走样（Liasing）现象 “锯齿”是“走样”（Aliasing）的一种形式。而走样是光栅显示的一种固有性质。产生走样现象的原因是像素本质上的离散性。 用于减少或消除走样效果的技术，称为反走样（Antialiasing）技术 由于图形的走样现象对图形的质量有很大影响，几乎所有图形处理系统都要对基本图形进行反走样处理 非加权区域采样方法根据物体的覆盖率（Coverage）计算像素的颜色 覆盖率 - 指某个像素区域被物体覆盖的比例 非加权区域采样方法有两个缺点： 像素的亮度与相交区域的面积成正比）而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应 直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差每个像素的权值是一样的，这是它的主要缺点。所以也称非加权区域采样方法 加权区域采样方法这种方法更符合人视觉系统对图像信息的处理方式，反走样效果更好 将直线段看作是具有一定宽度的狭长矩形；当直线段与像素有交时，根据相交区域与像素中心的距离来决定其对像素亮度的贡献 直线段对一个像素亮度的贡献正比于相交区域与像素中心的距离设置相交区域面积与像素中心距离的权函数（高斯函数）反映相交面积对整个像素亮度的贡献大小 利用权函数积分求相交区域面积，用它乘以像素可设置的最大亮度值，即可得到该像素实际显示的亮度值 采用离散计算方法将一个像素划分为$ n=3×3 $个子像素，加权表可以取作： $$\\begin{bmatrix} w_1 &amp; w_2 &amp; w_3 \\\\ w_4 &amp; w_5 &amp; w_6 \\\\ w_7 &amp; w_8 &amp; w_9\\end{bmatrix}=\\begin{bmatrix} 1 &amp; 2 &amp; 1 \\\\ 2 &amp; 4 &amp; 2 \\\\ 1 &amp; 2 &amp; 1\\end{bmatrix}$$ 加权方案： 中心子像素的加权 是角子像素的4倍，是其它像素的2倍，对九个子像素的每个网格所计算出的亮度进行平均 然后求出所有中心落于直线段内的子像素 最后计算所有这些子像素对原像素亮度贡献之和 裁剪算法 裁剪： 使用计算机处理图形信息时，计算机内部存储的图形往往比较大，而屏幕显示的只是图形的一部分 因此需要确定图形哪些部分落在显示区之内，哪些落在显示区之外。这个选择的过程就称为裁剪 最简单的裁剪方法是把各种图形扫描转换为点之后，再判断点是否在窗口内。 直线裁剪算法演变 点的裁剪 对于任意一点P（x,y），若满足下列两对不等式： $x_{left}≤x≤x_{right}$$y_{bottom}≤y≤y_{top}$ 则点P在矩形窗口内；否则，点P在矩形窗口之外 判断图形中每个点是否在窗口内，太费时，一般不可取 直线的裁剪 要裁剪一条直线段，首先要判断： 它是否完全落在裁剪窗口内？ 它是否完全在窗口外？ 如果不满足以上两个条件，则计算它与一个或多个裁剪边界的交点 常用的裁剪算法有三种，即Cohen-Sutherland、中点分割法和Liang- Barsky裁剪算法 Cohen-Sutherland算法又称为编码裁剪算法，算法的基本思想是对母条直线段分三种情况处理： 若点p1和p完全在裁剪窗口内，则“简取”之，即保留这条直线 若点$p_1(x_1,y_1)$和$p_2(x_2,y_2)$均在窗口外，且满足下列四个条件之一： $$\\begin{cases}x_1&lt;x_{left}且x_2&lt;x_{left}\\\\x_1&gt;x_{right}且x_2&gt;x_{right}\\\\y_1&lt;y_{bottom}且y_2&lt;y_{bottom}\\\\y_1&gt;y_{top}且y_2&gt;y_{top}\\end{cases}$$ 对这四种类型的直线，“简弃”之 （3）如果直线段既不满足“简取”的条件，也不满足“简弃”的条件 需要对直线段按交点进行分段，分段后判断直线是“简取”还是”简弃” 每条线段的端点都赋以四位二进制码$D_3D_2D_1D_0$，编码规则如下： 若$x&lt;x_{left}$,则$D_0=1$，否则$D_0=0$ 若$x&gt;x_{right}$ ，则$D_1=1$，否则$D_1=0$ 若$y&lt; y_{buttom}$，则$D_2=1$，否则$D_2=0$ 若$y&gt;y_{top}$，则$D_3=1$，否则$D_3=0$ 窗口及其延长线所构成了9个区域。根据该编码规则： $D_0$对应窗口左边界 $D_1$对应窗口右边界 $D_2$对应窗口下边界 $D_3$对应窗口上边界 裁剪一条线段时，先求出端点$p_1$和$p_2$的编码$code_1$和$code_2$ 然后进行二进制“或”运算和“与”运算： 若$code_1|code_2=0$，对直线段应”简取”之； 若$code_1 &amp; code_2≠0$，对直线段可”简弃”之； 若上述两条件均不成立，则需求出直线段与窗口边界的交点在交点处把线段一分为二。 运算符 名称 例子 运算功能 ~ 位反 ~b 求b的位反 &amp; 与运算 b&amp;c b和c位与 | 或运算 b|c b和c位或 ^ 异或运算 b^c b和b位异或 举例： 首先对$P_1、P_2$进行编码或$_{0100}^{0001} \\over _{0101}$ 与$_{0100}^{0001} \\over _{0000}$ 对$P_2、P_3$重复上述处理 或$_{0000}^{0100} \\over _{0100}$ 与$_{0000}^{0100} \\over _{0000}$ 剩下的直线段（$P_3、P_4$）再进行进一步判断， $code_1、code_2=0$，全在窗口内，简取之 此算法存在的问题：最坏情况下，被裁剪线段与窗口4条边计算交点，然后所得的裁剪结果却可能是全部舍弃 中点分割算法和上面讲到的Cohen- Sutherland算法一样，首先对直线段的端点进行编码。 把线段和窗口的关系分成三种情况： 完全在窗口内 完全在窗口外 和窗口有交点 中点分割算法的核心思想是通过二分逼近来确定直线段与窗口的交点。 注意： 若中点不在窗口内，则把中点和离窗口边界最远点构成的线段丢掉，以线段上的另一点和该中点再构成线段求其中点 如中点在窗口内，则又以中点和最远点构成线段，并求其中点，直到中点与窗口边界的坐标值在规定的误差范围内相等 Liang-Barsky裁剪算法核心思路直线参数方程的标准形式为：$\\begin{cases}x=x_0+tcosα\\\\y=y_0+tsinα\\end{cases}(t为参数)$ 用参数方程表示一条直线 $\\begin{cases}x=x_1+u·(x_2-x_1)=x_1+Δx·u\\\\y=y_1+u·(y_2-y_1)=y_1+Δy·u\\end{cases}(0≤u＜1)$ 把被裁剪的直线段看成是一条有方向的线段，把窗口的四条边分成两类：入边和出边。 裁剪结果的线段起点是直线和两条入边的交点以及始端点三个点里最前面的一个点，即参数u最大的那个点； 裁剪线段的终点是和两条出边的交点以及端点最后面的一个点，取参数$u$最小的那个点。 值得注意的是，当$u$从$-∞$到$+∞$遍历直线时，首先对裁剪窗口的两条边界直线（下边和左边）从外面向里面移动，再对裁剪窗口两条边界直线（上边和右边）从里面向外面移动。 如果用$u_1$，$u_2$分别表示线段（$u_1≤u_2$）可见部分的开始和结束 $u_1= max(0, u_r, u_b)$$u_2= min(1,u_t,u_r)$ 计算过程由参数方程可知：$\\begin{cases}x_{left}≤x_1+u·△x≤x_{right}\\\\y_{bottom}≤y_1+u·Δy≤y_{top}\\end{cases}$ $\\begin{cases}u·(-Δx)≤x_1-x_{left}\\\\u·Δx≤x_{right}-x_{1}\\\\u·(-Δy)≤y_1-y_{bottom}\\\\u·Δy≤y_{top}-y_{1}\\end{cases}$ 令：$\\begin{cases}p_1=-Δx，q_1=x_1-x_{left}\\\\p_2=Δx，q_2=x_{right}-x_1\\\\p_3=-Δy，q_3=y_1-y_{bottom}\\\\p_4=Δy，q_4=y_{top}-y_1\\end{cases}$ 于是有：$u·p_k≤q_k，k=1,2,3,4$ $\\begin{cases}p_1=-Δx，q_1=x_1-x_{left}\\\\p_3=-Δy，q_3=y_1-y_{bottom}\\\\入边：左边和下边\\end{cases}$，$\\begin{cases}p_2=Δx，q_2=x_{right}-x_1\\\\p_4=Δy，q_4=y_{top}-y_1\\\\出边：右边和上边\\end{cases}$ （1）分析$P=0$的情况 若$P_1=P_2=0$ 若$P_3=P_4=0$ 可知，任何平行于窗口某边界的直线，其$p_k=0$ 如果还满足$q&lt;0$ 则线段完全在边界外，应舍弃该线段 （2）当$p≠0$时 当$p_k&lt;0$时，线段从裁剪边界延长线的外部延伸到内部，是入边交点 当$p_k&gt;0$时，线段从裁剪边界延长线的内部延伸到外部，是出边交点 线段和窗口边界一共有四个交点，根据$p$的符号，就知道哪两个是入交点，哪两个是出交点 当$p_k&lt;0$时：对应入边交点 当$p_k&gt;0$时：对应出边交点 共四个u值，再加上$u=0、u=1$两个端点值，总共六个值 把$p&lt;0$的两个$u$值和0比较找最大，把$p&gt;0$的两个u值和1比较找最小， 这样就得到两个端点的参数值 $u_k={q_k \\over p_k}(p_k≠0，k=1,2,3,4)$ $u$是窗口边界及其延长线的交点的对应参数值 分别计算$u_{max}$和$u_{min}$ $\\begin{cases}u_{max}=max(0,u_k|{p_k&lt;0},u_k|_{p_k&lt;0})\\\\u_{min}=min(u_k|_{p_k&gt;0},u_k|{p_k&gt;0},1)\\end{cases}$ 注意：$p_k&lt;0$，代表入边；$p_k&gt;0$代表出边 若$u_{max}&gt;u_{min}$，则直线段在窗口外，删除该直线 若$u_{max}≤u_{min}$，将$u_{max}$和$u_{min}$代回直线参数方程，即求出直线与窗口的两实交点坐标。 注意：因为对于实交点$0≤u≤1$，因此$u_{max}$不能小于0，$u_{min}$不能大于1 算法步骤 输入直线段的两端点坐标$(x_1,y_1)、(x_2，y_2)$，以及窗口的四条边界坐标$：wxl、wxr、wyb和wyt$ 若$ΔX=0$，则 $p_1=p_2=0$，此时进一步判断是否满足$q_1&lt;0$或$q_2&lt;0$ 若满足，则该直线段不在窗口内，算法转（7）结束。 否则满足$q1≥0且q2≥0$，则进一步计算$u_{max}$和$u_{min}$： $$\\begin{cases}u_{max}=max(0,u_k|_{p_k&lt;0})\\\\u_{min}=min(1,u_k|_{p_k&gt;0})\\end{cases}$$ 其中，$u_k={q_k \\over p_k}(p_k≠0,k=3,4)$。算法转(5) 若$Δy=0$，则$p_3=p_4=0$，此时进一步判断是否满足$q_3&lt;0$或$q_4&lt;0$， 若满足，则该直线段不在窗口内，算法转（7）结束。 否则，满足$q_3≥0$且$q_4≥0$，则进一步计算$u_{max}$和$u_{min}$ $$\\begin{cases}u_{max}=max(0,u_k|_{p_k&lt;0})\\\\u_{min}=min(1,u_k|_{p_k&gt;0})\\end{cases}$$ 其中，$u_k={q_k \\over p_k}(p_k≠0,k=3,4)$。算法转(5) 若上述两条均不满足，则有$p_k≠0(k=1,2,3,4)$，此时计算$u_{max}$和$u_{min}$ $$\\begin{cases}u_{max}=max(0,u_k|{p_k&lt;0},u_k|{p_k&lt;0})\\\\u_{min}=min(1,u_k|{p_k&gt;0},u_k|{p_k&gt;0})\\end{cases}$$ 其中，$u_k={q_k \\over p_k}(p_k≠0,k-3,4)$ 求得$u_{max}$和$u_{min}$后，进行判断： 若$u_{max}&gt;u_{min}$，则直线段在窗口外，算法转（7）。 若$u_{max}≤u_{min}$，利用直线的参数方程： $$\\begin{cases}x=x_1+u·(x_2-x_1)\\\\y=y_1+u·(y_2-y_1)\\end{cases}$$ 利用直线的扫描转换算法绘制在窗口内的直线段。 结束 算法举例 令：$\\begin{cases}p_1=-Δx，q_1=x_1-x_{left}\\\\p_2=Δx，q_2=x_{right}-x_1\\\\p_3=-Δy，q_3=y_1-y_{bottom}\\\\p_4=Δy，q_4=y_{top}-y_1\\end{cases}$ 对于直线AB，有：$\\begin{cases}p_1=0，q_1=10\\\\p_2=0，q_2=-2\\\\p_3=-4，q_3=4\\\\p_4=4，q_4=2\\end{cases}$，由于$q_2&lt;0$，判断AB完全在右边界之右 对于直线CD，有：$\\begin{cases}p_1=0，q_1=2\\\\p_2=0，q_2=6\\\\p_3=-3，q_3=5\\\\p_4=3，q_4=1\\end{cases}$，由于$p_1、p_2=0$，$q_1、q_2&gt;0$，采取进一步判断 $$u_3={q_3 \\over p_3}=-{5 \\over 3},u_4={q_4 \\over p_4}={1\\over 3}$$ $$∴\\begin{cases}u_{max}=max(0,u_k|_{p_k&lt;0})=max(0,-{5 \\over 3})=0\\\\u_{min}=min(1,u_k|_{p_k&gt;0})=min(1,{1 \\over 3})={1 \\over 3}\\end{cases}$$ 此时$u_{max}≤u_{min}$，分别代入直线的参数方程：$$\\begin{cases}x=x_1+u·(x_2-x_1)\\\\y=y_1+u·(y_2-y_1)\\end{cases}$$得到裁减后直线的两个端点是$(3,7)$和$(3,8)$。 对于直线EF，有：$\\begin{cases}p_1=-2，q_1=5\\\\p_2=2，q_2=3\\\\p_3=-3，q_3=4\\\\p_4=3，q_4=2\\end{cases}$，由于$p_{1,2,3,4}≠0$，$q_{1,2,3,4}&gt;0$，采取进一步判断 $$u_1={q_1 \\over p_1}=-{5 \\over 2},u_2={q_2 \\over p_2}={3\\over 2}\\u_3={q_3 \\over p_3}=-{4 \\over 3},u_4={q_4 \\over p_4}={2\\over 3}$$ $$∴\\begin{cases}u_{max}&amp;=max(0,u_k|{p_k&lt;0},u_k|{p_k&lt;0})\\\\&amp;=max(0,-{5 \\over 2},-{4 \\over 3})=0\\\\\\\\u_{min}&amp;=min(1,u_k|{p_k&gt;0},u_k|{p_k&gt;0})\\\\&amp;=min(1,{3 \\over 2},{2 \\over 3})={2 \\over 3}\\end{cases}，此时u_{max}&lt;u_{min}$$ 分别代入直线的参数方程：$$\\begin{cases}x=x_1+u·(x_2-x_1)\\\\y=y_1+u·(y_2-y_1)\\end{cases}$$得到裁减后直线的两个端点是$(6,6)$和$(8,9)$。 多边形裁剪 多边形裁剪算法的输出应该是裁剪后的多边形边界的顶点序列 需要构造能产生一个或多个封闭区域的多边形裁剪算法 Sutherland-Hodgeman多边形裁剪 该算法的基本思想是将多边形边界作为一个整体，每次用窗口的一条边对要裁剪的多边形和中间结果多边形进行裁剪，体现一种分而治之的思想 根据多边形每一边与窗口边所形成的位置关系，沿着多边形依次处理顶点，会遇到四种情况(方向为从端点S到端点P)： S在不可见侧面，而P在可见侧，交点与点P均被加入到输出顶点表中 是S和P都在可见侧，则P被加入到输出顶点表中 S在可见侧，而P在不可见侧，则交点被加入到输出顶点表 如果S和P都在不可见侧，输出顶点表中不增加任何顶点 算法不足之处：在处理凹多边形时会产生多余线段 文字裁剪字符并不是由直线段组成的。文字裁剪包括以下几种： 串精度裁剪 当字符串中的所有字符都在裁剪窗口内时，就全部保留它，否则舍弃整个字符串。 字符精度裁剪 在进行裁剪时，任何与窗口有重叠或落在窗口边界以外的字符都被裁剪掉。 笔划/像素精度裁剪 将笔划分解成直线段对窗口作裁剪。需判断字符串中各字符的哪些像素、笔划的哪一部分在窗口内，保留窗口内部分，裁剪掉窗口外的部分。 消隐算法什么是消隐 当我们观察空间任何一个不透明的物体时，只能看到该物体朝冋我们的那些表面，其余的表面由于被物体所遮挡我们看不到 如果把可见和不可见的线都画出来，对视觉会造成多义性 要消除二义性，就必须在绘制时消除被遮挡的不可见的线或面，习惯上称作消除隐藏线和隐藏面，简称为消隐 消隐的分类按消隐对象分类 线消隐消隐对象是物体上的边，消除的是物体上不可见的边 面消隐消隐对象是物体上的面，消除的是物体上不可见的面，通常做真实感图形消隐时用面消隐 按消隐空间分类物体空间的消隐算法 此类算法通常用于线框图的消隐 以场景中的物体为处理单元。假设场景中有$k$个物体，将其中一个物体与其余$k-1$个物体逐一比较仅显示它可见表面以达到消隐的目的 在物体空间里典型的消隐算法有两个：Roberts算法和光线投射法 Roberts算法 基本步骤 逐个的独立考虑每个物体自身，找出为其自身所遮挡的边和面（自消隐）； 将每一物体上留下的边再与其它物体逐个的进行比较，以确定是完全可见还是部分或全部遮挡（两两物体消隐）； 确定由于物体之间的相互贯穿等原因，是否要形成新的显示边等，从而使被显示各物体更接近现实 光线投射求光线与场景的交点，该光线就是所谓的视线（如视点与像素连成的线）一条视线与场景中的物体可能有许多交点，求出这些交点后需要排序，在前面的才能被看到。人的眼睛可以一目了然，但计算机做需要大量的运算 图像空间的消隐算法 这类算法是消隐算法的主流 以屏幕窗口内的每个像素为处理单元。 确定在每一个像素处，场景中的$k$个物体哪一个距离观察点最近，从而用它的颜色来显示该像素 Z缓冲区（Z-Buffer）算法 Z缓冲器算法也叫深度缓冲器算法，属于图像空间消隐算法 算法原理该算法有帧缓冲器和深度缓冲器。 对应两个数组： intensity(x,y)属性数组（帧缓冲器） depth(x,y)深度数组（z-buffer） 存储图像空间 每个可见像素的光强或颜色 存放图像空间 每个可见像素的z坐标 算法思想： 先将Z缓冲器中各单元的初始值置为最小值。 当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z缓冲器的单元中） 如果大于原来的z值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色 Z-Buffer算法的优点 z- Buffer算法比较简单，也很直观 在像素级上以近物取代远物。与物体在屏幕上的出现顺序是无关紧要的，有利于硬件实现 Z-Buffer算法的缺点 占用空间大 没有利用图形的相关性与连续性，这是Z-Buffer算法的严重缺陷 算法改进 一般认为，Z-Buffer算法需要开一个与图象大小相等的缓存数组zb，实际上，可以改进算法，只用一个深度缓存变量zb 关键问题：判断像素点$(i,j)$是否在$p_k$的投影多边形之内，不是一件容易的事。 节省了空间但牺牲了时间。计算机的很多问题就是在时间和空间上找平衡。 点与多边形的包含性检测方法射线法由被测点P处向$y=-∞$方向作射线交点个数是奇数，则被测点在多边形内部交点个数是偶数，表示在多边形外部。 若射线正好经过多边形的顶点，则采用“左开右闭”的原则来实现 即：当射线与某条边的顶点相交时，若边在射线的左侧，则交点有效，计数；若边在射线的右侧，则交点无效，不计数 用射线法来判断一个点是否在多边形内的弊端： 计算量大 不稳定 弧长法以p点为圆心，作单位圆，把边投影到单位圆上，对应一段段弧长，规定逆时针为正，顺时针为负，计算弧长代数和： 代数和为0，点在多边形外部 代数和为2π，点在多边形内部 代数和为π，点在多边形边上 ####### 以顶点符号为基础的弧长累加方法 p是被测点，按照弧长法，p点的代数和为$2\\pi$ 不计算角度，做一个规定来取代原来的弧长计算： $p_1$符号 $p_n$符号 弧长变化 象限变化 (+,+) (+,+) 0 ①→① (+,+) (-,+) $\\pi \\over 2$ ①→② (+,+) (-,-) $±\\pi$ ①→③ (+,+) (+,-) $-{\\pi \\over 2}$ ①→④ … … … … 这样当要计算代数和的时候，就不要去投影了，只要根据点所在的象限一下子就判断出多少度，这样几乎没有什么计算量，只有一些简单的判断，效率非常高 区间扫描线算法该算法放弃Z-Buffer的思想，是一个新的算法，这个算法被认为是消隐算法中最快的之一 扫描线的交点把这条扫描线分成了若干个区间，每个区间上必然是同样一种颜色 对于有重合的区间，如$a_6a_7$这个区间，要么显示F2的颜色，要么显示F3的颜色，不会出现颜色的跳跃 如果把扫描线和多边形的这些交点都求出来，对每个区间，只要判断一个像素的要画什么颜色，那么整个区间的颜色都解决了，这就是区间扫描线算法的主要思想 如何确定小区间的颜色？ 小区间上没有任何多边形，如$[a_4，a_5]$，用背景色显示 小区间只有一个多边形，如$[a_1，a_2]$，显示该多边形的颜色 小区间上存在两个或两个以上的多边，比如$[a_6，a_7]$，必须通过深度测试判断哪个多边形可见 这个算法存在几个问题： 真的去求交点？——可以利用增量算法简化求交 每段区间上要求z值最大的面，这就存在一个问题。如何知道在这个区间上有哪些多边形是和这个区间相关的？ 区域子分割(Warnock)消隐算法 Warnock算法是图像空间中非常经典的一个算法 Warnock算法的重要性不在于它的效率比别的算法高，而在于采用了分而治之的思想，利用了堆栈的数据结构 把物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口内目标足够简单，可以显示为止 这些情况下，画面足够简单，可以立即显示 窗口中仅包含一个多边形 窗口与一个多边形相交，且窗口内无其它多边形 窗口为一个多边形所包围 窗口与一个多边形相分离 如何判别一个多边形和窗口是分离的？ 当满足下列条件时，多边形和窗冂分离： $$x_{min}&gt;x_R \\space {\\color{red}or}\\space x_{max}&lt;x_L \\space {\\color{red}or}\\space y_{min}&gt;y_T \\space {\\color{red}or}\\space y_{max}&lt;y_B$$ 如何判别一个多边形在窗口内？ 当满足下列条件时，多边形被窗口包含： $$x_{min}≥ x_L \\space {\\color{red}\\&amp;}\\space x_{max}≤x_R \\space {\\color{red}\\&amp;}\\space y_{min}≥y_B \\space {\\color{red}\\&amp;}\\space y_{max}≤y_T$$ 多边形与窗口相交的判别：可以采用直线方程作为判别函数来判定一个多边形是否与窗口相交 窗口有多个多边形投影面，如何显示？算法步骤： 如果窗口内没有物体则按背景色显示 若窗口内只有一个面，则把该面显示出来 否则，窗口内含有两个以上的面，则把窗口等分成四个子窗口。对每个小窗口再做上述同样的处理。这样反复地进行下去 把四个子窗口压在一个堆栈里（后进先出） 如果到某个时刻，窗口仅有像素那么大，而窗内仍有两个以上的面，如何处理？这时不必再分割，只要取窗口内最近的可见面的颜色或所有可见面的平均颜色，作为该像素的值 二维图形变换向量向量的线性组合有两种特殊的线性组合在计算机图形学中很重要 仿射组合如果线性组合的系数$a_1,a_2,…a_m$的和等于1，那么它就是仿射组合 $$a_1+a_2+…+a_m=1$$ 凸组合凸组合在数学中具有重要的位置，在图形学中也有很多应用。 凸组合是对仿射组合加以更多的限制得来的 $$a_1+a_2+…+a_m=1(i=1,2,…,m,且a_i≥0)$$ 向量的度量和单位向量 对n维向量：$w=(w_1,w_2,…,w_n)$，它的长度（大小）为： $$|w|=\\sqrt{w_1^2+w_2^2+…+w_n^2}$$ 有时经常需要缩放向量，使它的长度为1，这一过程叫恃量的归一化。 归一化的结果叫单位向量： $$\\hat{a}={a\\over |a|}$$ 向量运算向量的点积$$\\vec{a}=(a_1,a_2),\\vec{b}=(b_1,b_2)，则\\vec{a}·\\vec{b}=a_1b_1+a_2b_2$$ 也就是说，计算点积时，只需将两个向量相应的分量相乘，然后将结果相加即可：$$d=\\vec{v}·\\vec{w}=\\displaystyle\\sum_{i=1}^n{v_iw_i}$$点积最重要的应用就是计算两个向量的夹角，或着两条直线的夹角$$\\vec{b}·\\vec{c}=|\\vec{b}||\\vec{c}|\\cos\\theta(\\theta为夹角)$$ $$\\cos\\theta={\\vec{b}·\\vec{c}\\over |\\vec{b}||\\vec{c}|}=\\hat{\\vec{b}}·\\hat{\\vec{c}}$$ 由于两个向量的点积和它们之间夹角的余弦成正比，可以得出以下关于两个非零向量夹角与点积的关系：$$\\begin{cases}\\vec{b}·\\vec{c}&gt;0,\\theta&lt;90°\\\\vec{b}·\\vec{c}=0,\\theta=90°\\\\vec{b}·\\vec{c}&lt;0,\\theta&gt;90°\\end{cases}$$ 余弦定理和新闻的分类 谷歌、百度的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放到一类中 如何设计一个算法来算出任意两篇新闻的相似性？ 用一个向量来描述一篇新闻当夹角的余弦接近于1时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关 向量的叉积两个向量的仅积是另一个三维向量。叉积只对三维向量有意义。 它有许多有用的属性，但最常用的一个是它与原来的两个向量都正交。$$\\vec{a}=(a_x,a_y,a_z),\\vec{b}=(b_x,b_y,b_z)$$ $$\\vec{a}×\\vec{b}=\\begin{vmatrix}i &amp; j &amp; k\\a_x &amp; a_y &amp; a_z\\b_x &amp; b_y &amp; b_z\\end{vmatrix}$$ $\\vec{a}×\\vec{b}$和$\\vec{a}、\\vec{b}$两个向量都正交 $\\vec{a}×\\vec{b}$的长度等于由$\\vec{a}$和$\\vec{b}$决定的平行四边形面积：$\\vec{a}×\\vec{b}=|\\vec{a}||\\vec{b}|\\sin\\theta$ 图形坐标系坐标系的基本概念 坐标系是建立图形与数之间对应联系的参考系 坐标系的分类 从维度上看，可分为一维、二维、三维坐标系 从坐标轴之间的空间关系来看，可分为直角坐标系、极坐标系、圆柱坐标系、球坐标系等 在计算机图形学中，从物体（场景）的建模，到在不同显示设备上显示、处理图形时同样使用一系列的坐标系 显然，希望将程序中用于描述对象几何信息的数值，和那些用于表示对象中大小和位置的数值区分开来 前者通常被看作一个建模(modeling)的任务，后者是一个观察(viewing)的任务 图形显示的过程就是几何（对象）模型在不同坐标系之间的映射变换 计算机图形学中坐标系的分类 世界坐标系 程序员可以用最适合他们手中问题的坐标系来描述对象，并且可以自动的缩放和平移图形，使得其能正确地在屏幕窗口中显示 世界坐标系是一个公共坐标系，是现实中物体或场景的统一参照系。计算机图形系统中涉及的其它坐标系都是参照它进行定义的 建模坐标系 又称为局部坐标系。每个物体（对象）有它自己的局部中心和坐标系 建模坐标系独立于世界坐标系来定义物体的几何特性 观察坐标系 观察坐标系主要用于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述 依据观察窗口的方向和形状在世界坐标系中定义的坐标系称为观察坐标系。观察坐标系用于指定图形的输出范围 二维观察变换的一般方法是在世界坐标系中指定一个观察坐标系统，以该系统为参考通过选定方向和位置来制定矩形剪裁窗口 设备坐标系 适合特定输出设备输出对象的坐标系。 比如屏幕坐标系在多数情况下，对于每一个具体的显示设备，都有一个单独的坐标系统 规范化坐标系 规范化坐标系独立于设备，能容易地转变为设备坐标系，是一个中间坐标系。 为使图形软件能在不同的设备之间移植，采用规范化坐标，坐标轴取值范围是0-1 图形变换图形变换的用途图形变换和观察是计算机图形学的基础内容之一，也是图形显示过程中不可缺少的一个环节 一个简单的图形，通过各种变换（如：比例、旋转、镜象、错切、平移等）可以形成一个丰富多彩的图形或图案 图形变换的基本原理 仿射变换（Affine Transformation 或 Affine Map）是一种二维坐标到二维坐标之间的线性变换 “平直性”。即：直线经过变换之后依然是直线 “平行性”。即：平行线依然是平行线，且直线上点的位置顺序不变 满足下列式子 $$\\begin{cases}x’=ax+by+m\\\\y’=cx+dy+n\\end{cases}$$ 称为二维仿射变换(Affine transformation)，其中坐标x’和y都是原始坐标x和y的线性函数参数a,b,c,d,m和n是函数的系数 齐次坐标在二维平面内，我们是用一对坐标值$(x,y)$来表示一个点在平面内的确切位置，或着说是用一个向量$(x,y)$来标定一个点的位置 假如变换前的点坐标为$(x,y)$，变换后的点坐标为$(x*,y*)$ 这个变换过程可以写成如下矩阵形式：$$[x*,y*]=[x,y]·M$$ $$\\begin{cases}x*=a_1x+b_1y+c_1\\\\y*=a_2x+b_2y+c_2\\end{cases}$$ $$[x*,y*]=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}a_1 &amp; a_2\\b_1 &amp; b_2\\c_1 &amp; c_2\\end{bmatrix}$$ 上两式是完全等价的。对于向量(x1,y1)，可以在几何意义上理解为是在第三维为常数的平面上的一个二维向量。 这种用三维向量表示二维向量，或者一般而言，用一个$n+1$维的向量表示一个n维向量的方法称为齐次坐标表示法 如n维向量$(p_1,p_2,…,p_n)$表示为$(hp_1,hp_2,…,hp_n,h)$，其中h称为哑坐标。 普通坐标与齐次坐标的关系为“一对多”：$普通坐标×h \\rightarrow 齐次坐标$ 当$h=1$时，产生的齐次坐标称为“规格化坐标”，因为前n个坐标就是普通坐标系下的n维坐标 基本几何变换平移变换平移是指将p点沿直线路径从一个坐标位置移到另一个坐标位置的重定位过程 即新的坐标分别在x方向和y方向增加了一个增量和，使得：$$\\begin{cases}x*=x+T_x\\\\y*=y+T_y\\end{cases}$$$T_x,T_y$称为平移矢量$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\T_x &amp; T_y &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x+T_x &amp; y+T_y &amp; 1\\end{bmatrix}\\end{split}$$ 平移是一种不产生变形而移动物体的刚体变换，即物体上的每个点移动相同数量的坐标 比例变换比例变换是指对p点相对于坐标原点沿×方向放缩$S_x$倍，沿y方向放缩$S_y$倍。其中$S_x$和$S_y$称为比例系数$$\\begin{cases}x*=x·S_x\\\\y*=y·S_y\\end{cases}$$比例变换的齐次坐标计算形式如下：$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}S_x &amp; 0 &amp; 0\\\\0 &amp; S_y &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}S_x·x &amp; S_y·y &amp; 1\\end{bmatrix}\\end{split}$$ 缩放系数$S_x$和$S_y$可赋予任何正整数。值小于1缩小物体的尺寸，值大于1则放大物体，都指定为1，物体尺寸就不会改变 当$S_x=S_y$时，变换成为整体比例变换，用以下矩阵进行计算：$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; S\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; S\\end{bmatrix}=\\begin{bmatrix}x\\over S &amp; y\\over S &amp; 1\\end{bmatrix}\\end{split}$$整体比例变换时，若S&lt;0，图形整体缩小；若S&gt;1，图形整体放大；若0&lt;S&lt;1，发生关于原点的对称等比变换 对称变换对称变换也称为反射变换或镜像变换，变换后的图形是原图形关于某一轴线或原点的镜像。 举例 关于x轴对称点P经过关于X轴的对称变换后形成点P，则$x*=x$且$y*=-y$，写成齐次坐标的计算形式为： $$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; -y &amp; S\\end{bmatrix}\\end{split}$$ 旋转变换二维旋转是指将P点绕坐标原点转动某个角度θ（逆时针为正，顺时针为负）得到新的点P的重定位过程 首先确定当基准点为坐标原点时，点位置P旋转的变换方程 在极坐标系中点的原始坐标为：$\\begin{cases}x=r\\cos\\alpha\\\\y=r\\sin\\alpha\\end{cases}$ 应用标准三角特性，利用角度α和θ将转换后的坐标表示为：$$\\begin{cases}x*=r\\cos(\\alpha+\\theta)=r\\cos\\alpha\\cos\\theta-r\\sin\\alpha\\sin\\theta\\\\y*=r\\sin(\\alpha+\\theta)=r\\cos\\alpha\\sin\\theta+r\\sin\\alpha\\cos\\theta\\end{cases}$$将$\\begin{cases}x=r\\cos\\alpha\\\\y=r\\sin\\alpha\\end{cases}$代入，就得到相对于原点在位置$(x,y)$处的点旋转θ角的变换方程：$$\\begin{cases}x*=r\\cos(\\alpha+\\theta)=x\\cos\\theta-y\\sin\\theta\\\\y*=r\\sin(\\alpha+\\theta)=x\\sin\\theta+y\\cos\\theta\\end{cases}$$ 因此二维图形绕原点逆时针旋转θ角的齐次坐标计算形式可写为：$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}·\\begin{bmatrix}\\cos\\theta &amp; \\sin\\theta &amp; 0 \\\\-\\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix} x·\\cos\\theta-y·\\sin\\theta &amp; x·\\sin\\theta·\\cos\\theta &amp; 1 \\end{bmatrix}\\end{split}$$ 因此二维图形绕原点顺时针旋转θ角的齐次坐标计算形式可写为：$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}\\cos(-\\theta) &amp; \\sin(-\\theta) &amp; 0\\\\-\\sin(-\\theta) &amp; \\cos(-\\theta) &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$ 错切变换在图形学的应用中，有时需要产生弹性物体的变形处理，这就要用到错切变换 x值或y值越小，错切量越小；x值或y值越大，错切量越大 其变换矩阵为：$$\\begin{split}\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; b &amp; 0\\\\c &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x+cy &amp; bx+y &amp; 1\\end{bmatrix}\\end{split}$$例：沿x方向错切 当b=0时，有：$\\begin{cases}x*=x+cy\\\\y*=y\\end{cases}$ 复合变换复合变换是指图形作一次以上的几何变换，变换结果是每次的变换矩阵相乘 在进行复合变换时，需要注意的是矩阵相乘的顺序 由于矩阵乘法不满足交换率，因此通常$T_1T_2≠T_2T_1$，即矩阵相乘的顺序不可交换 坐标系之间的变换图形变换经常需要从一个坐标系变换到另一个坐标系 为了将$p(x_p,y_p)$点从$x0y$坐标系变换到$x’0’y’$坐标系，需建立变换使$x’0’y’$坐标系与$x0y$坐标系重合 相对任意参考点的二维几何变换比例、旋转变换等均与参考点相关。 如要对某个参考点$(x_f,y_f)$作二维几何变换，其变换过程如下： 将固定点移至坐标原点，此时进行平移变换 针对原点进行二维几何变换 进行反平移，将固定点又移回到原来的位置 总结对于一个变换矩阵$T=\\begin{bmatrix}a &amp; b &amp; p\\\\c &amp; d &amp; q\\\\l &amp; m &amp; s\\end{bmatrix}$，可划分为四个部分 其中： $T_1=\\begin{bmatrix}a &amp; b\\\\c &amp; d\\end{bmatrix}$，影响图形的比例、旋转、对称、错切等变换 $T_2=\\begin{bmatrix}l &amp; m\\end{bmatrix}$，影响图形的平移变换 $T_3=\\begin{bmatrix}p\\\\q\\end{bmatrix}$，影响图形的投影变换，在二维图像显示中一般为$\\begin{bmatrix}0\\\\0\\end{bmatrix}$ $T_4=\\begin{bmatrix}s\\end{bmatrix}$，影响图形整体的比例变换 几何变换均可表示成：$P*=P·T$的形式，其中，$P$为变换前二维图形的规范化齐次坐标，$P*$为变换后的规范化齐次坐标，T为变换矩阵。 点的变换，通过变换矩阵$\\begin{bmatrix}x* &amp; y* &amp; 1\\end{bmatrix}=\\begin{bmatrix}x &amp; y &amp; 1\\end{bmatrix}·T$ 直线的变换，直线的变换可以通过对直线两端点进行变换，从而改变直线的位置和方向，$\\begin{bmatrix}x_1* &amp; y_1* &amp; 1\\\\x_2* &amp; y_2* &amp; 1\\end{bmatrix}=\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\end{bmatrix}·T$ 多边形的变换，多边形变换是将变换矩阵作用到每个顶点的坐标位置，并按新的顶点坐标值和当前属性设置来生成新的多边形，$p=\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\\\x_3 &amp; y_3 &amp; 1\\\\… &amp; … &amp; …\\\\x_n &amp; y_n &amp; 1\\end{bmatrix}$ 窗口、视区及变换 世界坐标系中要显示的区域（通常在观察坐标系内定义）称为窗口 窗口映射到显示器（设备）上的区域称为视区 观察变换 将窗口内的图形在视区中显示出来，必须经过将窗口到视区的变换处理，这种变换就是观察变换（Viewing Transformation） 窗口到视区的映射 为了全部、如实地在视区中显示出窗口内的图形对象，就必须求出图形在窗口和视区间的映射关系 需要根据用户所定义的参数，找到窗口和视区之间的坐标对应关系 窗口到视区的映射是基于一个等式，即对每一个在世界坐标下的点$(x,y)$，产生屏幕坐标系中的一个点$(sx,sy)$ 这个映射是“保持比例”的映射 保持比例的性质，使得这个映射有线性形式： $$\\begin{cases}sx=Ax+C\\\\sy=By+D\\end{cases},其中A、B、C、D为常数$$ 首先考虑x的映射。保持比例的性质说明：$${sx-vl\\over sx-yl}={x-wl\\over wr-wl}$$ $$sx={x-wl\\over wr-wl}(vr-vl)+vl$$ $$sx={vr-vl\\over wr-wl}·x+(vl-{vr-vl\\over wr-wl}·wl)$$ A看做缩放x的部分，而C看做常数：$$A={vr-vl\\over wr-wl},C=vl-A·wl$$ 同理，y方向上保持比例性质满足：$${sy-vb\\over vt-vb}={y-vb\\over wt-wb}$$ $$B={vt-vv\\over wt-wb},D=vb-B·wb$$ 这个映射可用于任意点$(x,y)$，不管它是否在窗口之中。在窗口中的点映射到视口中的点，在窗口外的点映射到视口外的点 三维图形变换三维物体基本几何变换 三维物体的几何变换是在二维方法基础上增加了对z坐标的考虑而得到的 与二维变换类似，引入齐次坐标表示 即：三维空间中某点的变换可以表示成点的齐次坐标与四阶的三维变换矩阵相乘 $$\\begin{split}p’&amp;=\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}=p·T_{3D}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}a &amp; b &amp; c &amp; p\\\\d &amp; e &amp; f &amp; q\\\\g &amp; h &amp; i &amp; r\\\\l &amp; m &amp; n &amp; s\\end{bmatrix}\\end{split}$$ 根据$T_{3D}$在变换中所起的具体作用，进一步可将$T_{3D}$分成四个矩阵。 即：$$T_{3D}=\\begin{bmatrix}a &amp; b &amp; c &amp; p\\\\d &amp; e &amp; f &amp; q\\\\g &amp; h &amp; i &amp; r\\\\l &amp; m &amp; n &amp; s\\end{bmatrix}$$ 其中：$$T_1=\\begin{bmatrix}a &amp; b &amp; c \\\\d &amp; e &amp; f \\\\g &amp; h &amp; i \\\\\\end{bmatrix},对点进行比例、对称、旋转、错切变换$$ $$T_2=\\begin{bmatrix}l &amp; m &amp; n \\end{bmatrix},对点进行平移变换$$ $$T_3=\\begin{bmatrix}p\\\\q\\\\r\\end{bmatrix},作用是进行透视投影变换$$ $$T_4=\\begin{bmatrix}s\\end{bmatrix},作用是产生整体比例变换$$ 平移变换 若三维物体沿x,y,z方向上移动一个位置，而物体的大小与形状均不变，则称为平移变换 点P的平移变换矩阵表示如下：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_t\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\T_x &amp; T_y &amp; T_z &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x+T_x &amp; y+T_y &amp; z+T_z &amp; 1\\end{bmatrix}\\end{split}$$ 比例变换 比例变换分局部比例变换和整体比例变换 局部比例变换局部比例变换由T_{2D}中主对角线元素决定，其它元素均为零。 当对$x,y,z$方向分别进行比例变换时，其变换的矩阵表示为：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_s\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}a &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; e &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; i &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}ax &amp; ey &amp; iz &amp; 1\\end{bmatrix}\\end{split}$$ 整体比例变换整体比例变换，可用以下矩阵表示：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_s\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; s\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; s\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}{x\\over s} &amp; {y\\over s} &amp; {z\\over s} &amp; 1\\end{bmatrix}\\end{split}$$ 旋转变换三维立体的旋转变换，是指给定的三维立体绕三维空间某个指定的坐标轴旋转θ角度 旋转后，立体的空间位置将发生变化，但形状不变。 θ角的正负按右手规则确定，右手大姆指指向旋转轴的正向，其余四个手指指向旋转角的正向 绕z轴旋转三维空间立体绕z轴正向旋转时，立体上各顶点的x,y坐标改变，而z坐标不变。 而x,y坐标可由二维点绕原点旋转公式得到，因此可得：$$\\begin{cases}x*=x\\cos\\theta-y\\sin\\theta \\\\y*=xsin\\theta+y\\cos\\theta\\end{cases}$$ $$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_{R_z}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}\\cos\\theta &amp; \\sin\\theta &amp; 0 &amp; 0\\\\-\\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x·\\cos-y·\\sin\\theta &amp; x·\\sin\\theta+y·\\cos\\theta &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 绕x轴旋转同理，三维点p绕x轴正向旋转θ角的矩阵计算形式为：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_{R_x}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\cos\\theta &amp; \\sin\\theta &amp; 0\\\\0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; y·\\cos\\theta-z·\\sin\\theta &amp; y·\\sin\\theta+z·\\cos\\theta &amp; 1\\end{bmatrix}\\end{split}$$ 绕y轴旋转三维点p绕y轴正向旋转θ角的矩阵计算形式为：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_{R_y}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}\\cos\\theta &amp; 0 &amp; -\\sin\\theta &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x·\\sin\\theta+x·\\cos\\theta &amp; y &amp; z·\\cos\\theta-x·\\sin\\theta &amp; 1\\end{bmatrix}\\end{split}$$ 绕任意轴旋转 求绕任意直线旋转矩阵的原则： 任意变换的问题——基本几何变换的问题 绕任意直线旋转的问题——绕坐标轴旋转的问题 对称变换对称变换有关于坐标平面、坐标轴等的对称变换。 关于坐标平面的对称 关于xoy平面进行对称变换 $$\\begin{split}T_{F_{xy}}&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; -z &amp; 1\\end{bmatrix}\\end{split}$$ 关于yoz平面进行对称变换 $$\\begin{split}T_{F_{yz}}&amp;=\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}-x &amp; y &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 关于zox平面进行对称变换 $$\\begin{split}T_{F_{zx}}&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; -y &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 关于坐标轴对称 关于x轴进行对称变换 $$\\begin{split}T_{F_x}&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x &amp; -y &amp; -z &amp; 1\\end{bmatrix}\\end{split}$$ 关于y轴进行对称变换 $$\\begin{split}T_{F_y}&amp;=\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}-x &amp; y &amp; -z &amp; 1\\end{bmatrix}\\end{split}$$ 关于z轴进行对称变换 $$\\begin{split}T_{F_z}=\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}-x &amp; -y &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 投影变换 用于在二维平面上显示三维物体 平面几何投影的投影变换，就是把三维物体投射到投影面上得到二维平面图形 需要记住的一点是，计算机绘图是产生三维物体的二维图像。但在屏幕上绘制图形的时候，必须在三维坐标系下来考虑画法 在创建一个三维图形时，不要考虑二维平面图像 两种投影法的本质区别在于，透视投影的投影中心到投影面之间的距离是有限的；而另一个的距离是无限的 透视(中心)投影法在投影中心相对投影面 确定的情况下，空间的一个点在投影面上只存在唯一一个投影 透视投影特点： 物体的投影视图 由计算投影线与观察平面之交点而得 透视投影生成真实感视图但不保持相关比例 平行投影如果把透视投影的中心移至无穷远处，则各投影线成为相互平行的直线，这种投影法称为平行投影法。 平行投影特点： 平行投影保持物体的有关比例不变 变物体的各个面的精确视图由平行投影而得 没有给出三维物体外表的真实性表示 正投影根据投影面与坐标轴的夹角可分为两类：三视图和正轴侧图 当投影面与某一坐标轴垂直时，得到的投影为三视图，这时投影方向与这个坐标轴的方向一致； 否则，得到的投影为正轴侧图 正投影-三视图 通常所说的三视图包括主视图、侧视图和俯视图三种，投影面分别与x轴、y轴和z轴垂直 特点：物体的一个坐标面平行于投影面，其投影能反映形体的实际尺寸工程制图中常用三视图来测量形体间的距离、角度以及相互位置关系 不足：一组三视图上只有物体一个面的投影，所以三视图难以形象地表示出形体的三维性质，只有将主、侧、俯三个视图放在一起，才能综合出物体的空间形状 计算步骤： 确定三维物体上各点的位置坐标 引入齐次坐标，求出所作变换相应的变换矩 将所作变换用矩阵表示，通过运算求得三维物体上各点经变换后的点坐标值 由变换后得到的二维点绘出三维物体投影后的三视图 主视图由投影变换前后三维物体上点到主视图上点的关系 投影变换的变换矩阵应为：$$T_v=T_{xOz}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$通常称$T_v$为主视图的投影变换矩阵。 于是，由三维物体到主视图的投影变换矩阵表示为：$$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_v\\\\&amp;=\\begin{bmatrix}x &amp; 0 &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 俯视图将三维物体x0y面（又称H面）作垂直投影得到俯视图 其投影变换矩阵应为：$$T_H=T_{xOy}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ $$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_H\\\\&amp;=\\begin{bmatrix}x &amp; y &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$ 为了使俯视图与主视图都画在一个平面内，就要使H面绕x轴顺时针转90° 即应有一个旋转变换，其变换矩阵为：$$\\begin{split}T_{R_x}&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\cos(-90°) &amp; \\sin(-90°) &amp; 0\\\\0 &amp; -\\sin(-90°) &amp; \\cos(-90°) &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$ 为了使主视图和俯视图有一定的间距，还要使H面沿z方向平移一段距离$-z_0$， 其变换矩阵为：$$T_{t_z}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; -z_0 &amp; 1\\end{bmatrix}$$于是，俯视图的投影变换矩阵：$$\\begin{split}T_H&amp;=T_{xOy}·T_{R_x}·T_{t_z}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; -z_0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -z_0 &amp; 1\\end{bmatrix}\\end{split}$$ $$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_H\\\\&amp;=\\begin{bmatrix}x &amp; 0 &amp; -(y+z_0) &amp; 1\\end{bmatrix}\\end{split}$$ 侧视图将三维物体yOz面（又称W面）作垂直投影得到侧视图 其投影变换矩阵应为：$$T_W=T_{yOz}=\\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 为了使侧视图与主视图也在一个平面内，就要使W面绕轴正转90° 其旋转变换换矩阵为：$$\\begin{split}T_{R_z}&amp;=\\begin{bmatrix}\\cos90° &amp; \\sin90° &amp; 0 &amp; 0\\\\-\\sin90° &amp; \\cos90° &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$为使主视图和侧视图有一定的间距，还要使W面沿负x方向平移一段距离$-x_0$ 该平移变换矩阵为：$$T_{t_x}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\-x_0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$于是，侧视图的投影变换矩阵为：$$\\begin{split}T_W&amp;=T_{yOz}·T_{R_z}·T_{t_x}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\-x_0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\-x_0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$ $$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_W\\\\&amp;=\\begin{bmatrix}-(y+x_0) &amp; 0 &amp; z &amp; 1\\end{bmatrix}\\end{split}$$ 总结视图投影矩阵 主视图：$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_v&amp;=\\begin{bmatrix}x &amp; 0 &amp; z &amp; 1\\end{bmatrix}\\end{split}$ 俯视图：$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_H&amp;=\\begin{bmatrix}x &amp; 0 &amp; -(y+z_0) &amp; 1\\end{bmatrix}\\end{split}$ 侧视图：$\\begin{split}\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·T_W&amp;=\\begin{bmatrix}-(y+x_0) &amp; 0 &amp; z &amp; 1\\end{bmatrix}\\end{split}$ 三个视图中的y均为0，表明三个视图均落在xOz面上 正投影-正轴测图正轴测有等轴测、正二测和正三测三种： 当投影面与三个坐标轴之间的夹角都相等时 为等轴测 当投影面与两个坐标轴之间的夹角相等时 为正二测 当投影面与三个坐标轴之间的夹角都不相等时 为正三测 8.5.2.2](img/8.5.2.2.png) 空间物体的正轴测图是以V面为轴测投影面，先将物体绕Z轴转γ角，接着绕X轴转-α角，最后向V面投影。 其变换矩阵为： $$\\begin{split}T_正&amp;=T_Z·T_X·T_V\\\\&amp;=\\begin{bmatrix}\\cosγ &amp; \\sinγ &amp; 0 &amp; 0\\\\-\\sinγ &amp; \\cosγ &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\cosγ &amp; -\\sinγ &amp; 0\\\\0 &amp; \\sinγ &amp; \\cosγ &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}\\cosγ &amp; 0 &amp; -\\sinγ\\sinα &amp; 0\\\\-\\sinγ &amp; 0 &amp; -\\cosγ\\sinα &amp; 0\\\\0 &amp; 0 &amp; \\cosα &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\end{split}$$ $$即：\\begin{cases}x*=x\\cosγ-y\\sinγ\\\\y*=0\\\\z*=-x\\sinγ\\sinα-y\\cosγ\\sinα+z\\cosα\\end{cases}$$ 正等轴测图根据画法几何学，作正等轴测投影时，$γ=45°，α=-35.26°$ 将Y、α代入上式，其变换矩阵为：$$T_{正等轴测}=\\begin{bmatrix}0.7071 &amp; 0 &amp; -0.4082 &amp; 0\\\\-0.7071 &amp; 0 &amp; -0.4082 &amp; 0\\\\0 &amp; 0 &amp; 0.8165 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 正二测图做正二测图时，$γ=20.7°，α=19.47°$ 其变换矩阵为：$$T_{正二等}=\\begin{bmatrix}0.9354 &amp; 0 &amp; -0.1178 &amp; 0\\\\-0.7071 &amp; 0 &amp; -0.3118 &amp; 0\\\\0 &amp; 0 &amp; 0.9428 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 透视投影 透视投影（ Perspective Projection）是为了获得接近真实三维物体的视觉效果，而在二维的纸或者画布平面上绘图或者渲染的一种方法，能逼真地反映形体的空间形象，也称为透视图。 透视投影是3D渲染的基本概念，也是3D程序设计的基础。 $$T_{3D}=\\begin{bmatrix}a &amp; b &amp; c &amp; p\\\\d &amp; e &amp; f &amp; q\\\\g &amp; h &amp; i &amp; r\\\\l &amp; m &amp; n &amp; s\\end{bmatrix}，其中\\begin{bmatrix}p\\\\q\\\\r\\end{bmatrix}为透视投影效果$$ 一点透视 假设$q≠0，p=r=0$。然后对点$(x,y,z)$进行变换： $$\\begin{split}\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; q\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; \\color{red}qy+1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x\\over{qy+1} &amp; y\\over{qy+1} &amp; z\\over{qy+1} &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}\\end{split}$$ 当$y=0$时，得：$\\begin{cases}x’=x\\\\y’=0\\\\z’=z\\end{cases}$，说明处于y=0平面内的点，经过变换以后没有发生变化 当$y→∞$时，得：$\\begin{cases}x’=0\\\\y’={1\\over q}\\\\z’=z\\end{cases}$，说明当$y→∞$时，所有点的变换结果都集中到了y轴上的$1\\over q$处 即所有平行于y轴的直线将延伸相交于点$(0,{1\\over q}，0)$ 该点称为灭点，而像这样形成个灭点的透视变换，称为一点透视 根据同样的道理，当$p≠0$，$q=r=0$时，则将在x轴上的$1\\over q$处产生一个灭点，其坐标值为$({1\\over q},0,0)$。 这种情况下，所有平行于x轴的直线将延伸交于该点$$\\begin{split}\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; p\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}&amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; \\color{red}px+1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x\\over{px+1} &amp; y\\over{px+1} &amp; z\\over{px+1} &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix}\\end{split}$$当$r≠0，q=p=0$时，则将在z轴上的$1\\over r$处产生一个灭点，其坐标值为$(0,0,{1\\over r})$。在这种情况下，所有平行于z轴的直线将延伸交于该点。 多点透视根据一点透视的原理予以推广，如果$p,q,r$三个元素中有两个为非零元素时，将会生成两个灭点，因此得到两点透视。 如当$p≠0，r≠0$时，结果为：$$\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; p\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; r\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}=\\begin{bmatrix}x &amp; y &amp; z &amp; \\color{red}px+rz+1\\end{bmatrix}$$经过齐次化处理后结果为：$$\\begin{cases}x’={x\\over (px+rz+1)}\\\\y’={y\\over (px+rz+1)}\\\\z’={z\\over (px+rz+1)}\\end{cases}$$从以上结果可以看到： 当$x→∞$时，一个灭点在x轴上的$1\\over p$处 当$z→∞$时，一个灭点在z轴上的$1\\over r$处 同理，当p,q,r三个元素全为非零时，结果将会产生三个灭点，从而形成三点透视。产生的三个灭点分别在x轴上的$1\\over p$处、y轴上的$1\\over q$处和z轴上的$1\\over r$处 实例 一点透视 一点透视只有一个灭点。进行透视投影，要很好地考虑图面布局，以避免三维物体的平面或直线积聚成直线或点而影响直观性。 具体地说，就是要考虑下列几点： 三维形体与画面（投影面）的相对位置 视距，即视点（投影中心）与画面的距离 视点的高度 假定视点（投影中心）在z轴上（z=-d处），投影面在$xOy$面上，则一点透视的骤如下： 将三维物体平移到适当位置|、m、n 进行透视变换 最后，为了绘制的方便，向$xOy$平面作在投影变换，将结果变换到$xOy$平面上。 $$T_{p1}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\l &amp; m &amp; n &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\over d\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\color{red}0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 得到三维物体中任一点$(x,y,z)$一点透视变换矩阵形式：$$T_{p1}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\over d\\\\l &amp; m &amp; 0 &amp; {n\\over d}+1\\end{bmatrix}$$ $$\\begin{split} \\begin{bmatrix}x’ &amp; y’ &amp; z’ &amp; 1\\end{bmatrix} &amp;=\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}· \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\over d \\\\ l &amp; m &amp; 0 &amp; {n\\over d}+1 \\end{bmatrix}\\\\ &amp;=\\begin{bmatrix} {x+l}\\over{n+z\\over d} +1 &amp; {y+m}\\over {n+z\\over d}+1 &amp; 0 &amp; 1 \\end{bmatrix}\\end{split}$$ 二点透视 将物体平移到适当位置$l、m、n$ 将物体绕y轴旋转θ角 进行透视变换 最后向$xOy$面做正投影，即得二点透视图 $$\\begin{split}T_{p2}&amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\l &amp; m &amp; n &amp; 1\\end{bmatrix}·\\begin{bmatrix}\\cos\\theta &amp; 0 &amp; -\\sin\\theta &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; p\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; r\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\color{red}0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\&amp;=\\begin{bmatrix}\\cos\\theta &amp; 0 &amp; 0 &amp; p·cos\\theta-r\\sin\\theta\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\\\sin\\theta &amp; 0 &amp; 0 &amp; p·\\sin\\theta+r·\\cos\\theta\\\\l·\\cos\\theta+n·\\sin\\theta &amp; m &amp; 0 &amp; p(l·\\cos\\theta+n·\\sin\\theta+r(n·\\cos\\theta-l·\\sin\\theta)+1)\\end{bmatrix}\\end{split}$$ 三点透视 将物体平移到适当位置 将物体绕y轴旋转θ角 再绕x轴旋转α角 进行透视变换 最后向$xOy$面做正投影，即得三点透视图 曲线曲面曲线曲面基础显示、隐式和参数表示曲线和曲面的表示方程有参数表示和非参数表示之分，非参数表示又分为显式表示和隐式表示 对于一个平面曲线，显式表示一般形式是：$y=f(x)$ 在此方程中，一个x值与一个y值对应，所以显式方程不能表示封闭或多值曲线 如果一个平面曲线方程，表示成$f(x,y)=0$的形式，称之为隐式表示。 隐式表示的优点是易于判断一个点是否在曲线上 显式或隐式表示存在的问题： 与坐标轴相关 用隐函数表示不直观，作图不方便 用显函数表示存在多值性 会出现斜率为无穷大的情形 参数方程为了克服以上问题，曲线曲面方程通常表示成参数的形式 假定用t表示参数，平面曲线上任一点P可表示为：$$p(t)=[x(t),y(t)]$$ 空间曲线上任意三维点P可表示为：$$p(t)=[x(t),y(t),z(t)]$$ 它等价于笛卡儿分量表示：$$p(t)=x(t)i+y(t)j+z(t)k$$ 这样，给定一个t值，就得到曲线上一点的坐标。 假设曲线段对应的参数区间为$[a,b]$，即$a≤t≤b$。 为方便期间，可以将区间$[a,b]$规范化成$[0,1]$，参数变换为：$$t’={t-a\\over b-a}$$参数曲线一般可写成：$$p=p(t),t∈[0,1]$$ 类似地，可把曲面表示成为双参数u和v的矢量函数$$p(u,v)=p(x(u,v),y(u,v),z(u,v)),(u,v)∈[0,1]×[0,1]$$ 最简单的参数曲线是直线段，端点为P1、P2的直线段参数方程可表示为：$$p(t)=p_1+(p_2-p_1)t,t∈[0,1]$$ 位置矢量曲线上任一点的位置矢量可表示为：$$P(t)=[x(t),y(t),z(t)]$$ 切矢量选择弧长s作为参数，当Δt→0时，弦长Δs→0，但方向不能趋向于0$$\\begin{split}T&amp;={dP\\over ds}\\\\&amp;=\\lim_{Δs→0}{ΔP\\over Δs}\\end{split}$$ 根据弧长微分公式有：$$ds^2=(dx)^2+(dy)^2+(dz)^2$$ 引入参数t，可改写为：$$\\begin{split}({ds\\over dt})^2=({dx\\over dt})^2+({dy\\over dt})^2+({dz\\over dt})^2=|P’(t)|^2\\end{split}$$ $$\\begin{split}T={dP\\over ds}={dP\\over dt}·{dt\\over ds}={P’(t)\\over |P’(t)|}\\end{split}$$ 即T是单位切矢量 曲率切向量求导，求导以后还是一个向量，称为曲率，其几何意义是曲线的单位切向量对弧长的转动率，即刻画这一点的曲线的弯曲程度$$\\begin{split}k=|T’|=\\lim_{Δs→0}|{ΔT\\over Δs}|=\\lim_{Δs→0}|{T(s+Δs)-T(s)\\over Δs}|=\\lim_{Δs→0}|{Δθ\\over Δs}|\\end{split}$$曲率越大，表示曲线的弯曲程度越大 曲率k的倒数$ρ={1\\over k}$称为曲率半径。 曲率半径越大，圆弧越平缓；曲率半径越小，圆弧越陡。 法矢量法矢量是与切矢量垂直的向量 N、B构成的平面称为法平面，N、T构成的平面称为密切平面，B、T构成的平面称为从切平面 T（切矢量）、N（主法矢量）和B（副法矢量）构成了曲线上的活动坐标架$$B=T×N$$ 挠率空间曲线不但要弯曲，而且还要扭曲，即要离开它的密切平面。 为了能刻画这一扭曲程度，等价于去研究密切平面的法矢量（即曲线的副法矢量）关于弧长的变化率。 挠率$τ$的绝对值等于副法线方向（或密切平面）对于弧长的转动率$$|τ|=\\lim_{Δs}|{Δθ\\over Δs}|$$ 插值自由曲线和自由曲面一般通过少数分散的点生成，这些点叫做“型值点”、“样本点”或“控制点” 给定一组有序的数据点$P_i(i=0,1,2，…n)$，要求构造一条曲线顺序通过这些数据点，称为对这些数据点进行插值(interpolation)，所构造的曲线称为插值曲线 线性插值：假设给定函数$f(x)$在两个不同点x和x2的值，用一个线形函数：$y=ax+b$，近似代替，称为的线性插值函数 抛物线插值：已知三个点的坐标，要求构造一个抛物线函数 拟合构造一条曲线，使之在某种意义下最接近给定的数据点（但未必通过这些点），所构造的曲线为拟合曲线 在计算数学中，逼近通常指用一些性质较好的函数近似表示一些性质不好的函数。 在计算机图形学中，逼近继承了这方面的含义，因此插值和拟合都可以视为逼近 对于逼近样条，连接控制点序列的折线通常被显示出来，以提醒设计者控制点的次序 般将连接有一定次序控制点的直线序列称为控制多边形或特征多边形 光顺指曲线的拐点不能太多（有一、二阶导数等） 对平面曲线而言，相对光顺的条件是 具有二阶几何连续性（$G^2$） 不存在多余拐点和奇异点 曲率变化较小 曲线连续性当许多参数曲线段首尾相连构成一条曲线时，如何保证各曲线段在连接处具有合乎要求的连续性是一个重要问题。 假定参数曲线段$p_i$以参数形式进行描述：$$p_i=p_i(t),t∈[t_{i0},t_{i1}]$$这里讨论参数曲线两种意义上的连续性：即参数连续性和几何连续性 参数连续性 0阶参数连续性 记作$C^0$连续性，是指曲线的几何位置连接，即第一个曲线段在$t_{i1}$处的x,y,z值与第二个曲线段在$t_{(i+1)0}$处的x,y,z值相等 $$p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})$$ 1阶参数连续性 记作$C^1$连续性，指代表两个相邻曲线段的方程在相交点处有相同的一阶导数（切线）： $$p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})\\且p’i(t{i1})=p’{(i+1)}(t{(i+1)0})$$ 一阶连续性对数字化绘画及一些设计应用已经足够 2阶参数连续性 记作$C^2$连续性，指两个相邻曲线段的方程在相交点处具有相同的一阶和二阶导数。 类似地，还可定义高阶参数连续性 对于$C^2$连续性，交点处的切向量变化率相等，即切线从一个曲线段平滑地变化到另一个曲线段 二阶连续性对电影中的动画途径和很多精密CAD需求有用 经典的参数连续性在图形学里是不适合的，因为太苛刻，所以引进了几何连续性的概念 汽车曲面的设计美观要求很高，但有时候车身的一条曲线并不是参数连连续的，但人眼看上去已经是很光滑的了，因此需要一种更弱的连续性 几何连续性曲线段相连的另一个连续性条件是几何连续性。 与参数连续性不同的是，它只需曲线段在相交处的参数导数成比例即可 0阶几何连续性 记作$G^0$连续性。与0阶参数连续性的定义相同，满足： $$p_i(t_{i1})=p_{(i+1)}(t_{(i+1)0})$$ 1阶几何连续性 记作$G^1$连续性。若要求在结合处达到$G^1$连续就是说两条曲线在结合处在满足$G^0$连续的条件下，并有公共的切矢 $$Q’(0)=αP’(1)\\space(α&gt;0)$$ 2阶几何连续性 记作$G^2$连续性。就是说两条曲线在结合处在满足$G^1$连续的条件下，并有公共的曲率 !&gt;一阶导数相等和有公共切向量这两个概念差别是什么？导数相等是大小方向都相等，而公共切矢意味着方向相同但大小不等。所谓参数连续意味着导数相等，导数相等意味着两个切向量，不但方向相等而且长度也相等。条件减弱了 参数化 过三点P、P1和P2构造参数表示的插值多项式是唯一的还是有多个呢？ 插值多项式可以有无数条，这是因为对应地参数t在[0,1]中可以有无数种取法 $$t_0=0,t_1={1\\over 2},t_2=1$$ $$t_0=0,t_1={1\\over 3},t_2=1$$ $$参数方程:\\begin{cases}x(t)=a_1t^2+a_2t+a_3\\y(t)=b_1t^2+b_2t+b_3\\end{cases}$$ 插值问题实际上就是解方程组的问题。但如果参数取的不一样的话，结果是不一样的 每个参数值称为节点(knot)。对于一条插值曲线，$p_0、 p_1、p_2$这些点称为型值点 对于一条插值曲线，型值点$p_0,p_1,…,p_n$。与其参数域$t∈[t_0，t_1]$内的节点之间有一种对应关系。对于一组有序的型值点，所确定一种参数分割，称之这组型值点的参数化 例：现在给定3个点$p_0、p_1、p_2$，坐标是$(0,0)、(100,50)、(200,0)$，求一条2次的多项式曲线来插值这三个点。 假设第一个点参数$t=0$，第二个点参数取$t={1\\over 2}$，第三个点的参数取$t=1$。 即$t_1=0,t_2={1\\over 2},t_3=1$，带入参数方程$\\begin{cases}x(t)=a_1t^2+a_2t+a_3\\y(t)=b_1t^2+b_2t+b_3\\end{cases}$ 得到：$$\\begin{cases}0=x(0)=a_3\\\\0=y(0)=b_3\\end{cases}$$$$\\begin{cases}100=x({1\\over 2})={a_1\\over 4}+{a_2\\over 2}+a_3\\\\50=y({1\\over 2})={b_1\\over 4}+{b_2\\over 2}+b_3\\end{cases}$$$$\\begin{cases}200=x(1)=a_1+a_2+a_3\\\\0=y(1)=b_1+b_2+b_3\\end{cases}$$ 6个方程6个未知数，插值问题的本质是方程的个数和未知数的个数是一致的 为何取参数$t_1=0,t_2={1\\over 2},t_3=1$？因为要使参数更接近/符合点的分布。参数化的本质就是找一组恰当的参数t来匹配这一组不同的型值点。给定一组不同的型值点，就要给出不同的参数化，即不同的t值，这样才使得这条曲线美观、合理。 参数化常用方法： 均匀参数化 节点在参数轴上呈等距分布。如$0、{1\\over 10}、{2\\over 10}…$ 累加弦长参数化（根据长度的比例关系来确定t） $\\begin{cases}t_0=0\\\\t_i=t_{i-1}+|ΔP_{i-1}|,i=1,2,…,n\\end{cases};ΔP_i=P_{i+1}-P_i$ 这种参数法如实反映了型值点按弦长的分布情况，能够克服型值点按弦长分布不均匀的情况下采用均匀参数化所岀现的问题 向心参数化法 $\\begin{cases}t_0=0\\\\t_i=t_{i-1}+|ΔP_{i-1}|^{1\\over 2},i=1,2,…,n\\end{cases};ΔP_i=P_{i+1}-P_i$ 向心参数化法假设在一段曲线弧上的向心力与曲线切矢从该弧段始端至末端的转角成正比，加上一些简化假设，得到向心参数化法。此法尤其适用于非均匀型值点分布 参数曲线的代数和几何形式以三次参数曲线为例，讨论参数曲线的代数和几何形式 代数形式 $$\\begin{cases}x(t)=a_{3x}t^3+a_{2x}t^2+a_{1x}t+a_{0x}\\\\y(t)=b_{3y}t^3+b_{2y}t^2+b_{1y}t+b_{0y}\\\\z(t)=c_{3z}t^3+c_{2z}t^2+c_{1z}t+c_{0z}\\\\\\end{cases},t∈[0,1]$$ 上述代数式写成矢量式是：$$P(t)=a_3t^3+a_2t^2+a_1t+a_0,t∈[0,1]$$ 注意：$a_3，a_2，a_1，a$是参数曲线的系数，但记住不是常数而是向量。$a_3$对应刚才的$a_{3x}$、$a_{3y}$、$a_{3z}$。改变系数曲线如何变化是不清楚的，这是代数形式的缺点 几何形式 几何形式是利用一条曲线端点的几何性质来刻画一条曲线。所谓端点的几何性质，就是指曲线的端点位置、切向量、各阶导数等端点的信息。 将$P(0)$、$P(1)$、$P’(0)$和$P’(1)$简记为：$P_0、P_1、P’_0、P’_1$$$P(t)=a_3t^3+a_2t^2+a_1t+a_0,t∈[0,1]$$得到：$\\begin{cases}P_0=a+0\\\\P_1=a_3+a_2+a_1+a_0\\\\P’_0=a_1\\\\P’_1=3a_3+2a_2+a_1\\end{cases}\\implies\\begin{cases}a_0=P_0\\\\a_1=P’_0\\\\a_2=-3P_0-3P_1-2P’_0-P’_0\\\\a_3=2P_0-2P_1+P’_0+P’_1\\end{cases}$ 再代入$P(t)=a_3t^3+a_2t^2+a_1t+a_0$ 得：$P(t)=(2t^3-3t^2+1)p_0+(-2t^3+3t^2)p_1+(t^3-2t^2-t)p’_0+(t^3-t^2)p’_1$ 对上式化简，令：$$F(0)=2t^3-3t^2+1，F(1)=-2t^3+3t^2\\\\G(0)=t^3-2t^2-t，G(1)=t^3-t^2$$简化后得：$${\\color{red}*}P(t)=F_0P_0+F_1P_1+G_0P’_0+G_1P’_1,t∈[0,1]$$上式是三次Hermite曲线（三次哈密特曲线）的几何形式，几何系数是$P_0、P_1、P’_0、P’_1$；$F(0)、F(1)、G(O)、G(1)$称为调和函数（或混合函数） Bezier曲线与曲面 想法基点是在进行汽车外形设计时，先用折线段勾画出汽车的外形大致轮廓，然后用光滑的参数曲线去逼近这个折线多边形 这个折线多边形被称为特征多边形。 逼近该特征多边形的曲线被称为Bezier曲线。 定义针对Bezier曲线，给定空间n+1个点的位置矢量$P_i$ 贝塞尔把参数n次曲线表示为：$$p(t)=\\displaystyle\\sum_{i=0}^na_if_{i,n}(t)，0≤t≤1$$其中系数矢量$a_i(i=0,1,…n)$顺序首尾相接，从$a_0$的末端到$a_n$的末端所形成的折线称为控制多边形或贝塞尔多边形$$f_{i,n}(t)=\\begin{cases}1,i=0\\\\{(-t)^i\\over(i-1)!} {d^{i-1}\\over dt^{i-1}} ({(1-t)^{n-1}-1 \\over t})\\end{cases}称为贝塞尔基函数$$上式可以简化成伯恩斯坦基函数：$$B_{i,n}(t)={n!\\over i!(n-i)!}t^i(1-t)^{n-i}=C_n^it^i(1-t)^{n-i},(i=0,1,…,n)$$ $C_n^it^i(1-t)^{n-i}$正是牛顿二项式定理 一次Bezier曲线当n=1时，有两个控制点$p_0$和$p_1$，Bezier多项式是一次多项式：$$p(t)=\\displaystyle\\sum_{i=0}^1a_if_{i,1}(t)=P_0B_{0,1}(t)+P_1B_{1,1}(t)$$ $$\\begin{cases}B_{0,1}(t)={1!\\over 0!(1-0)!}t^0(1-t)^{1-0}=1-t\\\\B_{1,1}(t)={1!\\over 1!(1-1)!}t^1(1-t)^{1-1}=t\\end{cases}$$ 因此：$$p(t)=\\displaystyle\\sum_{i=0}^1a_if_{i,1}(t)=P_0B_{0,1}(t)+P_1B_{1,1}(t)\\\\=(1-t)P_0+tP_1$$这恰好是连接起点$P_0$和终点$P_1$的直线段 二次Bezier曲线当n=2时，有3个控制点$p_0、p_1和p_2$，Bezier多项式是二次多项式：$$p(t)=\\displaystyle\\sum_{i=0}^2a_if_{i,2}(t)=P_0B_{0,2}(t)+P_1B_{1,2}(t)+P_2B_{2,2}(t)$$ $$\\begin{cases}B_{0,2}(t)={2!\\over 0!(2-0)!}t^0(1-t)^{2-0}=(1-t)^2\\\\B_{1,2}(t)={2!\\over 1!(2-1)!}t^1(1-t)^{2-1}=2t(1-t)\\\\B_{2,2}(t)={2!\\over 2!(2-2)!}t^2(1-t)^{2-2}=t^2\\end{cases}$$ 因此：$$\\begin{split}p(t)&amp;=\\displaystyle\\sum_{i=0}^2a_if_{i,2}(t)&amp;=P_0B_{0,2}(t)+P_1B_{1,2}(t)+P_2B_{2,2}(t)\\\\&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2\\\\&amp;=(P_2-2P_1+P_0)t^2+2(P_1-P_0)t+P_0\\end{split}$$二次Bezier曲线为抛物线，其矩阵形式为：$$p(t)=\\begin{bmatrix}t^2 &amp; t &amp; 1\\end{bmatrix}·\\begin{bmatrix}1 &amp; -2 &amp; 1\\\\-2 &amp; 2 &amp; 0\\\\1 &amp; 0 &amp; 0\\end{bmatrix}·\\begin{bmatrix}P_0\\\\P_1\\\\P_2\\end{bmatrix},t∈[0,1]$$ 三次Bezier曲线三次Bezier曲线由4个控制点生成，这时n=3，有4个控制点$p_0、p_1、p_2$和$p_3$，Bezier多项式是三次多项式：$$p(t)=\\displaystyle\\sum_{i=0}^3a_if_{i,3}(t)=P_0B_{0,3}(t)+P_1B_{1,3}(t)+P_2B_{2,3}(t)+P_3B_{3,3}(t)$$ $$\\begin{cases}B_{0,3}(t)={3!\\over 0!(3-0)!}t^0(1-t)^{3-0}=(1-t)^3\\\\B_{1,3}(t)={3!\\over 1!(3-1)!}t^1(1-t)^{3-1}=3t(1-t)^2\\\\B_{2,3}(t)={3!\\over 2!(3-2)!}t^2(1-t)^{3-2}=3t^2(1-t)\\\\B_{3,3}(t)={3!\\over 3!(3-3)!}t^3(1-t)^{3-3}=t^3\\end{cases}，为三次Bezier曲线的基函数$$ 因此：$$p(t)=\\displaystyle\\sum_{i=0}^3a_if_{i,3}(t)=(1-t^3)P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3$$这四条基函数曲线均是三次曲线，任何三次Bezier曲线都是这四条曲线的线形组合 把 Bezier三次曲线多项式写成矩阵形式：$$\\begin{split}p(t)&amp;=\\begin{bmatrix}t^3 &amp; t^2 &amp; t &amp; 1\\end{bmatrix}·\\begin{bmatrix}-1 &amp; 3 &amp; -3 &amp; 1\\\\3 &amp; -6 &amp; 3 &amp; 0\\\\-3 &amp; 3 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}·\\begin{bmatrix}P_0\\\\P_1\\\\P_2\\\\P_3\\end{bmatrix},t∈[0,1]\\\\&amp;=T·M_{be}·G_{be}\\end{split}$$其中，$M_{be}$是三次Bezier曲线系数矩阵，为常数；$G_{be}$是4个控制点位置矢量 Bezier曲线不可能对曲线形状进行局部控制，如果改变任一控制点位置，整个曲线会受到影响 Bernstein基函数的性质 正性（非负性） 权性 基函数有n+1项，n+1个基函数的和加起来正好等1 端点性质 对称性 可以证明，假如保持n次 Bezier曲线控制多边形的顶点位置不变，而把次序颠倒过来，则此时曲线仍不变，只不过曲线的走向相反而已 递推性 即n次的Bernstein基函数可由两个n-1次的 Bernstein基函数线性组合而成。 导函数 $B’_{i,n}(t)=n[B_{i-1,n-1}(t)-B_{i,n-1}(t)],i=0,1,…,n$ 最大值 $B_{i,n}(t)$在$t={i\\over n}$处达到最大值 积分 $\\int_0^1B_{i,n}(t)dt={1\\over n+1}$ 降阶公式 $B_{i,n}(u)=(1-u)B_{i,n-l}(u)+uB_{i-l,n-l}(u)$ 一个n次Bernstein基函数能表示成两个n-1次基函数的线性和 升阶公式 Bezier曲线的性质 端点性质 顶点$p_0$和$p_n$分别位于实际曲线段的起点和终点上 一阶导数 Bezier曲线的起点和终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致 几何不变性 指某些几何特性不随坐标变换而变化的特性。Bezier曲线的形状仅与控制多边形各顶点的相对位置有关，而与坐标系的的选择无关 变差缩减性 若Bezier曲线的特征多边形是一个平面图形，则平面内任意直线与p(t)的交点个数不多于该直线与其特征多边形的交点个数，这一性质叫变差缩减性质 Bezier曲线的生成 根据定义直接生成Bezier曲线 首先给出$C^i_n$的递归计算式：$C^i_n={n!\\over i!(n-i)!}={n-i+1\\over i}C^{i-1}_n,n≥i$ 将$p(t)=\\displaystyle\\sum^n_{i=0}P_iB_{i,n}(t)$表示成分量坐标形式$$\\begin{cases}x(t)=\\displaystyle\\sum^n_{i=0}x_iB_{i,n}(t)\\\\y(t)=\\displaystyle\\sum^n_{i=0}y_iB_{i,n}(t)\\\\z(t)=\\displaystyle\\sum^n_{i=0}z_iB_{i,n}(t)\\end{cases},t∈[0,1]$$ 根据以上的公式可以直接写出绘制Bezier曲线的程序 Bezier曲线的递推(de Castel jau)算法 根据Bezier曲线的定义确定的参数方程绘制Bezier曲线，因其计算量过大，不太适合在工程上使用 Bezier曲线上的任一个点P(t)，都是其它相邻线段的同等比例(t)点处的连线，再取同等比例(t)的点再连线，一直取到最后那条线段的同等比例(t)处，该点就是Beizer曲线上的点P(t) 由(n+1)个控制点$P_i(i=0,1,…,n)$定义的n次Bezier曲线$P_0^n$。n可被定义为分别由前、后n个控制点定义的两条(n-1)次Bezier曲线$P_0^{n-1}$与$P_1^{n-1}$的线性组合 由此得到Bezier曲线的递推计算公式：$$P_i^k=\\begin{cases}P_i\\space k=0\\\\(1-t)P_i^{k-1}+tP_{i+1}^{k-1}\\space,k=1,2,…,n\\space /\\space i=0,1,…,n-k\\end{cases}$$ Bezier曲线的拼接 几何设计中，一条Bezier曲线往往难以描述复杂的曲线形状。这是由于增加特征多边形的顶点数，会引起Bezier曲线次数的提高，而高次多项式又会带来计算上的困难 采用分段设计,然后将各段曲线相互连接起来, 并在接合处保持一定的连续条件 给定两条Bezier曲线P(t)和Q(t)，相应控制点为$P(i=0,1,…,n)$和$Q(i=0,1…,m)$ 要使它们达到$G^0$连续,则：$P_n=Q_0$ 要使它们达到$G^1$连续,只要保证$P_{n-1},P_n=Q,Q_1$三点共线就行了 Bezier曲线的起点和终点处的切线方向 和特征多边形的第一条边及最后一条边的走向一致 Bezier曲线的升阶与降阶 Bezier曲线的升阶 假设有一个二次多项式：$$a_0+a_1t+a_2t^2=0$$能否找一个三次多项式近似逼近这个二次多项式，或精确地转成一个三次多项式？$$a_0+a_1t+a_2t^2+0*t^3=0$$所谓升阶就是保证曲线的形状和方向保持不变，但是要增加顶点个数 但是，伯恩斯坦基函数不是简单的$t^2、t^3$，2次Bezier基函数是$B_{i,2}$，3次是$B_{i,3}$，如何从$B_{i,2}$转化成$B_{i,3}$的形式? 所谓升阶是指保持Bezier曲线的形状与方向不变，增加定义它的控制顶点数，即提高该Bezier曲线的次数。 增加一个顶点后,仍定义同一条曲线的新控制顶点为$P_0^*,P_1^*,…,P_{n+1}^*$，则有： $$\\displaystyle\\sum^n_{i=0}C^i_nP_it^i(1-t)^{n-i}=\\displaystyle\\sum^n_{i=0}C^i_{n+1}P^*_it^i(1-t)^{n-i}$$ 新的多边形更加靠近曲线。在80年代初，有人证明如果直升阶升下去的话，控制多边形收敛这条曲线 Bezier曲线的降阶 降阶是升阶的逆过程 假设有一个三次多项式：$$a_0+a_1t+a_2t^2+a_3t^3$$能否找一个二次多项式近似逼近这个三次多项式，或精确地转成一个二次多项式？$$a_0+a_1t+a_2t^2+a_3t^3=b_0+b_1t+b_2t^2$$如果$a_3$不等于0，想找一个二次多项式精确等于它是不可能的。如果一定要降下来，那只能近似逼近 如果把$a_3t^3$扔掉，也不是不可以，但误差太大。必须想办法找到一个二次多项式，尽量逼近这个三次多项式 假定$P_i$是由$P_i^*$升阶得到，则由升阶公式有：$$P_i={n-i\\over n}P_i^*+{i\\over n}P_{i-1}^*$$ 从这个方程可以导出两个递推公式：$$\\begin{cases}P_i^*={nP_i-iP_{i-1}^* \\over n-i},\\space i=0,1,…,n-1\\\\P_{i-1}^*={nP_i-(n-i)P_i^* \\over i},\\space i=n,n-1,…,1\\end{cases}$$ 可以综合利用上面两个式子进行降解，但仍然不精确 Bezier曲线曲面升降阶的重要性 它是CAD系统之间数据传递与交换的需要 它是系统中分段（片）线性逼近的需要。通过逐次降阶，把曲面化为直线平面，便于求交和曲面绘制 它是外形信息压缩的需要。降阶处理以后可以减少存储的信息量 Bezier曲面基于Bezier曲线的讨论，可以给出 Bezier曲面的定义和性质， Bezier曲线的一些算法也可以很容易扩展到Bezier曲面的情况 Bezier曲面的定义设$p_{i,j}(0,1,…,n;j=0,1,…,m)$为$(n+1)×(m+1)$个空间点 则$m×n$的Bezier曲面定义为：$$P(u,v)=\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}P_{ij}B_{i,m}(u)B_{j,n}(v),\\space u,v∈[0,1]$$其伯恩斯坦基函数为：$$\\begin{cases}B_{i,m}(u)=C_m^i u^i(1-u)^{m-i}\\\\B_{i,n}(v)=C_n^j v^j(1-v)^{n-j}\\end{cases}$$Bezier曲面的矩阵表示式是：$$P(u,v)=\\begin{bmatrix}B_{0,n}(u) &amp; B_{1,n}(u) &amp; … &amp; B_{m,n}(u)\\end{bmatrix}\\begin{bmatrix}P_{00} &amp; P_{01} &amp; … &amp; P_{0m}\\\\P_{10} &amp; P_{11} &amp; … &amp; P_{1m}\\\\… &amp; … … &amp; …\\\\P_{n0} &amp; P_{n1} &amp; … &amp; P_{nm}\\end{bmatrix}\\begin{bmatrix}B_{0,m}(v)\\\\B_{1,m}(v)\\\\…\\\\B_{n,m}(v)\\end{bmatrix}$$上式的曲面称为$m×n$次的，在一般应用中，$n,m$不大于4 Bezier曲面的性质Bezier曲线的很多性质可推广到 Bezier曲面 Bezier曲面特征网格的四个角点正好是 Bezier曲面的四个角点，即： $$\\begin{cases}P(0,0)=P_{00}\\\\P(1,0)=P_{m0}\\\\P(0,1)=P_{0n}\\\\P(1,1)=P_{mn}\\end{cases}$$ Bezier曲面特征网格最外一圈顶点定义Bezier曲面的四条边界 几何不变性 对称性 凸包性 Bezier曲面片的拼接设两张$m×n$次Bezier曲面片：$$\\begin{cases}P(u,v)=\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}P_{ij}B_{i,m}(u)B_{j,n}(v)\\\\Q(u,v)=\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}Q_{ij}B_{i,m}(u)B_{j,n}(v)\\end{cases},\\space u,v∈[0,1]$$分别由控制顶点$P_{ij}$和$Q_{ij}$定义。 如果要求两曲面片达到$G^0$连续，则它们有公共的边界，即：$P(1,v)=Q(0,v)$ 于是有：$P_{ni}=Q_{0i},\\space (i=0,1,…,m)$ 如果又要求沿该公共边界达到G连续，则两曲面片在该边界上有公共的切平面，因此曲面的法向应当是跨界连续的，即： $$Q_u(0,v)×Q_v(0,v)=α(v)P_u(1,v)×P_v(1,v)$$ 递推(de Castel jau)算法（曲面的求值）Bezier曲线的递推(de Castel jau)算法，可以推广到Bezier曲面的情形$$P_{ij}(i=0,1,…,m;j=0,1,…,n)$$ $$P(u,v)=\\displaystyle\\sum_{i=0}^{m-k}\\displaystyle\\sum_{j=0}^{n-l}P_{i,j}^{k,l}B_{i,m}(u)B_{j,n}(v)=…=P_{00}^{m,n},\\space u,v∈[0,1]$$ 一条曲线可以表示成两条低一次曲线的组合，一张曲面可以表示成低一次的四张曲面的线性组合 其中：$$\\begin{equation}P_{i,j}^{k,l}=\\begin{cases}P_{ij},\\space (k=l=0)\\\\(1-u)P_{ij}^{k-1,0}+uP_{i+1,j}^{k-1,0},\\space (k=1,2,…,m;l=0)\\\\(1-v)P_{0,j}^{m,l-1}+vP_{0,j+1}^{m,l-1},\\space (k=m;l=1,2,…,n)\\end{cases}\\end{equation}$$或$$\\begin{equation}P_{ij}^{k,l}=\\begin{cases}P_{ij},\\space (k=l=0)\\\\(1-v)P_{ij}^{0,l-1}+vP_{i,j+1}^{0,l-1},\\space (k=0;l=1,2,…,n)\\\\(1-u)P_{i0}^{k-1,n}+uP_{i+1,0}^{k-1,n},\\space (k=1,2,…,m;l=n)\\end{cases}\\end{equation}$$ 当按（1）式方案执行时，先以u参数值对控制网格u向的n+1个多边形执行曲线 de Castel jau算法，m级递推后，得到沿v向由n+1个顶点$P^{m0}_{0j}$构成的多边形。再以v参数值对它执行曲线的 de Castel jau算法n级递推以后，得到一个$P^{mn}_{00}$即所求曲面上的点。 B样条 Bezier曲线有几点不足： 一旦确定了特征多边形的顶点数（n+1个），也就决定了曲线的阶次（n次） Bezier曲线或曲面的拼接比较复杂 Bezier曲线或曲面不能作局部修改 B样条的特点 整条曲线用一个完整的表达形式，但内在的量是一段一段的，比如一堆的3次曲线拼接，两条之间满足2次连续 这样既克服了波动现象，曲线又是低次的。既有统一的表达式，又有统一的算法 如何进行分段？ 现在有n+1个点，每两点之间构造一条多项式，n+1个点有n个小区间 每个小区间构造一条三次多项式，变成了n段的三次多项式拼接在一起，段与段之间要两次连续，这就是三次样条 如有5个点，构造一个多项式，应该是个四次多项式。现在采用样条方式构造四段曲线，每一段都是三次的，且段与段之问间要$C^2$连续 B样条的递推定义和性质B样条曲线的数学表达式为：$$P(u)=\\displaystyle\\sum_{i=0}^n{P_iB_{i,k}(u)},\\space u∈[u_{k-1},u_{n+1}]$$$P(i=0,1,…,n)$是控制多边形的顶点 $B_{i,k}(u)$称为k阶（k-1次）B样条基函数，k是刻画次数。其中k可以是2到控制点个数n+1之间的任意整数 对Bezier曲线来说，阶数和次数是一样的；但对于B样条，阶数是次数+1 B样条基函数是一个称为节点矢量的非递减的参数u的序列所决定的k阶分段多项式，这个序列称为节点向量 de boor-Cox递推定义B样条基函数可以有各种各样的定义方式，但是公认的最容易理解的是de boor-Cox递推定义 它的原理是，只要是k阶（k-1次）的B样条基函数，构造一种递推的公式，由0次构造1次，1次构造2次，2次构造3次……依次类推$$\\begin{cases} B_{i,1}(u)=\\begin{cases} 1,\\space u_i&lt;u&lt;u_{i+1}\\\\ 0,\\space Otherwise \\end{cases}\\\\ B_{i,k}(u)={u-u_i \\over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)\\end{cases},\\space 约定{0\\over 0}=0$$ 该递推公式表明：若确定第$i$个$k$阶B样条$B_{i,k}(u)$，需要用到$u_i,u_{i+1},…,u_{i+k}$共k+1个节点，称区间$[u_i，u_{i+k}]$为$B_{i,k}(u)$的支承区间 K阶B样条对应节点向量数$$deboor-Cox递推公式\\begin{cases} B_{i,1}(u)=\\begin{cases} 1,\\space u_i&lt;u&lt;u_{i+1}\\\\ 0,\\space Otherwise \\end{cases}\\\\ B_{i,k}(u)={u-u_i\\over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)\\end{cases},\\space 约定{0\\over 0}=0$$ 对于$B_{i,1}$（1阶0次基函数）来说，涉及$u_i$到$u_{i+1}$一个区间，即一阶的多项式涉及一个区间两个节点 $B_{i,2}$是由$B_{i,1}$和$B_{i+1,1}$，因此$B_{i,2}$涉及2个区间，3个节点。 $B_{i,3}$涉及3个区间，4个节点……$B_{i,k}$涉及k个区间，k+1个节点 B样条函数定义区间$$P(u)=\\displaystyle\\sum_{i=0}^n{P_iB_{i,k}(u)},\\space u∈[u_{k-1},u_{n+1}]$$ 以k=4，n=4为例，节点矢量为$$U={u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8}$$ 上图区间是$u_3$到$u_5$（从$u_{k-1}$到$u_{n+1}$），B样条基函数严重依赖于节点向量的分布 上面的曲线被分成两段：$u_3u_4,u_4u_5$。如有5个顶点$P_0、P_1、P_2、P_3、P_4$，B样条一段段过渡过去 哪些基函数是在$u_3u_4$区间里有定义？正好是$P_0P_1P_2P_3$ $P_1P_2P_3P_4$在$u_4u_5$区间里有定义，两端之间有三个顶点是一样这样就保证了两段拼接的效果非常好 B样条基函数的主要性质 局部支承性 $$B_{i,1}(u)\\begin{cases} ≥0,\\space u∈[u_i,u_{i+1}]\\\\ =0,\\space Otherwise \\end{cases};而Bezier在整个区间非0$$ 反过来，对每一个区间$(u_i,u_{i+k})$，至多只有k个基函数在其上非零 权性 $$\\displaystyle\\sum_{i=0}^n{P_iB_{i,k}(u)}≡1,\\space u∈[u_{k-1},u_{n+1}]$$ 连续性 $B_{i,k}(u)$在r重节点处的连续阶不低于$k-1-r$ 分段参数多项式 $B_{i,k}(u)$在每个长度非零的区间$[u_i,u_{i+1})$上都是次数不高于k-1的多项式，它在整个参数轴上是分段多项式 B样条函数的主要性质 局部性 k阶B样条曲线上的一点至多与k个控制顶点有关，与其它控制顶点无关 移动曲线的第$i$个控制顶点$P_i$，至多影响到定义在区间上那部分曲线的形状，对曲线其余部分不发生影响 变差缩减性 设平面内n+1个控制顶点构成B样条曲线P(t)的特征多边形。在该平面内的任意一条直线与P(t)的交点个数不多于该直线和特征多边形的交点个数 几何不变性 B样条曲线的形状和位置与坐标系的选择无关 凸包性 B样条曲线落在$P_i$构成的凸包之中。其凸包区域小于或等于同一组控制顶点定义的Bezier曲线凸包区域。 凸包就是包含右边这6个顶点的最小凸多边形。凸多边形是把多边形的每条边延长，其它边都在它的同一侧。 该性质导致顺序k+1个顶点重合时，由这些顶点定义的k次B样条曲线段退化到这一个重合点. B样条曲线类型的划分 均匀B样条曲线(uniform B-spline curve) 当节点沿参数轴均匀等距分布，即$u_{i+1}-u_i=常数&gt;0$时，表示均匀B样条函数 均匀B样条的基函数呈周期性。即给定n和k，所有的基凼数有相同形状。每个后续基函数仅仅是前面基函数在新位置上的重复：$$B_{i,1}(u)=B_{i+1,1}(u+Δu)=B_{i+2,1}(u+2Δu)$$其中，Δu是相邻节点值的间距 ※下面以均匀二次（三阶）B样条曲线为例来说明均匀周期性B样条函数的计算： 假定有四个控制点，取参数值n=3，k=3，则n+k=6，$u=(0,1,2,3,4,5,6)$ 根据de boor-Cox递推公式：$\\begin{cases} B_{i,1}(u)=\\begin{cases} 1,\\space u_i&lt;u&lt;u_{i+1}\\\\ 0,\\space Otherwise \\end{cases}\\\\ B_{i,k}(u)={u-u_i \\over u_{i+k-1}-u_i} B_{i,k-1}(u)+{u_{i+k}-u\\over u_{i+k}-u_{i+1}}B_{i+1,k+1}(u)\\end{cases}$ $B_{0,1}(u)=\\begin{cases} 1,\\space 0≤u&lt;1\\\\ 0,\\space 其它\\end{cases}$ $\\begin{split}B_{0,2}(u)&amp;=uB_{0,1}(u)+(2-u)B_{1,1}(u)\\\\&amp;=uB_{0,1}(u)+(2-u)B_{1,1}(u)\\\\&amp;=\\begin{cases} u,\\space 0≤u&lt;1\\\\ 2-u,\\space 1≤u&lt;2\\end{cases}\\end{split}$ $\\begin{split}B_{0,3}(u)&amp;={u\\over 2}B_{0,2}(u)+{(3-u)\\over 2}B_{1,2}(u-1)\\\\&amp;=\\begin{cases} {1\\over 2}u^2,\\space 0≤u&lt;1\\ {1\\over 2}u(2-u)+{1\\over 2}(u-1)(3-u),\\space 1≤u&lt;2\\\\ {1\\over 2}(3-u)^2,\\space 2≤u&lt;3\\end{cases}\\end{split}$ $B_{1,3}(u)=\\begin{cases} {1\\over 2}(u-1)^2,\\space 1≤u&lt;2\\\\ {1\\over 2}(u-1)(3-u)+{1\\over 2}(u-2)(4-u),\\space 1≤u&lt;3\\\\ {1\\over 2}(4-u)^2,\\space 3≤u&lt;4\\end{cases}$ 准均匀B样条曲线(Quasi-uniform B-spline curve) 与均匀B样条曲线的差别在于两端节点具有重复，这样的节点矢量定义了准均匀的B样条基函数 均匀B样条曲线没有保留 Bezier曲线端点的几何性质，采用准均匀的B样条曲线解决了这个问题 均匀：$u=(0,1,2,3,4,5,6)$ 准均匀：$u=(0,0,0,1,2,3,4,5,5,5)$ 分段Bezier曲线（Piecewise Bezier Curve） 节点矢量中两端节点具有重复度k，所有内节点重复度为k-1，这样的节点矢量定义了分段的 Bernstein基 B样条曲线用分段Bezier曲线表示后，各曲线段就具有了相对的独立性\\ 另外， Bezier曲线一整套简单有效的算法都可以原封不动地采用 缺点：增加了定义曲线的数据，控制顶点数及节点数 非均匀B样条曲线（non- uniform B- spline curve） 当节点沿参数轴的分布不等距，即$u_{i+1}-u_i≠常数$时，表示非均匀B样条函数 B样条曲面 给定参数轴u和v的节点矢量$\\begin{cases}U=[u_0,u_1,…,u_{m+p}]\\\\V=[v_0,v_1,…,v_{n+q}]\\end{cases}$$p×q$阶B样条曲面定义如下：$P(u,v)=\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum_{j=0}^n{P_{i,j}N_{i,p}(u)N_{j,q}(v)},\\space u∈[u_{k-1},u_{n+1}]$$P_{i,j}$构成一张控制网格，称为B样条曲面的特征网格 $N_{i,p}(u)$和$N_{j,q}(v)$是B样条基，分别由节点矢量U和V按de Boor-Cox递推公式决定 NURBS曲线（面） NURBS曲线（面）的提出 Bezier曲线（面）$\\implies$B样条曲线（面） B样条方法在表示与设计自由型曲线、曲面形状时显示了强大的威力，然而在表示与设计初等曲线、曲面时时却遇到了麻烦。B样条曲线（面）和 Bezier曲线（面）不能精确表示出抛物线以外的二次曲线（面），如圆弧、圆。 而在工程应用特别是在工业设计当中，都用到图纸。而表示图纸的元素就是直线、圆弧和一些标注信息 NURBS(Non-Uniform Rational B-Splines)：非均匀有理B样条方法，主要是为了找到与描述自由型曲线曲面的B样条方法既相统一，又能精确表示二次曲线曲面（圆弧、抛物线、椭圆等）的数学方法 NURBS一种最一般最有代表性的表示方法。既为标准解析形状（即前面提到的初等曲线曲面），又为自由型曲线曲面的精确表示与设计提供了一个公共的数学形式，广泛应用在各种3D造型系统中，如3DMAX，Maya等 NURBS曲线的定义NURBS（Non-Uniform Rational B-Splines）非均匀有理B样条的缩写 有理（Rational）函数是两个多项式之比。 因此，有理B样条可描述为：$$\\begin{split}P(u)&amp;={\\displaystyle\\sum_{i=0}^nω_iP_iB_{i,k}(u)\\over \\displaystyle\\sum_{i=0}^nω_iB_{i,k}(u)}\\\\&amp;=\\displaystyle\\sum_{i=0}^n P_iR_{i,k}(u),\\space\\space R_{i,k}(u)={ω_iB_{i,k}(u) \\over \\displaystyle\\sum_{j=0}^nω_jB_{j,k}(u)}\\end{split}$$ $ω_i$：是控制顶点的权因子。其大小决定曲线偏离控制顶点的距离。值越大，曲线越靠近控制顶点$P_i$。 NURBS曲线的性质NURBS曲线与B样条曲线具有类似的几何性质： 局部性质 变差减小性质 凸包性 在仿射与透射变换下的不变性 在曲线定义域内有与有理基函数同样的可微性 NURBS曲面的定义$\\begin{split}P(u)&amp;={\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}ω_{ij}P_{ij}B_{i,p}(u)N_{j,q}(v)\\over \\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}ω_iB_{i,p}(u)N_{j,q}(v)}\\\\&amp;=\\displaystyle\\sum^m_{i=0}\\displaystyle\\sum^n_{j=0}P_{ij}R_{i,p;j,q}(u,v),\\space u,v∈[0,1]\\end{split}$ $基函数：R_{i,p;j,q}(u,v)={ω_{ij}N_{i,p}(u)N_{j,p}(v)\\over \\displaystyle\\sum^m_{r=0}\\displaystyle\\sum^n_{s=0}ω_{rs}N_{r,p}(u)N_{s,q}(v)}$ 真实感图形学概述 简单地说，就是希望用计算机生成像照相机拍的照片一样逼真的图形图像。 要实现这个目标，需要三部曲： 建立三维场景（建模）； 消隐解决物体深度的显示及确定物体之内的相互关系； 在解决了消隐问题之后，在可见面上进行明暗光泽的处理，然后进行绘制（渲染）。 颜色模型 什么是颜色： 颜色是人的视觉系统对可见光的感知结果，感知到的颜色由光波的波长决定。 人眼对于颜色的观察和处理是一种生理和心理现象，其机理还没有完全搞清楚。 视觉系统能感觉的波长范围为380~780nm。 什么是颜色模型？ 颜色模型（空间），是表示颜色的一种数学方法，人们用它来指定颜色和标定产生的颜色。通常用三个参数表小。 几乎所有的颜色模型都是从RGB颜色模型导出 目前现有颜色模型还没有一个完全符合人的视觉感知特性、颜色本身的物理特性或发光物体和光反射物体的特性。 常用颜色模型 RGB颜色工业模型 其它颜色工业模型 主要用于彩色电视信号传输标准，主要有YIQ、YUV、 YCbCr彩色模型。 三种彩色模型中，Y分量均代表黑白亮度分量，其余分量用于显示彩色信息。这样，只需利用Y分量进行图像显示，彩色图像就转换为灰度图像 颜色视觉模型 以上彩色模型是从色度学或硬件实现的角度提出的，但用色调（Hue）、饱和度（ Saturation，也称彩度）、亮度（Illumination）三要素来描述彩色空间能更好地与人的视觉特性相匹配。 色调（Hue）：由物体反射光线中占优势的波长决定的，是彩色互相区分的基本特性。 饱和度（ Saturation）或彩度：彩色的深浅程度，它取决于彩色中白色的含量。饱和度越高，彩色越深，白色光越少。 亮度（Illumination）：光波作用于感受器所发生的效应，它取决于物体的反射系数。反射系数越大，物体亮度越大 其他颜色视觉模型 HSV（hue, saturat ion and value彩色模型 A.R. Smith根据颜色的直观特性于1978年创建的，是颜色的倒六角锥体模型。 HSL与HSV HSL采用亮度L（lightness）、HSV采用明度V（ value）作为坐标。 简单光照模型 光照模型 当物体的几何形态确定之后，光照决定了整个场景的显示结果。因此，真实感图形的生成取决于如何建立个合适的光照模型（illumination model）。 光照明模型：模拟物体表面的光照明物理现象的数学模型。 简单光照明模型只考虑光源对物体的直接光照 背景物理知识 光的传播规律反射定律 入射角等于反射角，而且反射光线、入射光线与法向量在同一平面上。 折射定律折射定律 折射线在入射线与法线构成的平面上，折射角与入射角满足： $${η_1\\over η_2}={\\sinφ \\over \\sinθ}$$ 能量关系 在光的反射和折射现象中的能量分布（满足能量守恒） Phong光照模型（环境光+漫反射光+镜面反射光） 环境光 邻近各物体所产生的光的多次反射最终达到平衡时的种光。可近似认为同一环境下的环境光，其光强分布是均匀的。 $I_{ambient}=I_aK_a\\\\I_a-环境光强度；K_a-环境光反射系数$ 漫反射光 光照射到比较粗糙的物体表面，物体表面某点的明暗程度不随观测者的位置变化，这种等同地向各个方向散射的现象称为光的漫反射。 漫反射光强近似服从Lambert定律： $I_{diffuse}=I_pK_d(L·N)\\\\I_p-点光源光强；K_d-物体表面漫反射率$ 镜面反射光 光照射到相当光滑的物体表面，就产生镜面反射光，其特点是在光滑表面会产生高光区域。 一般用Phong提出的经验模型表达： $I_{spec}=I_pK_s(R·V)^n\\\\I_p-点光源光强；K_s-物体表面某点的高光亮系数；n-镜面反射指数，1^2000，反映光滑程度$ 得出Phong光照模型：$$\\begin{split}I&amp;=I_{ambient}+I_{diffuse}+I_{spec}\\\\&amp;=I_aK_a+I_pK_d(L·N)+I_pK_s(R·V)^n\\end{split}$$结合RGB颜色模型， Phong光照明模型最终有如下的形式：$$\\begin{cases}I_r=I_{ar}K_{ar}+I_{pr}K_{dr}(L·N)+I_{pr}K_{sr}(R·V)^n\\\\I_g=I_{ag}K_{ag}+I_{pg}K_{dg}(L·N)+I_{pg}K_{sg}(R·V)^n\\\\I_b=I_{ab}K_{ab}+I_{pb}K_{db}(L·N)+I_{pb}K_{sb}(R·V)^n\\end{cases}$$ Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型，生成图象的真实度已经达到可以接受的程度。 Phone模型用来模拟光从物体表面到观察者眼睛的反射。尽管这种方法符合一些基本的物理法则，但它更多的是基于对现象的观察，所以被看成是一种经验式的方法。 在实际的应用中，由于Phonηg光照模型是一个经验模型，因此还具有以下的一些问题： 显示出的物体象塑料，无质感变化 没有考虑物体间相互反射光 镜面反射颜色与材质无关 镜面反射入射角大，会产生失真现象 增量式光照模型 为什么要进行明暗处理？ 三维物体通常用多边形（三角形）来近似模拟。 由于每一个多边形的法向一致，因而多边形内部的像素的颜色都是相同的，而且在不同法向的多边形邻接处，光强突变，使具有不同光强的两个相邻区域之间的光强不连续性（马赫带效应）。 如何进行明暗处理？ 基本思想：每一个多边形的顶点处计算出光照强度或参数，然后在各个多边形内部进行均匀插值 常用方法： Gouraud明暗处理（双线性光强插值算法） Phong明暗处理（双线性法向插值算法） Gouraud明暗处理 计算多边形顶点的平均法向量与某个顶点相邻的所有多边形的法向平均值近似作为该顶点的近似法向量，顶点A相邻的多边形有k个，它的法向量计算为： $$N_a={1\\over k}(N_1+N_2+…+N_k)$$ 用Phong光照模型计算顶点的光强 Phong光照模型出现前，采用如下光照模型计算：$$I=I_aK_a+I_pK_d(L·N_a)/(r+k)$$ 插值计算离散边上个点的光强 $$I_A=uI_1+(1-u)I_2,\\space u={AV_2\\over V_1V_2}$$$$I_B=vI_1+(1-u)I_3,\\space v={BV_3\\over V_1V_3}$$ 插值计算多边形内域中各点的光强 $$I_p=tI_A+(1-t)I_B,\\space t={PB\\over AB}$$ 求任一点的光强需进行两次插值计算 为减少计算量，采用增量计算方法 $$新扫描线：\\begin{cases}I_{A,j+1}=I_{A,j}+ΔI_A\\\\I_{B,j+1}=I_{B,j}+ΔI_B\\\\ΔI_A=(I_1-I_2)/(y_1-y_2)\\\\ΔI_B=(I_1-I_3)/(y_1-y_3)\\end{cases}$$ Gouraud明暗处理有一个最大的缺点，就是不能有镜面反射光（高光）。 双线性插值是把能量往四周均匀，平均的结果就是光斑被扩大了，本来没有光斑的地方一插值反而出现了光斑。 解决办法：Phong明暗处理 Phong明暗处理 与 Gouraud明暗处理有何不同？ 双线性光强插值&gt;&gt;双线性法向插值 以时间为代价，引入镜面反射，解决高光问题 Phong明暗处理基本步骤： 计算每个多边形顶点处的平均单位法矢量，这一步骤与Gour aud明暗处理方法的第一步相同。 用双线性插值方法求得多边形内部各点的法矢量。 最后按光照模型确定多边形内部各点的光强。 Phong明暗处理是先算角点的法向量，再算内部点的法向量最后再用新的光照模型算内部点的颜色值。 两种增量式光照模型比较 Phong方法 Gouraud方法 1、产生的效果高光明显；2、高光多位于多边形内部；3、明暗变化缺乏层次感。 1、效果并不明显；2、多边形内部无高光；3、光强度变化均匀，与实际效果更接近。 增量式光照模型总结 双线性光强插值（Gouraud模型）能有效的显示漫反射曲面，计算量小，速度快。 双线性法向插值（Phong模型）可以产生正确的高光区域，但是计算量要大的多。 增量式光照明模型的不足 物体边缘轮廓是折线段而非光滑曲线 等间距扫描线会产生不均匀效果 插值结果取决于插值方向 局部光照模型 局部光照模型：仅处理光源直接照射物体表面的光照模型。 简单光照模型是一个比较粗糙的经验模型，不足之处：镜面反射项与物体表面的材质无关。 从光电学知识和物体微平面假设出发，介绍镜面反射与物体材质有关的普遍局部光照模型。 自然光反射 自然光反射率系数可用Fresnel公式计算 $$ρ={1\\over 2}\\left({tg^2(θ-φ)\\over tg^2(θ+φ)}+{sin^2(θ-φ)\\over sin^2(θ+φ)}\\right)$$ θ是入射角，若发生反射的物体表面两侧折射率分别为和$n_1，n_2$那么φ满足这样的一个式子：$\\sin φ={n_1\\over n_2}\\sin θ$ 反射率与折射率有关，是波长的函数$ρ(θ,λ)$ 光反射率 微观情况下，物体表面粗糙不平。 宏观上看，这是一个平面，法向朝上。实际上它是由许多微小平面构成的，微小平面的法向是各异的。 微平面是理想镜面，反射率可用Fresnel公式计算，而粗糙表面的反射率与表面的粗糙度有关。 实际物体反射率：$DGρ(θ,λ)$ D为微平面法向的分布函数 G为由于微平面的相互遮挡或屏蔽而使光产生的衰减因子 Torrance和Sparrow采用Gauss分布函数模拟法向分布： $D=ke^{(-a/m)^2}$ k为常系数 a为微平面的法向与平均法向的夹角，即(N·H) m为微平面斜率的均方根，表示表面的粗糙程度 $m=\\sqrt{m_1^2+m_2^2+…+m_n^2\\over n}$ 也可采用Berkmann分布函数 光的衰减 衰减因子G在局部光照明模型中也可以反映物体表面的粗糙程度。 衰减因子是由于微平面的相互遮挡或屏蔽而产生的 微平面相互遮挡的光衰减因子G，有三种情况： 推导 Cook和Torrance于1981年提出了局部光照模型。 $R_{bd}$表示物体对入射光的反射率系数$$R_{bd}={I_r\\over E_i}$$ $I_r$—反射光的光强 $E_i$—单位时间内单位面积上的入射光能量 入射光能量$E_i$，可用入射光的光强$I_i$和单位面积向光源所张的立体角$dω$表示为： $$E_i=I_i\\cosθ·dω=I_i(N·L)dω$$ 于是有反射光光强 $$I_r=R_{bd}E_i=R_{bd}I_i(N·L)dω$$ 反射率系数可表示为漫反射率与镜面反射率的代数和：$$R_{bd}=K_dR_d+K_sR_s$$ $K_d+K_s=1$ 漫反射与镜面反射系数 物体表面的漫反射率：$R_d=R_d(λ)$ 物体表面的镜面反射率：$R_s={DGρ(θ,λ)\\over\\pi(N·L)(N·V)}$ 总结 加入环境光的计算，局部光照模型表示为：$$I_r=I_aK_a+I_i(N·L)dω(K_dR_d+K_sR_s)$$ $I_r$物体表面反射光强 $I_aK_a$表示环境光的影响 最后一项是考虑了物体表面性质后的反射光强度量，是该局部光照模型的复杂性与普遍性所在。 相对于简单光照模型而言 基于入射光能量导出的光辐射模型 反映表面的粗糙度对反射光强的影响 高光颜色与材料的物理性质有关 改进入射角很大时的失真现象 考虑了物体材质的影响，可以模拟磨光的金属光泽 光透射模型 简单和局部光照模型没有考虑光的透射现象 适用于场景中有透明或者半透明的物体的光照处理 早期用颜色调和法进行模拟 Whitted光透射模型 1980年Whitted提出了第一个整体光照模型，并给出了一般光线跟踪算法的范例，综合考虑了光的反射、折射、透射和阴影等。被认为是计算机图形领域的一个里程碑。 在简单光照明模型的基础上，加上透射光项就得到Whitted光透射模型：$$I=I_a·K_a+I_p·K_d·(L·N)+I_p·K_s·(R·V)^n+I’_t·K’_t$$再加上镜面反射光项，就得到Whitted整体光照模型：$$I=I_a·K_a+I_p·K_d·(L·N)+I_p·K_s·(R·V)^n+I’_t·K’_t+I’_s·K’_s$$ 整体光照模型 简单和局部光照模型不能很好地模拟光的折射、反射和阴影等，也不能用来表示物体间的相互光照影响 整体光照模型是更精确的光照模型，主要有光线跟踪和辐射度两种方法。 光线跟踪（Ray tracing） 光线跟踪算法是真实感图形学中的主要算法之一，该算法具有原理简单、实现方便和能够生成各种逼真的视觉效果等突出的优点，综合考虑了光的反射、折射、阴影等 光线跟踪怎么停止？ 在算法应用的意义上，可以有以下几种终止条件。 该光线未碰到任何物体 该光线碰到了背景光线在经过许多次反射和折射以后，就会产生衰减 光线对于视点的光强贡献很小 光线反射或折射次数即跟踪深度大于一定值 光线跟踪的缺陷 光线跟踪方法由于要进行大量的求交运算，且每一条射线都要和所有的物体求交，因此效率很低，需要耗费大量的计算时间。 光线跟踪方法可以进行加速 提是高求交速度：针对性的几何算法、…… 减成少求交次数：包围盒、空间索引、…… 减少光线条数：颜色插值、自适应控制、…… 采用广义光线和采用并行算法等 纹理映射 在真实感图形学中，可以用下列两种方法来定义纹理： 图象纹理：将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值。 函数纹理：用数学函数定义简单的二维纹理图案，如方格地毯；或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理。 纹理映射（Texture Mapping）：通过将数字化的纹理图像覆盖或投射到物体表面，而为物体表面增加表面细节的过程。 颜色纹理坐标转换通常使用下列两种方法： 在绘制一个三角形时，为每个顶点指定纹理坐标，角形内部点的纹理坐标由纹理三角形的对应点确定。 即指定：$$\\begin{split}(x_0,y_0,z_0)\\implies(u_0,v_0)\\\\(x_1,y_1,z_1)\\implies(u_1,v_1)\\\\(x_2,y_2,z_2)\\implies(u_2,v_2)\\end{split}$$ 指定映射关系：$$\\begin{split}u=a_0x+a_1y+a_2z+a_3\\\\v=b_0x+b_1y+b_2z+b_3\\end{split}$$ 几何纹理使用一个称为扰动函数的数学函数进行定义 扰动函数通过对景物表面各采样点的位置作微小扰动来改变表面的微观几何形状。 设景物表面由下述参数方程定义：$Q=Q(u,v)$ 则表面任一点(u,v)处的法线为：$N=N(u,v)={Q_u^(u,v)×Q_v(u,v)\\over |Q_u^(u,v)×Q_v(u,v)|}$ 设扰动函数为：$P(u,v)$ 扰动后的表面为：$Q’=Q(u,v)+P(u,v)N$ 阴影处理 本影 umbra-本影区：场景中的一个点P，如果它不被光源的任何部分所照射到，就称为在本影区里。本影就是不被任何光原所照到的区域。 半影 Occluder-遮挡物：阴影的生成是因为空间有遮挡物。这些遮挡物把光源挡住了，所以在receivers上有些部分就很阴暗 阴影是本影和半影的组合。求出本影和半影的并集(union)来绘出阴影 阴影 自身阴影：由于物体自身的遮挡而使光线照射不到它上面的某些面； 投射阴影：由于物体遮挡光线，使场景中位于它后面的物体或区域受不到光照射而形成的。 阴影算法 阴影体法(Shadow Volume) 由一个点光源和一个三角形可以生成一个无限大的阴影体。落在这个阴影体中的物体，就处于阴影中。 在对光线进行跟踪的过程中，如果这条射线穿过了阴影体的一个正面（朝向视点的一个面），则计数器加1.如果这条射线穿过了阴影体的一个背面（背向视点的一个面），则计数器减1.如果最终计数器的数值大于0，则说明这个像素处于阴影中，否则处于阴影之外。 阴影图法(Shadow Mapping) 这种方法的主要思想是使用Z缓冲器算法，从投射阴影的光源位置对整个场景进行绘制。 这时，对于Z缓冲器的每一个像素，它的z深度值包括了这个像素到距离光源最近点的物体的距离。一般将Z缓冲器中的整个内容称为阴影图(Shadow Map)，有时候也称为阴影深度图。 为了使用阴影图，需要对场景进行次绘制，不过这次是从视点的角度来进行的。 在对每个图元进行绘制的时候，将它们的位置与阴影图进行比较，如果绘制点距离光源比阴影图中的数值还要远，那么这个点就在阴影中，否则就不在阴影中。 "},{"title":"数据库概述","date":"2020-04-28T16:00:00.000Z","url":"/blogs/2020/04/29/dataBase/","tags":[["大数据","/blogs/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"]],"categories":[["SQL","/blogs/categories/SQL/"]],"content":"数据库系统概念 数据（Data） 数据是数据库存储的基本对象。是描述现实世界中各种具体事物或抽象概念的、可存储，并具有明确意义的符号记录。 数据库（DataBase，简称为DB） 简单的说，数据库就是相互关联的数据集合。严格的说，数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性。 数据库管理系统（DBMS）它的主要功能包括以下几个方面： 数据定义功能： DBMS提供数据定义语言（DDL），用户通过它可以方便地在数据库中定义数据对象（包括表、视图、索引、存储过程等）和数据的完整性约束等。 数据操纵功能： DBMS提供数据操纵语言（DML），用户可以通过它对数据库的数据进行增加、删除、修改和查询操作，简称为“增、删、改、查询”，对应于SQL语言的4个命令，即INSERT、DELETE、UPDATE和SELECT。 数据控制功能： DBMS提供了数据控制语言（DCL），用户可以通过它完成对用户访问数据权限的授予和撤消，即安全性控制；解决多用户对数据库的并发使用所产生的事务处理问题，即并发控制；数据库的转储、恢复功能；数据库的性能监视、分析等功能。 数据库系统（DBS）： 数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库（DB）、数据库管理系统（DBMS）、应用系统和数据库管理员（DBA）构成。 数据库应用系统（DBAS）： 数据库应用系统主要是指实现业务逻辑的应用程序。 数据库系统的用户 数据库管理员（DBA）DBA的具体职责包括： 参与数据库的设计 定义数据的安全性要求和完整性约束条件 日常维护：定期备份数据 、监视数据库的运行 、确保正常运转时所需的空余磁盘空间，并且在需要时升级磁盘空间。 数据库的改进和重组、重构 数据库用户 最终用户最终用户是现实系统中的业务人员，是数据库系统的主要用户。 专业用户专业用户包括工程师、科学家、经济学家等具有较高科学技术背景的人员。 系统分析员和数据库设计人员 应用程序员 数据模型数据库设计数据抽象的过程即是数据库设计的过程，具体的步骤如下 第1步：根据用户需求，设计数据库的概念模型，这是一个“综合”的过程。 第2步：根据转换规则，把概念模型转换成数据库的逻辑模型，这是一个“转换”的过程。 第3步：根据用户的业务特点，设计不同的外部模型，给应用程序使用。也就是说，应用程序使用的是数据库外部模型中的各个视图。 第4步：数据库实现时，要根据逻辑模型设计其内部模型。 概念模型概念模型在这4种模型中抽象级别最高。 其特点如下： 概念模型表达了数据库的整体逻辑结构，它是企业管理人员对整个企业组织的全面概述。 概念模型是从用户需求的观点出发，对数据建模。 概念模型独立于硬件和软件。 概念模型是数据库设计人员与用户之间进行交流的工具。 现在采用的概念模型主要是实体-联系模型，即E-R模型。E-R模型主要用E-R图来表示。 实体是现实世界或客观世界中可以相互区别的对象，这种对象可以是具体的，也可以是抽象的。 联系是两个或多个实体间的关联。两个实体之间的联系可以分为三种： 一对一联系（1：1） 一对多联系（1：n） 多对多联系（m：n） 逻辑模型逻辑模型具有下列特点： 逻辑模型表达了数据库的整体逻辑结构，但它是设计人员对整个企业组织数据库的全面概述。 逻辑模型是从数据库实现的观点出发，对数据建模。 逻辑模型硬件独立，但软件依赖。 逻辑模型是数据库设计人员与应用程序员之间进行交流的工具。 逻辑模型有层次模型、网状模型和关系模型3种。现在使用的关系型数据库管理系统（RDBMS）均采用关系数据模型。 外部模型外部模型具有如下特点： 外部模型是逻辑模型的一个逻辑子集。 硬件独立，软件依赖。 外部模型反映了用户使用数据库的观点。 从整个系统考察，外部模型具有下列特点： 简化了用户的观点。 有助于数据库的安全性保护。 外部模型是对概念模型的支持。 内部模型内部模型又称为物理模型，是数据库最底层的抽象，它描述数据在磁盘上存储方式、存取设备和存取方法。内部模型是与硬件和软件紧密相连的。 可以不必考虑内部级的设计细节，由系统自动实现。 关系模型${\\color{red}※}$数据模型的三要素 数据结构 数据结构是所描述的对象类型的集合。现在常用的是关系数据模型。 数据结构是对系统静态特性的描述。 数据操作 数据操作是指对数据库表中记录的值允许执行的操作集合，数据库对数据的操作主要有增、删、改、查询4种操作。 数据操作是对系统动态特性的描述。 数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。用以保证数据的正确、有效、相容。 数据结构 关系（Relation）：一个关系就是一张规范的二维表 。 元组（Tuple）：表中的一行即为一个元组。 属性（Attribute）：表中的一列即为一个属性，每个属性都有一个属性名。 码或键（Key）：也称为关键码或关键字。表中的某个属性或者属性的组合，能唯一的确定一个元组。 关系模式： 对关系的描述，一般表示为： 关系名（属性1，属性2，属性3，……，属性n） 操作与完整性约束关系的完整性约束条件包括三大类： 实体完整性 参照完整性 用户定义的完整性 数据库体系结构三级结构 用户级数据库 用户级对应于外模式，是最接近用户的一级，是用户看到和使用的数据库，又称为用户视图。 概念级数据库 概念级数据库对应于概念模式，介于用户级和物理级之间，是数据库管理员看到和使用的数据库，又称DBA视图。 物理级数据库 物理级数据库对应于内模式，是数据库的底层表示，它描述数据的实际存储组织，是最接近于物理存储的级，又称内部视图。 三级模式 概念模式 概念模式又称为模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只能有一个概念模式。 外模式 外模式又称为子模式或用户模式，是数据库用户（包括程序员和最终用户）能够看到和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式。 内模式 内模式又称为存储模式或物理模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只能有一个内模式。 二级映射与数据独立性 数据库系统的二级映射 数据库系统的二级映射是：外模式/模式映射和模式/内模式映射。 数据独立性 物理独立性物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是独立的。物理独立性是通过模式/内模式映射来实现的。 逻辑独立性逻辑独立性是指用户的应用程序与逻辑结构是相互独立的。逻辑独立性是通过外模式/模式映射来实现的。 数据库应用系统的开发架构 C/S模式 客户/服务器(Client/Server)，C/S模式是一种流行的解决分布式问题的架构模式。C/S模式通过网络环境，将应用划分为前台和后台两个部分。 两层C/S模式 三层C/S模式 B/S模式（浏览器/服务器模式） 高级数据库系统 分布式数据库系统 面向对象数据库系统 并行数据库系统 多媒体数据库系统 数据仓库技术与数据挖掘技术 数据仓库 数据仓库（Data Warehouse，DW）是一个面向主题的、集成的、稳定的、随时间不断变化的数据集合，它用于支持经营管理中的决策制定过程。 联机分析处理 OLAP可以对大量的多给数据进行动态合并和分析，是决策支持领域的一部分。 数据挖掘 数据挖掘（Date Mining）是从大量数据中提取隐含在其中的、人们事先不知道的但又可能有用的信息和知识的过程。 非关系型数据库NoSQL NoSQL概述： NoSQL是非关系型数据存储的广义定义。它打破了长久以来关系型数据库与事务ACID理论大一统的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取上具备关系型数据库无法比拟的性能优势。 NoSQL相关理论： CAP理论是NoSQL数据库的基石。CAP理论指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容忍性），三者不可兼得。 一个分布式系统无法同时满足一致性、可用性、分区容忍性三个特点，最多只能实现其中两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式使系统达到最终一致性。 NoSQL数据库模型 Key-Value存储模型 文档存储模型 图存储模型 BigTable存储模型 关系代数 传统的集合运算，包括并、交、差。 专门的关系运算，包括对关系进行 垂直分割（投影） 水平分割（选择） 关系的结合（连接、自然连接）等 基本操作并（Union）设关系R和S具有相同的关系模式，R和S的并是由属于R或属于S的所有元组构成的集合，记为R∪S。 形式定义如下：$$R∪S={t|t\\in R \\lor t\\in S}$$ 关系的并操作对应于关系的插入或添加记录的操作，俗称“+”操作，是关系代数的基本操作。 例： R S R∪S X Y Z X Y Z X Y Z x1 y1 z1 x1 y1 z2 x1 y1 z1 x1 y3 z2 x1 y3 z2 x1 y3 z2 x2 y3 z3 x2 y3 z3 x1 y1 z2 x2 y3 z3 差（Difference）设关系R和S具有相同的关系模式，R和S的差是由属于R但不属于S的元组构成的集合，记为R-S。 形式定义如下：$$R-S={t|t \\in R \\land t \\in S }$$关系的差操作对应于关系的删除记录的操作，俗称“-”操作，是关系代数的基本操作。 例： R S R-S X Y Z X Y Z X Y Z x1 y1 z1 x1 y1 z2 x1 y1 z1 x1 y3 z2 x1 y3 z2 x2 y3 z3 x2 y3 z3 笛卡尔积（Extended Cartesian Product）设关系R和S的属性个数（即列数）分别为r和s，R和S的笛卡儿积是一个（r+s）列的元组集合，每个元组的前r个列来自R的一个元组，后s个列来自S的一个元组，记为R×S。形式定义如下：$$\\begin{split}R{\\color{red}×}S={\\hat{t_rt_s}|t \\in R \\land t \\in S}\\end{split}$$ 关系的广义笛卡尔积操作对应于两个关系记录横向合并的操作，俗称“×”操作，是关系代数的基本操作。 R S R×S X Y Z X Y Z R.X R.Y R.Z S.X S.Y S.Z x1 y1 z1 x1 y1 z2 x1 y1 z1 x1 y1 z2 x1 y3 z2 x1 y3 z2 x1 y1 z1 x1 y3 z2 x2 y3 z3 x2 y3 z3 x1 y1 z1 x2 y3 z3 x1 y3 z2 x1 y1 z2 x1 y3 z2 x1 y3 z2 x1 y3 z2 x2 y3 z3 x2 y3 z3 x1 y1 z2 x2 y3 z3 x1 y3 z2 x2 y3 z3 x2 y3 z3 投影（Projection）关系R上的投影是从R中选择出若干属性列组成新的关系。 形式定义如下： $$\\Pi_A(R) = {t[A]|t \\in R}$$ 其中A为R中的属性列。是关系代数的基本操作。 例：对S关系，计算$\\Pi_{3,1}(S)$ S $\\Pi_{3,1}(S)$ A B C C A 2 5 7 7 2 4 6 8 8 4 3 5 9 9 3 选择（Selection）关系R上的选择操作是从R中选择符合条件的元组。 形式定义如下:$$\\sigma_F(R)={t|t \\in R \\land F(t)=true}$$ 其中： F表示选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”。 逻辑表达式F的基本形式为：$XθY[φX \\space θY…]$ θ表示比较运算符：$、、、、、≥、≤、&gt;、&lt;、=、≠$ φ表示逻辑运算符：﹁(非)、∧(与)、∨(或) X、Y是属性名，属性名也可用它的序号代替(如1、2……)。 是关系代数的基本操作。 例： R $\\eth_{C&gt;’6’}(R)$ A B C A B C 2 4 6 3 5 7 3 5 7 4 6 8 4 6 8 组合操作交（Intersection）设关系R和S具有相同的关系模式，R和S的交是由属于R又属于S的元组构成的集合，记为R∩S。形式定义如下：$$R \\cap S={t|t\\in R \\land t \\in S}$$ 关系的交可以用差来表示，即$R \\cap S=R-(R-S)$。关系的交操作对应于寻找两关系共有记录的操作，是一种关系查询操作。 例： R S $R \\cap S$ X Y Z X Y Z X Y Z x1 y1 z1 x1 y1 z2 x1 y3 z2 x1 y3 z2 x1 y3 z2 x2 y3 z3 x2 y3 z3 x2 y3 z3 连接（Join）连接也称为θ连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。 记作：$$R {_{A \\theta B}^{\\space\\space\\Join}} S={\\hat{t_rt_s}|t_r\\in R∧t_s\\in S\\land t_r[A]\\space θ\\space t_s[B]}$$连接运算从R和S的笛卡尔积R×S中选取（R关系）在A属性组上的值与（S关系）在B属性组上值满足比较关系θ的元组。 因此：$$R {_{A \\theta B}^{\\space\\space\\Join}} S=\\sigma _{A \\theta B}(R×S)$$ 等值连接等值连接是θ为”＝”的连接运算。它是从关系R与S的笛卡尔积中，选取A、B属性值相等的那些元组。等值连接表示为：$$R {_{A=B}^{\\space\\space\\Join}} S={\\hat{t_rt_s}|t_r\\in R∧t_s\\in S∧t_r[A]=t_s[B]}$$ $$为此：R {{A=B}^{\\space\\space\\Join}} S=\\sigma{A=B}(R×S)$$ 自然连接自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。即若R和S具有相同的属性组B，则自然连接可记作：$$R\\Join S={\\hat{t_rt_s}[\\bar{B}]|t_r\\in R∧t_s\\in S∧t_r[A]=t_s[B]}$$ $$为此：R\\Join S=\\Pi_{\\bar{B}}(\\sigma_{R.B=S.B}(R×S))$$ 例： 关系R 关系S A B C B E a1 b1 5 b1 3 a1 b2 6 b2 7 a2 b3 8 b3 10 a2 b4 12 b4 2 b5 2 $R {_{C&lt;E}^{\\space\\space\\Join}} S$ A R.B C S.B E a1 b1 5 b2 7 a1 b1 5 b3 10 a1 b2 6 b2 7 a1 b2 6 b3 10 a2 b3 8 b3 10 等值连接： $R {_{R.B=S.B}^{\\space\\space\\space\\space\\Join}} S$ A R.B C S.B E a1 b1 5 b1 3 a1 b2 6 b2 7 a2 b3 8 b3 10 a2 b4 12 b4 2 自然连接： $R\\Join S$ A B C E a1 b1 5 3 a1 b2 6 7 a2 b3 8 10 a2 b3 8 2 除(Division)概念引入 分量：设关系模式为$R(A_1, A_2, …, A_n)$。它的一个关系设为R。 $t\\in R$表示t是R的一个元组。$t[A_i$]则表示元组t中相应于属性$A_i$的一个分量。 象集：给定一个关系R(X，Z)，X和Z为属性组。 可以定义，当$t[X]=x$时，x在R中的象集为：$Z_x={t[Z]|t∈R,t[X]=x}$ 它表示R中属性组X上值为x的诸元组在Z上分量的集合。 计算$R÷S$的操作步骤为： 将关系R和关系S的属性进行划分，即$、R(X,Y)、S(Y,Z)$; 若X的某个值x的像集$Y_x$包含S表中所有元组，则将x放入结果集中。 说明： 除操作是同时从行和列角度进行运算。除操作适合于包含“对于所有的/全部的”语句的查询操作。 例： R S R÷S A $\\color{red}B$ $\\color{red}C$ $\\color{red}B$ $\\color{red}C$ D A $\\color{blue}a1$ $\\color{blue}b1$ $\\color{blue}c2$ $\\color{blue}b1$ $\\color{blue}c2$ d1 a1 $\\color{green}a2$ $\\color{green}b3$ $\\color{green}c5$ $\\color{blue}b2$ $\\color{blue}c1$ d1 a3 b4 c4 $\\color{blue}b2$ $\\color{blue}c3$ d2 $\\color{blue}a1$ $\\color{blue}b2$ $\\color{blue}c3$ a4 b6 c4 $\\color{green}a2$ $\\color{green}b2$ $\\color{green}c3$ $\\color{blue}a1$ $\\color{blue}b2$ $\\color{blue}c1$ 在关系R中，A可以取四个值${a1, a2, a3, a4}$ a1的象集为${(b1,c2), (b2,c3), (b2,c1)}$ a2的象集为${(b3,c5), (b2,c3)}$ a3的象集为${(b4,c4)}$ a4的象集为${(b6,c4)}$ S在(B,C)上的投影为{(b1,c2), (b2,c3), (b2,c1)} 显然只有a1的象集$(B,C)_{a1}$包含S在$(B,C)$属性组上的投影，所以$R÷S={a1}$ "},{"title":"Adobe Audition 录音后期技巧","date":"2020-02-14T16:00:00.000Z","url":"/blogs/2020/02/15/audition/","tags":[["影视","/blogs/tags/%E5%BD%B1%E8%A7%86/"]],"categories":[["音频后期","/blogs/categories/%E9%9F%B3%E9%A2%91%E5%90%8E%E6%9C%9F/"]],"content":"振幅与限压 - 语音音量级别 目标音量级别：调整音量 电平值：调小 减少噪声（呼吸声）/ 调大 增加噪声（呼吸声） 匹配响度 央视《电视节目音频制作的响度规范》基于ITU-RBS.1700-2 规定响度：-24LUFS 容差：2LU 最高实际峰值电平：-2dBTP EQ均衡器 频段 衰减 提升 60 ~ 100Hz 消除低频噪音 增加低频噪音 150 ~ 350Hz 减少浑浊感 温暖感、厚度（250 ~ 450Hz） 1kHz ± 减弱鼻音 突出声音 5 ~ 8kHz 削弱齿音（刺耳） 突出人声 10kHz ± 变暗 明亮、磁性 "},{"title":"如何搭建一个简单博客","date":"2020-02-13T16:00:00.000Z","url":"/blogs/2020/02/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","tags":[["创作","/blogs/tags/%E5%88%9B%E4%BD%9C/"]],"categories":[["博客","/blogs/categories/%E5%8D%9A%E5%AE%A2/"]],"content":"如何搭建一个博客准备工作大体流程和所需工具 安装Node.js 选择一个博客框架并用js下载资源 创建在线网页存储项目 安装git（或TortoiseGit） 在Github上创建项目并启用Github Page 将框架和文档通过git上传至项目中 写文章并通过git上传 安装Node.js搜索Node.js进入官网下载LTS版本，安装过程保持默认即可 搭建博客框架 这里以docsify框架为例。也有诸如GitBook、Hexo等其他框架，用法大同小异。目前的框架虽然结构简单，但满足基本需求，而且很容易上手。 搜索这个框架，查看帮助文档内的搭建步骤。 利用node.js安装框架 首先创建一个文件夹，用于存放框架文件，这里我命名为”MyBlog”。这里可以看到文件夹的路径，让我们把它复制下来。 右键任务栏的开始图标，选择Windows PowerShell(管理员)，输入 cd [之前复制的路径]，这样下载的资源就会存在这个目录底下。 接着按照帮助文档，输入指令回车，会调用js下载资源，等待下载完成即可。 初始化项目 在PowerShell中输入指令 之后文件夹中会出现docs文件夹，里面包含三个初始文件，并且框架搭建已经完成，可以按照提示进行本地运行 按照提示输入docsify serve ./docs后，在浏览器内粘贴复制的本地查看地址（默认为 ） 即可实时查看保存后的搭建效果，在PowerShell界面按下Ctrl + C可退出本地预览 了解资源结构回到docs文件夹内，打开README.md这个文档即为博客首页，可以修改其内容。 打开index.html，自带默认内容，帮助文档中包含了其他可添加配置项，限于篇幅，具体请参照其中内容。修改name属性的内容为’我的博客名’ 保存文档后即可查看本地效果 至此博客的初步搭建已经完成。 [!warning|style:flat|label:注意|labelVisibility:visible|iconVisibility:visible]除中文外的标点符号均为英文标点，html属性之间需要逗号分隔，否则会导致出错 创建并设置在线网页存储项目 TortoiseGit基于Git，Git使用代码指令操作，而TortoiseGit增加了可视化的界面操作，更容易上手。 以TortoiseGit为例，首先搜索下载并安装TortoiseGit，随后可以选择安装对应的语言翻译包。 在Github开源网站上用自己的账户创建一个空白的项目，会得到一个项目的链接，现在先不要关闭这个网页 在博客文件夹中，右键选择Git 在这里创建版本库，创建一个新的版本库 接着继续右键，设置库的内容 将之前网页得到的链接复制到这个文本框内保存，添加后若有提示，点否 到这一步，在线存储工作就准备完毕，在右键菜单内，选择Git提交 -&gt; &quot;master&quot;，并勾选所有文件修改 等待提交完成后，刷新之前的网页，发现在线库中出现了之前上传的docs文件夹 最后，点击菜单最后的Setings进入设置界面，在GithubPage中，将Source选项选择第二项master branch /docs folder并保存。会出现绿色消息框，里面的链接即为生成的网页在线地址。 至此搭建博客网页的全流程结束。 若以后更新博客内容，直接在文件内选择Git提交 -&gt; &quot;master&quot;，勾选所有文件修改 即可完成。"},{"title":"分类","date":"2020-10-16T12:18:18.908Z","url":"/blogs/categories/index.html","categories":[[" ",""]]},{"title":"关于我","date":"2020-10-16T12:18:18.908Z","url":"/blogs/about/index.html","categories":[[" ",""]],"content":"聪聪学长 男的、活的、不吃人 男/1999.07.23 本科/三明学院/数字媒体技术 QQ：2247770466 技能清单 平面设计：PhotoShop/Illustrator 桌面开发：C#/WPF Web开发：html/Javascript/Node 再说点我是居住在福州的IT技术与游戏开发爱好者，欢迎来到我的个人领域。给您劈个叉吧！ 这儿用于保存我在学校或者自发学习过程中的收获和成果，以及各种闲谈扯皮。这些东西不会很高大上，但相信会很有趣。希望能够留下，值得为之保留的东西，打磨自己、分享给需要的人。"},{"date":"2020-10-16T12:18:18.909Z","url":"/blogs/css/darkmode.css","categories":[[" ",""]],"content":"@media (prefers-color-scheme:dark) { :root { --color-mode: 'dark' } :root:not([data-user-color-scheme]) { --main-color: #eb5757; --bg-color: #181c27; --bg-content-color: #232222; --bg-menu: #3e4b5e; --bg-tag-color: #696969; --bg-cat-color: #789; --bg-codeblock: #000; --bg-code: #3e4b5e; --body-color: rgba(255, 255, 255, 0.8); --title-color: rgba(252, 252, 252, 0.9); --border-color: rgba(255, 255, 255, 0.1) } :root:not([data-user-color-scheme]) blockquote { border-left: .25em solid rgba(255, 255, 255, .5); color: rgba(255, 255, 255, .5) } :root:not([data-user-color-scheme]) .post__license { background-color: rgba(255, 255, 255, .2) } :root:not([data-user-color-scheme]) .post__content img { opacity: .8; -webkit-filter: brightness(.8) contrast(1.2); filter: brightness(.8) contrast(1.2) } :root:not([data-user-color-scheme]) .post__content img:hover { opacity: 1; -webkit-filter: none; filter: none } :root:not([data-user-color-scheme]) table tr:not(.code):not(.gutter):nth-child(2n) { background-color: #353535 } } [data-user-color-scheme=dark] { --color-mode: 'dark'; --main-color: #eb5757; --bg-color: #181c27; --bg-content-color: #232222; --bg-menu: #3e4b5e; --bg-tag-color: #696969; --bg-cat-color: #789; --bg-codeblock: #000; --bg-code: #3e4b5e; --body-color: rgba(255, 255, 255, 0.8); --title-color: rgba(252, 252, 252, 0.9); --border-color: rgba(255, 255, 255, 0.1) } [data-user-color-scheme=dark] blockquote { border-left: .25em solid rgba(255, 255, 255, .5); color: rgba(255, 255, 255, .5) } [data-user-color-scheme=dark] .post__license { background-color: rgba(255, 255, 255, .2) } [data-user-color-scheme=dark] .post__content img { opacity: .8; -webkit-filter: brightness(.8) contrast(1.2); filter: brightness(.8) contrast(1.2) } [data-user-color-scheme=dark] .post__content img:hover { opacity: 1; -webkit-filter: none; filter: none } [data-user-color-scheme=dark] table tr:not(.code):not(.gutter):nth-child(2n) { background-color: #353535 }"},{"title":"友情链接","date":"2020-10-16T12:18:18.909Z","url":"/blogs/friends/index.html","categories":[[" ",""]]},{"title":"搜索","date":"2020-10-16T12:18:18.910Z","url":"/blogs/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2020-10-16T12:18:18.910Z","url":"/blogs/tags/index.html","categories":[[" ",""]]}]